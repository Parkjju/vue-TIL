(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{315:function(t,s,a){t.exports=a.p+"assets/img/4-1.90672816.jpeg"},316:function(t,s,a){t.exports=a.p+"assets/img/4-2.c18e972e.jpeg"},652:function(t,s,a){"use strict";a.r(s);var e=a(6),c=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"tcp-ip-프로토콜-스택"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip-프로토콜-스택"}},[t._v("#")]),t._v(" TCP / IP 프로토콜 스택")]),t._v(" "),s("p",[s("code",[t._v("TCP/IP")]),t._v("는 "),s("code",[t._v("프로토콜 스택이다.")]),t._v(" 프로토콜이 스택 형태로 쌓여 있다는 것을 의미한다. 인터넷 기반이 데이터 송수신을 목적으로 설계된 스택을 의미한다.")]),t._v(" "),s("p",[t._v("소켓 프로그래밍 기준으로는 데이터 송수신 과정을 네 영역으로 계층화하여 이야기 할 수도 있다.")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("LINK 계층")]),t._v(": 물리적인 계층")]),t._v(" "),s("li",[s("code",[t._v("IP 계층")]),t._v(": 라우팅 알고리즘 표준화, 경로 설정")]),t._v(" "),s("li",[s("code",[t._v("TCP 계층 or UDP 계층")]),t._v(": 구체적인 데이터 전송 방식의 구분")]),t._v(" "),s("li",[s("code",[t._v("APPLICATION 계층")]),t._v(":")])]),t._v(" "),s("blockquote",[s("p",[t._v("OSI 7 계층 모델은 물리 계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층으로 구성되어 있다.")])]),t._v(" "),s("p",[t._v("각 영역은 영역별로 전문화 되어 있으며, 동시에 표준화 되어 있다. 라우터는 IP계층에서 동작하는데 IP계층에서 따르는 라우팅 알고리즘을 라우터 내에 적용해야 하는 것이 바로 표준화가 갖는 의미이다.")]),t._v(" "),s("p",[t._v("소켓을 생성하면 보통 "),s("code",[t._v("LINK")]),t._v(", "),s("code",[t._v("IP")]),t._v(", "),s("code",[t._v("TCP & UDP")]),t._v(" 계층까지 자동화해준다. 개발자는 "),s("code",[t._v("APPLICATION")]),t._v(" 계층에서 컨트롤만 잘 해주면 된다. 전송 형태를 개발자가 정의하고 소켓 생성 및 데이터 전송 타이밍, 형태 등 다양하게 직접 커스텀해주면 된다.")]),t._v(" "),s("h2",{attrs:{id:"tcp-서버의-함수-호출-순서"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-서버의-함수-호출-순서"}},[t._v("#")]),t._v(" TCP 서버의 함수 호출 순서")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("socket()")]),t._v(": 소켓 생성")]),t._v(" "),s("li",[s("code",[t._v("bind()")]),t._v(": 소켓 주소 할당, bind 호출 단계 까지는 소켓의 용도가 결정되지 않은 상태이다.")]),t._v(" "),s("li",[s("code",[t._v("listen()")]),t._v(": 연결요청 대기, 해당 단계를 통해 리스닝 소켓 (서버 소켓)이라는 정체성이 확립된다.")]),t._v(" "),s("li",[s("code",[t._v("accept()")]),t._v(": 연결 허용")]),t._v(" "),s("li",[s("code",[t._v("read() / write()")]),t._v(": 데이터 송수신")]),t._v(" "),s("li",[s("code",[t._v("close()")]),t._v(": 연결 종료")])]),t._v(" "),s("p",[t._v("연결 요청 대기 상태로 진입하는 "),s("code",[t._v("listen")]),t._v("함수가 중요하다.")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<sys/type.h>")])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 성공 시 0, 실패 시 -1 반환")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("listen")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" backlog"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("ol",[s("li",[s("code",[t._v("sock")]),t._v(": 연결 요청 대기상태에 두고자 하는 소켓 파일 디스크립터를 전달한다.")]),t._v(" "),s("li",[s("code",[t._v("backlog")]),t._v(": 연결요청 대기 큐 크기정보를 전달한다. 클라이언트의 연결 요청 갯수를 제한할 수 있다.")])]),t._v(" "),s("p",[t._v("리스닝 소켓은 생성 뒤에 클라이언트로부터 날라오는 요청들을 연결 요청 대기 큐에 push하는 작업을 할 뿐이다. 연결 요청 대기큐에서 데이터를 pop하여 클라이언트 소켓과 통신 연결을 형성하는 작업은 "),s("code",[t._v("accept")]),t._v("함수 호출을 통해 이루어진다.")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<sys/socket.h>")])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 소켓 시 생성된 소켓 파일 디스크립터, 실패 시 -1 반환")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("accept")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sockaddr")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" addr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("socklen_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" addrlen"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("ol",[s("li",[s("code",[t._v("sock")]),t._v(": 서버 소켓 (리스닝 소켓)의 파일 디스크립터 전달. 파일 디스크립터가 전달되는 이유는 연결 요청 대기 큐와 서버 소켓이 1대1 대응 관계이기 때문이다. 서버 소켓이 2개 생성된다는 의미는 연결 요청 대기큐가 2개 생성된다는 의미이다.")]),t._v(" "),s("li",[s("code",[t._v("addr")]),t._v(": 연결 요청을 한 클라이언트 소켓 주소정보를 담을 주소 값. 함수호출 완료 이후 addr 변수에 클라이언트 주소 정보가 채워진다.")]),t._v(" "),s("li",[s("code",[t._v("addrlen")]),t._v(": "),s("code",[t._v("addr")]),t._v(" 변수의 크기를 바이트 단위로 전달한다. 변수의 참조를 전달해야 하며, 함수 호출 완료 이후에는 연결 요청된 클라이언트의 주소 정보 길이가 바이트 단위로 계산되어 할당된다.")])]),t._v(" "),s("h2",{attrs:{id:"tcp-클라이언트-함수-호출-순서"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-클라이언트-함수-호출-순서"}},[t._v("#")]),t._v(" TCP 클라이언트 함수 호출 순서")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("socket()")]),t._v(": 소켓 생성")]),t._v(" "),s("li",[s("code",[t._v("connect()")]),t._v(": 연결 요청. 함수 호출 후 "),s("strong",[t._v("클라이언트 소켓은 BLOCK 상태가 된다.")]),t._v(" 해당 상태에서 빠져나오기 위해서는 서버로부터 "),s("code",[t._v("accept")]),t._v("가 호출되었음을 확인 한 뒤에 이루어진다.")]),t._v(" "),s("li",[s("code",[t._v("read() / write()")]),t._v(": 데이터 송수신")]),t._v(" "),s("li",[s("code",[t._v("close()")]),t._v(": 연결 종료")])]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<sys/socket.h>")])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("connect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sockaddr")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" servaddr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("socklen_t")]),t._v(" addrlen"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[s("code",[t._v("connect")]),t._v("함수 각 인자가 하는 역할은 리스닝 소켓의 "),s("code",[t._v("accept")]),t._v("함수 인자의 역할과 동일하다.")]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("accept 함수 호출로 생성된 소켓의 포트 번호는?")]),t._v(" "),s("p",[t._v("accept로 생성된 소켓의 포트번호는 "),s("strong",[t._v("리스닝 소켓 시 할당한 포트 번호와 동일하다.")]),t._v(" 편의상 accept 소켓이라고 명명했을 때, 서로 다른 클라이언트 소켓으로부터 서버의 accept 소켓으로 연결이 이루어질 때 어떤 데이터를 전송해야 할지 선택해야 하는 상황을 가정해보자.")]),t._v(" "),s("p",[s("img",{attrs:{src:a(315),alt:"4-1"}})]),t._v(" "),s("p",[t._v("accept 소켓의 경우 클라이언트와 연결이 맺어질 때 클라이언트의 소켓 주소를 보유하게 된다. 그렇기 때문에 "),s("code",[t._v("accept")]),t._v("함수에서 "),s("code",[t._v("addr")]),t._v("변수가 존재하게 되는 것이다.")])]),t._v(" "),s("p",[s("img",{attrs:{src:a(316),alt:"4-2"}})]),t._v(" "),s("p",[t._v("위 그림에서 "),s("code",[t._v("listen")]),t._v("함수 호출 이후에 클라이언트로부터 "),s("code",[t._v("connect")]),t._v("요청이 언제 들어올 줄 알고 "),s("code",[t._v("accept")]),t._v("를 호출하는 걸까? 서버는 "),s("code",[t._v("accept")]),t._v("함수 호출 이후에 BLOCK 상태가 되어 대기하게 되고, 클라이언트로부터 "),s("code",[t._v("connect")]),t._v(" 호출이 이루어지는 경우 "),s("code",[t._v("accept")]),t._v("를 빠져나와 데이터 송수신이 본격적으로 이루어지게 된다.")])])}),[],!1,null,null,null);s.default=c.exports}}]);