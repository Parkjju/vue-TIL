(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{375:function(t,s,e){t.exports=e.p+"assets/img/axis.2135c792.png"},871:function(t,s,e){"use strict";e.r(s);var a=e(6),n=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"css-grid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-grid"}},[t._v("#")]),t._v(" CSS Grid")]),t._v(" "),s("p",[t._v("CSS를 다루면서 "),s("code",[t._v("display:flex")]),t._v(" 속성은 익숙하게 사용하였지만 그리드가 꼭 편할때가 있어서 결국 정리하게 되었습니다.")]),t._v(" "),s("p",[t._v("최근 프레이머 모션에 대해 공부하는 와중에 프레이머 홈페이지의 데모 애니메이션 중 Variants의 예시를 보여주는 부분이 있었습니다.")]),t._v(" "),s("p",[t._v("해당 애니메이션 구현에 앞서 박스 안에 원이 네개 배열되어 있었는데, 이를 "),s("code",[t._v("display:flex")]),t._v("로 배열하려고 하니 내부에 박스 두개를 더 겹치고 박스에 패딩을 부여한 뒤 "),s("code",[t._v("justify-content:space-between")]),t._v(", "),s("code",[t._v("align-items:center")]),t._v("를 주는 둥 엄청나게 코드가 복잡해질 수 밖에 없었습니다.")]),t._v(" "),s("p",[t._v("반면 그리드 시스템을 활용하게 될 경우 박스 내부를 원하는 크기로 잘라 각각 박스에 요소들을 알아서 배열해준다는 장점이 있었습니다. 코드의 중복이 다이나믹하게 줄어들 수 있었습니다.")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Box "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("styled")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("motion"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\n    width: 200px;\n    height: 200px;\n    background-color: #d14cf9;\n    border-radius: 40px;\n    box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1), 0 10px 20px rgba(0, 0, 0, 0.06);\n    display: grid;\n\n    grid-template-columns: repeat(2, 1fr);\n    grid-template-rows: repeat(2, 1fr);\n    align-items: center;\n    justify-items: center;\n")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("위 코드는 리액트 "),s("code",[t._v("styled-components")]),t._v("의 일부를 가져온 것입니다. 아래 네 개의 속성을 통해 그리드 기반 요소 배열을 진행할 수 있었습니다.")]),t._v(" "),s("ol",[s("li",[t._v("grid-template-columns : 박스에 세로 기준 그리드를 생성합니다.\n"),s("ul",[s("li",[t._v("각각 원하는 값을 그리드 크기로 지정할 수 있지만, "),s("code",[t._v("repeat(반복할 그리드 수, 단위)")]),t._v("로 지정하면 자동으로 동일 크기로 그리드를 잡아줍니다.")])])]),t._v(" "),s("li",[t._v("grid-template-rows : 가로 기준으로 그리드를 잡아줍니다.")]),t._v(" "),s("li",[t._v("align-items : 그리드 내부 요소들을 cross-axis 기준으로 정렬합니다. "),s("code",[t._v("display:flex")]),t._v("일 때와 동일하게 동작합니다.")]),t._v(" "),s("li",[t._v("justify-items (justify-content와 혼동 X) : 그리드 내부 요소들을 main-axis 기준으로 정렬합니다.")])]),t._v(" "),s("p",[t._v("여러분도 아래의 결과물을 직접 정렬해보세요!")]),t._v(" "),s("p",[s("img",{attrs:{src:e(375),alt:"framer"}})]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("place-self")]),t._v(" "),s("p",[t._v("그리드 시스템을 적용한 부모 요소에 align-items와 justify-items를 해도 되지만, 자식 요소에 "),s("code",[t._v("place-self:center")]),t._v("를 줘도 동일한 결과를 보이게 됩니다.")])])])}),[],!1,null,null,null);s.default=n.exports}}]);