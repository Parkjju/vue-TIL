---
title: Swift - MVVM
---

## 의존과 주입

A가 B에 의존적이라는 것은 B가 A의 변경에 맞춰 함께 변경되어야 하는 경우를 의미한다.

```swift
class A{
    var name: String = "박경준"
}

class B{
    var a = A()

    func printName(){
        print(a.name)
    }
}
```

위의 경우 A클래스의 `name`속성의 이름이 바뀐다거나 타입이 변경되는 경우 그에 따른 B 클래스에서의 정의를 수정해줘야 하는 번거로움이 생긴다.

:::tip 주입 (injection)

주입은 외부에서 생성자와 같은 방식을 통해 값을 인스턴스 내에 할당하는 것을 의미한다.

:::

C가 A에 의존하다가 B에 의존하게 되는 코드를 봐보자.

```swift
class A{
    var name: String = "JUN"
}

class B{
    var name: String = "PARK"
}

class C{
    var a = A()

    init(a: A){
        self.a = a
    }

    func printName(){
        print(a.name)
    }
}

let aInstance = A()
aInstance.name = "A name"

let c = C(a: aInstance)
```

위의 C인스턴스에 a 인스턴스를 주입한다. **현재 예시가 의존성 주입은 아니다.**

## 의존성 주입

의존성 주입은 프로토콜을 기반으로 구현된다.

```swift
protocol ModuledProtocol{
    var name: String { get set }
}

class A: ModuledProtocol{
    // ModuledProtocol 채택에 따라 name속성을 구현해야 하는 책임이 생긴다.
    var name: String = "A"
}

class B: ModuledProtocol{
    // ModuledProtocol 채택에 따라 name속성을 구현해야 하는 책임이 생긴다.
    var name: String = "B"
}

// ModuledProtocol 프로토콜은 일급객체이므로 타입으로 사용 가능하다.
class C{
    var moduledProperty: ModuledProtocol

    init(moduledProperty: ModuledProtocol){
        self.moduledProperty = moduledProperty
    }

    func printName(){
        // ModuledProtocol 저장속성 구현체에는 name속성이 반드시 들어가있음
        print(moduledProperty.name)
    }
}

let moduledA = A()
let moduledB = B()

let cFromA = C(moduledProperty: moduledA)
let cFromB = C(moduledProperty: moduledB)

cFromA.printName() // 모듈 A 인스턴스의 name 출력
cFromB.printName() // 모듈 B 인스턴스의 name 출력
```

C클래스가 A와 B클래스에 의존하고 있는 형태가 아닌 A와 B를 추상화한 프로토콜을 의존하게 된다. 이를 **의존관계 역전이라고 한다.**

:::tip 의존성 주입 정의

의존성 주입이란

1. 프로그램결합도를 느슨하게 되도록 하고
2. 의존관계 역전 원칙을 따르게 하고
3. 단일 책임 원칙을 따르게 한다.

이에 따라 클라이언트 생성에 대한 의존성을 클라이언트의 행위로부터 분리하는 것을 의미한다.

:::

:::tip 의존성 주입의 장점

1. 객체간 의존성을 줄여 코드의 확장성, 재활용성 개선
2. 객체간 결합도가 낮아져 유연한 코드 작성
3. 위 두가지 장점으로 인해 유지보수가 쉬워진다
4. 유닛테스트가 가능해진다.

:::
