---
title: Swift - 화면 이동과 데이터 전달
---

## 화면 이동(코드로만 연결하기)

xcode에서 화면 이동을 구현하기 위해서는 스위프트 파일을 먼저 생성해야 한다.

파일 생성시 `cocoa touch class` 타입의 파일로 생성하게 되면 상속받을 클래스를 선택하여 기본적인 코드 세팅을 도와준다. `override func viewDidLoad()`와 같은 코드들을 자동으로 생성해주는 것이다. 상속받는 클래스는 `UIViewController`로 지정하면 된다.

화면 이동의 흐름은 아래와 같다.

1. 새로운 `ViewController` 자식클래스를 생성한다.
2. 해당 클래스의 UI를 셋업한다. 이때, `addSubView`순서에 유의하여 클래스 자체에 오류가 없도록 해야한다. (중요)
3. 화면을 전환하고자 하는 원래 코드로 돌아와 새로 생성한 `ViewController` 자식클래스의 인스턴스를 생성한다.
4. 인스턴스의 `modalPresentationStyle` 열거형 속성을 지정하면 화면 전환 효과를 바꿔줄 수도 있다. (모달 또는 풀스크린 등)
5. `present` 메서드를 통해 화면을 전환한다.

```swift
// 이동할 페이지
class CustomViewController: UIViewController {
    // UI 셋업 코드
    override func viewDidLoad(){
        // ....
    }
}
```

```swift
// 처음 화면 위치에서 연결한 버튼을 탭하면 화면이 이동하도록 설계
@IBAction func codeNextButtonTapped(_ sender: UIButton) {
    // 인스턴스 생성
    let customVC = CustomViewController()
    customVC.modalPresentationStyle = .fullScreen
    present(customVC, animated: true)
}
```

## 데이터 전달

데이터를 주고받기 위해서는 전달받는 쪽의 클래스에 저장속성을 하나 마련해야 한다. ViewController 클래스에서는 생성자를 다루는 것이 쉽지 않기 때문에 옵셔널 타입으로 선언하는 것이 일반적이다.

위와 같이 저장속성을 옵셔널 타입으로 선언해도 `UILabel` 인스턴스의 `text`속성도 `String`의 옵셔널 타입이므로 옵셔널 바인딩을 할 필요 없이 바로 대입 가능하다.

```swift
class FirstViewController: UIViewController {
    var someString: String?

    let myLabel: UILabel = {
        let label = UILabel()

        // 전달될 someString의 값이 label로 세팅된다
        label.text = someString

        return label
    }()

    override func viewDidLoad(){

    }
}
```

데이터 공간을 마련했다면 인스턴스에 대한 저장속성에 접근하여 데이터를 전달하면 된다.

```swift
@IBAction func codeNextButtonTapped(_ sender: UIButton) {
    // 인스턴스 생성
    let firstVC = FirstViewController()
    firstVC.someString = "데이터 전달~~"
    firstVC.modalPresentationStyle = .fullScreen
    present(firstVC, animated: true)
}
```

:::tip 뒤로가기

스위프트에서 뒤로가기는 `dismiss(animated:)` 메서드를 사용하면 된다.

```swift
// 버튼에 대해 addTarget 메서드를 호출, backButtonTapped라는 이름으로 셀렉터 메서드 연결
@objc func backButtonTapped(){
    dismiss(animated: true)
}
```

:::

## 화면 이동(스토리보드)

`Main`스토리보드로 이동한 뒤 라이브러리에서 `ViewController`요소를 끌어다가 배치한다. 이후 좌측 파일 리스트에 코드로 설정했던 부분과 동일하게 `Cocoa touch class`타입으로 파일을 하나 생성한다.

Main 스토리보드에 올려놓은 ViewController요소를 선택한 뒤 우측 메뉴에서 (Inspector 메뉴) 왼쪽으로부터 4번째 메뉴를 클릭한다. (Identity Inspector)

해당 메뉴의 `Custom Class` 섹션의 Class에 위에서 연결하고자 하는 ViewController 클래스 파일명을 입력한 뒤 엔터를 치면 연결된다.

이뿐 아니라 present 함수 호출을 위해 ViewController 인스턴스 생성을 하는 코드가 있었는데, 코드로만 작성하던 방식과는 다른 방법을 사용해야 한다. 기존 코드로만 작성했을 때는 UI 오토 레이아웃에 대한 인스턴스와 스토리보드 자체에 대한 인스턴스가 함께 올라가서 동작했다면 스토리보드를 사용하는 방식은 둘이 분리되어 메모리상에서 관리가 되기 때문이다.

따라서 필요한 부분은 storyboard라는 변수에 접근하여 새로 생성한 뷰 컨트롤러를 연결한 인스턴스를 생성하는 부분이다.

```swift
@IBAction func storyboardWithCodeButtonTapped(_ sender: UIButton) {
    let secondVC = storyboard?.instantiateViewController(withIdentifier: "myVC") as!  MyViewController

    present(secondVC, animated: true)

}
```

`storyboard?.instantiateViewController` 메서드를 사용하며, 파라미터로 `withIdentifier`를 전달한다. 이때 identifier는 스토리보드와 ViewController 클래스를 연결할때 사용했던 Identity Inspector 메뉴를 사용한다.

연결하고자 하는 스토리보드를 누르고 `Identity` 섹션의 `Storyboard ID`를 원하는 문자열로 정의한다. 이후 `storyboard.instantiateViewController` 메서드를 호출할때 해당 아이디값을 전달하면 되며, 이렇게 생성한 인스턴스는 뷰컨트롤러 클래스로 타입 캐스팅을 해야한다.

## Reference

1. [앨런 Swift 문법 마스터스쿨](https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8-%EC%95%B1%EB%A7%8C%EB%93%A4%EA%B8%B0/dashboard)
