---
title: Swift - 비동기처리
---

## 기본 개념

GCD(Grand Central Dispatch == 디스패치큐)는 간단한 일, 메서드 위주의 함수를 사용하는 작업에 사용된다. 오퍼레이션큐는 상대적으로 복잡한 기능 구현에 사용된다. 오퍼레이션은 GCD에서 기반하여 만들어진 기능이다. (취소, 순서지정, 일시중지 등)

비동기는 디스패치 큐를 통해 다른 스레드로 보낸 뒤 다시 메인 스레드로 돌아와 다른 작업들을 시작한다. 동기는 다른 스레드로 보낸 뒤 해당 작업이 끝날때까지 기다린다. 논리적으로는 동기처리가 메인스레드에서 동작하는 것과 동일하다.

```swift
DispatchQueue.global().async{
    // task
}
```

:::tip 직렬(serial) vs 동시(concurrent)
직렬과 동시는 큐의 특성에 관한 개념이다. 직렬 큐는 분산처리 시킨 작업을 **다른 한개의 쓰레드에서** 처리하는 큐이다. 동시큐는 분산처리 시킨 작업을 **다른 여러개의 쓰레드에서** 처리하는 큐이다.

직렬 큐는 **순서가 중요한 작업을 처리할때 사용한다.** 동시 큐는 **독립적이지만 유사한 여러 작업을 처리할때** 사용한다.(테이블 뷰 셀 내의 컨텐츠 fetch 등)
:::

## GCD

디스패치큐는 메인큐, 글로벌큐, 프라이빗(커스텀)큐 세가지로 이루어진다. 메인 큐는 메인 스레드를 관장하는 큐이다.

글로벌큐는 기본적으로 분산처리시 동시처리를 기본으로 한다. 글로벌 큐는 파라미터로 `qos`라는 서비스 품질 값을 전달할 수 있다. `userInteractive`의 디스패치큐가 가장 중요도가 높다.

1. `DispatchQueue.global(qos: .userInteractive)` - 거의 즉시
2. `DispatchQueue.global(qos: .userInitiated)` - 몇초 (앱내 pdf 오픈)
3. `DispatchQueue.global()`
4. `DispatchQueue.global(qos: .utility)` - 몇초에서 몇분 (네트워킹)
5. `DispatchQueue.global(qos: .background)` - 몇분 이상 (에너지효율성 중시 / 유저의 직접적 인지가 없는 활동)
6. `DispatchQueue.global(qos: .unspecified)` - 레거시 API

중요도가 높은 큐에 태스크를 배치하면 내부적으로 더 여러개의 쓰레드를 배치하여 리소스를 집중시킨다.

```swift
// 백그라운드 큐는 작업의 영향을 받게 된다.
// 큐를 background로 생성했더라도 작업이 utility이므로 유틸리티 큐로 작업이 진행된다.
let queue = DispatchQueue.global(qos: .background)

queue.async(qos: utility){
    // task
}
```

커스텀 큐는 아래와 같이 사용한다. `label` 파라미터를 통해 큐에 이름을 붙인다. 직렬 및 동시처리를 선택할 수도 있다.

```swift
let queue1 = DispatchQueue(label: "com.parkjju.serial")
let queue2 = DispatchQueue(label: "com.parkjju.concurrent", attributes: .concurrent)
```

:::warning 비동기처리시 주의사항

1. 메인큐에서 다른큐로 보낼때 sync메서드를 호출하면 **절대 안된다.** (UI 버벅임)
2. **현재의 큐에서 현재 큐로** 동기적으로 보내서는 안된다. (Deadlock 발생)
    - 쓰레드의 작업을 큐로 보낼때 동기적으로 보냈기 때문에 해당 쓰레드는 lock이 걸린다.
    - 큐에 올라온 작업을 다른 쓰레드로 GCD에 의해 다시 보내질때 기존 쓰레드로 보내게될 경우 해당 쓰레드는 lock이 걸려있으므로 교착상태가 발생한다.
    - GCD가 다른 쓰레드로 작업을 보내는건 내부 알고리즘에 의한 것이므로 반드시 교착상태가 발생한다고 확신할 수는 없지만 일말의 가능성이 있는 코드 자체를 작성하지 않는 것이 중요하다.

:::

:::tip weak self 중첩
클로저 내에서 바깥족 함수에 weak self를 이미 선언했다면 내부 클로저에서는 추가로 weak self 선언을 하지 않아도 된다.

```swift
DispatchQueue.global(qos: .utility).async{[weak self] in
    // ...

    DispatchQueue.main.async{ // weak self 선언되어 있는 것과 마찬가지
        // ...
    }
}
```

:::
