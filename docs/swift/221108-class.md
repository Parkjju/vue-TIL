---
title: Swift - 클래스와 구조체
---

## 클래스

클래스는 타입이다.

```swift
class Dog{
    var name = "강아지"
    var weight = 0.0

    func sit(){
        print("\(self.name) 앉기")
    }
}

var bori = Dog() // Dog 클래스의 실제 데이터

bori.name = "보리"
bori.weight = 15.0
bori.sit()
```

클래스 내에 만들어진 각 변수와 함수들을 통칭 멤버라고 한다.

이때 클래스 내의 변수를 속성(property), 메서드(method)라고 한다.

`struct`라는 키워드로 생성하는 구조체라는 개념도 있는데 이는 클래스와 동일한 기능을 한다고 보면 된다.

클래스와 구조체 모두 메모리에 찍어낸 것을 인스턴스라고 한다. **클래스 인스턴스만 스위프트에서 특별히 객체라고** 함.

구조체도, 열거형도 모두 인스턴스를 갖는다.

구조체와 클래스의 **가장 큰 차이점은 메모리 저장 방식에서 나타남**

1. 구조체
    1. 값 형식
    2. 인스턴스 데이터를 모두 스택에 저장
2. 클래스
    1. 참조 형식
    2. 인스턴스 데이터는 힙에 저장, 힙을 가리키는 변수는 스택에 저장
    3. 메모리 주소값이 힙을 가리킨다.

### 1. 클래스 저장 방식

데이터 영역에 클래스가 저장되고 여기로부터 생성된 인스턴스가 힙에 저장됨. 각 인스턴스는 데이터 영역의 자신을 생성한 클래스 메모리 주소를 갖고 있고 참조함.

힙에 저장된 인스턴스는 특정 변수에 저장되어 활용되는데, 이 변수는 **스택 영역에 저장된다.**

:::tip 클래스의 값 복사

```swift
class Person{
    var name = "사람"
}

var person1 = Person()

person1.name = "박경준" // 인스턴스 프로퍼티 변경
print(person1.name) // 박경준

var person2 = person1
print(person2.name) // 박경준
// person2와 person1은 동일한 인스턴스를 가리키고 있다.

person2.name = "김경준"
print(person1) // 김경준
// person2가 가리키는 인스턴스 프로퍼티값이 바뀌었음에도
// person1이 가리키는 인스턴스 프로퍼티값이 바뀐다
// 따라서, person1과 person2는 동일한 인스턴스를 가리킨다
```

위 코드를 보면 Person이라는 클래스가 데이터 영역에 저장되어 있고 `Person()` 생성자를 통해 만들어진 인스턴스는 힙 영역에 저장된다.

이 힙 영역에 저장된 데이터는 다시 `person1`라는 변수에 저장되게 되는데 데이터 자체가 저장되는 것이 아닌 힙 영역에 저장된 인스턴스의 주소를 저장하게 된다.

`person2`라는 변수를 하나 생성하여 `person1`에 저장된 값을 할당하면 어떻게 될까?

person1에는 힙 영역에 저장된 인스턴스 데이터의 메모리 주소가 저장되어 있기 때문에 person2도 동일한 메모리 주소를 가리키게 된다.

:::

### 2. 구조체 저장 방식

데이터 영역에 구조체가 만들어지고 이 구조체 생성자를 통해 만들어진 데이터는 변수에 저장된 후 스택에 쌓인다.

함수 내에서 구조체를 통해 생성된 데이터는 함수 종료와 함께 사라진다.

:::tip 구조체의 값 복사

```swift
struct Animal{
    var name = "동물"
}

var animal1 = Animal();
var animal2 = animal1;

animal1.name = "고양이"
print(animal2.name) // 동물
```

:::

:::warning let선언

구조체의 let 선언은 스택에 쌓인 인스턴스 내부 속성 모두가 let선언이 된다는 것이고, 클래스의 let선언은 힙 메모리 주소의 변경이 불가능하다는 것을 의미한다.

:::

## 생성자 (initializer)

`init`키워드로 함수를 셍성한다.

```swift
class Dog{
    var name: String
    var weight: Double

    init(n: String, w: Double){
        name = n
        weight = w
    }
}

var bori = Dog(n: "보리", w: 15.0)
```

```swift
class Dog{
    var name: String
    var weight: Double

    init(name: String, weight: Double){
        self.name = name
        self.weight = weight
    }
}

var bori = Dog(name: "보리", weight: 15.0)
```

위의 코드에서 생성자 함수를 보면 파라미터 name, weight의 이름과 할당대상 변수의 이름이 동일한 것을 볼 수 있다.

이때 `self`키워드로 접근하면 **클래스 인스턴스의** 프로퍼티에 접근한다는 것을 나타낸다.

:::warning 초기화 주의점
클래스, 구조체 생성자 함수에서는 모든 프로퍼티에 대해 초기화를 진행해야 한다.

생성자함수 실행 종료시점에는 모든 프로퍼티 초기값이 저장되어 있어야한다.

```swift
var dog = Dog.init(name: "강아지", weight:15.0)
// 위와 아래는 같은 코드이다
var dog = Dog(name: "강아지", weight: 15.0)
```

인스턴스의 초기화가 완료되면 메모리에 정상적으로 인스턴스가 생성되었다는 의미이다.

:::

## 옵셔널 타입 속성

클래스 또는 구조체의 속성을 옵셔널 타입으로 선언하게 되는 경우를 생각해보자.

```swift
class Dog{
    var name: String?
    var weight: Int

    init(weight: Int){
        self.weight = weight
    }

    func sit(){
        print("\(name)이 앉았습니다.")
    }

    func layDown(){
        print("\(name)이 누웠습니다.")
    }
}

var myDog = Dog(weight: 15)
```

타입이 옵셔널이고 생성자 함수에서 모든 속성들을 초기화하지 않았더라도 옵셔널 선언된 변수는 `nil`값으로 초기화 되기 때문에 **생성자 함수는 모든 속성을 초기화해야한다는 법칙에 저촉되지 않는다.**

클래스 및 구조체 속성이 옵셔널 타입으로 생성되었다면 생성자 함수 파라미터를 통해 초기화 하거나 리터럴값으로 직접 초기화하더라도 인스턴스 생성 후 출력해보면 **옵셔널 타입으로 출력된다.** 따라서 옵셔널 타입을 한번 벗긴 후 값을 사용해야한다.

:::tip 식별 연산자

`===` 연산자는 **클래스의 인스턴스가 같은 곳을 가리키고 있는지 판별하는 연산자**

:::

클래스는 기본적으로 메모리 주소에 참조 형태로 데이터를 저장하기 때문에 동작이 무거움. 꼭 써야만 하는 경우(상속 구조, 시리얼라이징, 파일로 전송 등의 작업)가 아닌 경우에는 구조체를 쓰는 것이 좋다.

## 객체지향의 4대 특징

1. 추상화 - 실생활에서 관심있고 공통적 특싱을 뽑아내어 하나의 분류로 만든 것 (모델링)
2. 캡슐화 - 속성과 메서드를 하나의 클래스로 묶어 활용한다는 개념(속성과 메서드 이들이 모두 하나의 목적을 가진 실체)
    1. 은닉화 - 캡슐화 이후 접근제어자를 (public, private 키워드 등)통해 객체 내외부 데이터 접근 통제가 가능
3. 상속성 - 부모클래스 속성과 메서드를 자식클래스에서 물려받음(클래스 재활용)
4. 다형성 - 한 객체가 여러 타입의 형태로 저장 가능. (나중에 이해)

## Reference

1. [인프런 - 앨런 swift 문법 마스터 스쿨](https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8/dashboard)
