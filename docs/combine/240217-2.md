---
title: Combine - Publisher
tags: ['Swift', 'Combine']
---

## Publisher - Overview

퍼블리셔는 시간에 따라 방출하는 일련의 값들을 선언한다. 이렇게 방출된 값들은 하나 이상의 구독자에게 전달할 수 있다.

구독자의 `Input`과 `Failure`타입은 퍼블리셔에 선언된 `Output`, `Failure`타입과 일치해야 한다. 퍼블리셔는 구독자의 구독을 받아들이기 위해 `receive(subscriber:)` 메서드를 내부적으로 구현한다. `Publisher` 중첩 구조체를 살펴보면 내부에 `receive` 함수 타입이 정의된 것을 볼 수 있다.

퍼블리셔는 아래의 메서드들을 구독자에게 호출할 수 있다.

1. `receive(subscription:)`: 구독 요청을 승인하고 `Subscription` 인스턴스를 반환한다. 구독자는 `Subscription` 인스턴스를 통해 퍼블리셔에게 값을 요구하고 값의 방출을 취소할 수 있다.
2. `receive(_:)`: 퍼블리셔로부터 하나의 값을 구독자에게 전달한다.
3. `receive(completion:)`: 구독자에게 값의 방출이 끝났음을 알린다.

모든 퍼블리셔는 `Publisher`프로토콜 채택에 따라 `receive` 메서드를 반드시 구현해야 한다.

`Publishers` 열거형 내부 구현을 살펴보면 수 많은 퍼블리셔들이 정의되어 있는 것을 볼 수 있다. 이는 퍼블리셔 체이닝을 위해 오퍼레이터로 사용될 목적으로 만들어진 것이다. 예를 들어 `map` 오퍼레이터의 경우 `Publishers.Map`클래스의 인스턴스를 리턴하도록 구현되어 있다.

:::tip Publisher vs AsyncSequence

퍼블리셔와 스위프트 표준 라이브러리의 `AsyncSequence`는 시간에 따라 값을 방출한다는 점에서 동일하지만 퍼블리셔는 구독자를 통해 퍼블리셔로부터 값을 요청하는 반면 `AsyncSequence`는 `for-await-in`을 통해 방출되는 값들을 순회한다.

둘다 모두 필터링 및 매핑 관련 연산자를 제공한다.

```swift
let endpointURL = URL(string: "https://zeddios.tistory.com")!
let lineCount = endpointURL.lines.map { $0.count } ✅ // AsyncSequence 인스턴스의 map 연산자
do {
    for try await line in lineCount {
        print(line)
    }
} catch {

}
// 출처: https://zeddios.tistory.com/1339 [ZeddiOS:티스토리]
```

컴바인에서는 `AsyncSequence`에서 제공하지 않는 시간 기반의 오퍼레이터 `debounce`, `throttle`을 추가로 제공하며 퍼블리셔 간 결합 오퍼레이터인 `merge(with:)`, `combineLatest(_: _:)` 연산자들도 제공한다.

`AsyncSequence`와 컴바인의 퍼블리셔를 브릿징하기 위해서는 퍼블리셔에서 방출하는 값들을 `AsyncSequence`로 노출시켜 구독자를 통한 값의 처리방법 대신 `for-await-in`으로 순회할 수 있다.

:::

퍼블리셔 프로토콜을 채택하여 직접 정의하는 대신 컴바인에서 제공하는 몇가지 타입을 활용하면 커스텀 퍼블리셔를 쉽게 정의할 수 있다. `PassThroughSubject`와 같은 `Subject` 하위클래스 타입을 사용하면 된다. (`PassThroughSubject`는 RxSwift에서 `PublishSubject`, `CurrentValueSubject`는 `BehaviorSubject`와 동일하다.)

`@Published` 프로퍼티 래퍼를 사용하면 속성의 값이 변할때마다 값을 방출하는 퍼블리셔를 쉽게 정의할 수도 있다.

## Publisher - Output, Failure

Output은 퍼블리셔로부터 방출되는 값의 타입을 의미한다. `Failure`는 퍼블리셔가 방출할 수 있는 에러의 타입을 의미한다. 퍼블리셔가 에러를 방출하지 않을 경우 `Never`를 사용한다.

## Operators

`RxSwift`에서 다뤄보지 않은 오퍼레이터를 추가로 정리한다.

### map, tryMap, mapError

RxSwift `map` 오퍼레이터와 동일하다. 업스트림 퍼블리셔로부터 받은 엘리먼트를 클로저에 따라 변형시킨 뒤 새로운 옵저버블로 반환한다. `tryMap`은 클로저에서 에러를 `throw`하는 경우 sink `completion`클로저에서 처리하기 위해 사용한다.

```swift
struct ParseError: Error {}
func romanNumeral(from:Int) throws -> String {
    let romanNumeralDict: [Int : String] =
        [1:"I", 2:"II", 3:"III", 4:"IV", 5:"V"]
    guard let numeral = romanNumeralDict[from] else {
        throw ParseError()
    }
    return numeral
}

let numbers = [5, 4, 3, 2, 1, 0]

// 0에서 에러 방출
let cancellable = numbers.publisher
    .tryMap { try romanNumeral(from: $0) }
    .sink(
        receiveCompletion: { print ("completion: \($0)") },
        receiveValue: { print ("\($0)", terminator: " ") }
     )

```

`mapError`오퍼레이터는 방출된 에러 타입을 map처럼 다른 형태로 변형하고 싶을때 사용한다.

```swift
struct MyGenericError: Error { var wrappedError: Error }

divisors.publisher
    .tryMap { try myDivide(1, $0) }
    .mapError { MyGenericError(wrappedError: $0) }
    // ....
```

### replaceNil(with:)

`replaceNil` 오퍼레이터는 업스트림 퍼블리셔에서 전달된 요소 중 nil값을 with 파라미터에 전달된 값으로 대체해준다.

```swift
let numbers: [Double?] = [1.0, 2.0, nil, 3.0]
numbers.publisher
    .replaceNil(with: 0.0)
    .sink { print("\(String(describing: $0))", terminator: " ") }
    .cancel()
```

### removeDuplicates

`Output`타입이 Equatable 프로토콜을 구현한 경우 방출되는 요소들의 중복을 제거하여 반환한다.

```swift
let numbers: [Int] = [1,1,2,2,3,4]
numbers.publisher
    .removeDuplicates()
    .sink(receiveValue: {print($0)})
```

by 클로저를 통해 직접 동일성 여부 로직을 구성할 수도 있다.

```swift
let points = [Point(x: 0, y: 0), Point(x: 0, y: 1),
              Point(x: 1, y: 1), Point(x: 2, y: 1)]
cancellable = points.publisher
    .removeDuplicates { prev, current in
        prev.x == current.x
    }
    .sink { print("\($0)", terminator: " ") }
```

### replaceEmpty

시퀀스에서 방출하는 요소가 `empty`상태일때 새로운 값으로 대체한다.

```swift
let numbers: [String] = []
numbers.publisher
    .replaceEmpty(with: "ABC")
    .sink(receiveValue: { print($0) })
```

### collect

방출되는 요소들을 종합하여 하나의 배열로 합친다. `count`파라미터는 담을 버퍼값을 지정하고 모두 담으면 방출한다. 모든 요소를 순회하며 버퍼에 계속해서 채운다.

```swift
let numbers = 1..<10
numbers.publisher
    .collect()
    // collect(3) -> 3개씩 모아서 다 모아지면 방출
    .sink(receiveValue: {print($0)})
```

### ignoreOutput

방출되는 값들은 무시하고 `completion`의 `failure`만 방출한다.

### reduce vs scan

`scan`은 누적 계산되는 모든 값을 매번 방출하고, `reduce`는 최종 연산된 마지막 결과만 방출한다.

```swift
let numbers = 1..<4
numbers.publisher
    .scan(0) { $0 + $1 }
    .sink(receiveValue: {print($0)}) // 1 3 6

numbers.publisher
    .reduce(0, { $0 + $1 })
    .sink(receiveValue: {print($0)}) // 6
```

### allSatisfy

업스트림으로부터 전달된 요소 전체가 `allSatisfy` 오퍼레이터에 정의된 클로저 조건식에 만족되는지 여부를 `Bool`값으로 리턴한다.

```swift
let targetRange = (-1...100)
let numbers = [-1, 0, 10, 5]
numbers.publisher
    .allSatisfy { targetRange.contains($0) }
    .sink { print("\($0)") } // true
```

### drop(untilOutputFrom:), drop(while:), tryDrop(while:), dropFirst(\_ count: Int)

1. `drop(untilOutputFrom:)`: 파라미터에 전달되는 퍼블리셔에서 요소가 방출되기 전까지 업스트림에서 방출되는 요소들을 무시한다.
2. `drop(while:)`: `while`클로저에 전달된 조건식이 true인 동안에 업스트림에서 방출되는 요소들을 무시한다.
3. `tryDrop(while:)`: 에러를 던질 수 있는 `drop(while:)`오퍼레이터
4. `dropFirst(_ count: Int)`: 0번째부터 count까지의 요소들을 버림

### append(\_ elements: Self.Output...), append<S>(\_ elements: S), append<P>(\_ publisher: P) & prepend

1. `append(_ elements: Self.Output...)`: Output타입과 동일한 데이터들을 가변 파라미터 형태로 전달하면 업스트림에서 방출되는 요소에 이어붙여진다.
2. `append<S>(_ elements: S)`: 파라미터에 시퀀스를 전달하면 업스트림에서 방출된 시퀀스에 이어붙여진다.
3. `append<P>(_ publisher: P)`: 업스트림에서 방출되는 요소에 이어 파라미터에 전달된 다운스트림 퍼블리셔에서 방출되는 요소를 이어붙인다.
4. `prepend(_ elements: Self.Output...)`: append와 동일하게 동작하지만, 삽입되는 위치만 맨 앞

### prefix(\_: Int), prefix(while: ), tryPrefix(while:), prefix<P>(untilOutputFrom publisher: P)

1. `prefix(Int)`: 파라미터에 전달된 갯수 값 만큼 요소를 방출한다.
2. `prefix(while: )`: 조건식이 true인 동안에만 방출하고 false가 된 이후에는 방출하지 않는다.
3. `tryPrefix`: 에러를 던질 수 있는 `prefix(while:)`
4. `prefix(untilOutputFrom)`: 다운스트림 퍼블리셔에서 요소를 방출하기 전까지 계속해서 업스트림의 요소 방출

```swift
let upstream = PassthroughSubject<Int,Never>()
let second = PassthroughSubject<String,Never>()

let cancellable = upstream
    .prefix(untilOutputFrom: second)
    .sink(receiveValue: { print($0) })

upstream.send(0)
upstream.send(1)
second.send("A")
upstream.send(2)
// 0 1
```

## Reference

1. [Zeddios - AsyncSequence](https://zeddios.tistory.com/1339)
2. [Apple Document - Publisher](https://developer.apple.com/documentation/combine/publisher)
3. [try code by Marin Todorov - subscribe(on:) vs receive(on:)](https://trycombine.com/posts/subscribe-on-receive-on/)
4. [Velog - subscribe(on:) VS. receive(on:)](https://velog.io/@ictechgy/Combine-subscribeon-VS.-receiveon)
