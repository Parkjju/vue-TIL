---
title: DailyTech - DOM에 대해

---
## DOM이란?

> 문서 객체 모델(DOM, Document Object Model)은 HTML, XML 문서의 프로그래밍 인터페이스이다. - MDN

API와 관련된 자료를 찾아볼 때마다 지겹도록 들은 인터페이스에 대한 개념이 또 등장한다. 인터페이스라 함은 서로 다른 두 대상이 소통할 때 필요한 규격이라고 정리할 수 있는데 이러한 측면을 DOM에 적용해보면 어떻게 될까?

> 텍스트 파일로 만들어져 있는 웹 문서를 브라우저에 렌더링하려면 **웹 문서를 브라우저가 이해할 수 있는 구조로 메모리에 올려야 한다.** **브라우저의 렌더링 엔진은 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를 DOM이라 한다.** 즉 모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고 이들 객체를 부자 관계를 표현할 수 있는 트리 구조로 구성한 것이 DOM이다.  - [Poimaweb(Js-dom)](https://poiemaweb.com/js-dom)

DOM의 필요성부터 생각해보자. 브라우저가 HTML 문서 안의 다양한 요소, 속성들을 해석하여 렌더링하게 될텐데 단순 HTML 코드 텍스트 나열이 아니라 사용자가 보기에 자연스러운 웹 페이지로 구성이 된다.

이러한 구성을 위한 작업을 (웹 문서의 로드, 파싱) 브라우저의 렌더링 엔진이 처리하고 이에 대한 결과물로써 DOM이 나오는 것이다. 브라우저는 DOM을 확인하고 문서에 대한 해석과 더불어 우리가 보고 있는 페이지를 나타낸다.

:::warning
DOM은 프로그래밍 언어가 아니다. HTML 소스와 같은 문서를 객체 지향적으로 표현한 추상적 모델일 뿐이다. 하지만 DOM이 없으면 웹 브라우저에 접근하는 스크립트 언어가 페이지 또는 XML 요소와 관련된 개념에 대해 정보를 갖지 못하게 된다.

위에서 말했듯, DOM은 브라우저와 스크립트 언어 사이를 이어주는 API와 같은 역할을 한다고 보면 된다.
:::

초창기 웹의 발전에 이바지한 자바스크립트는 DOM과 함께 길을 가는 듯 했지만 나중에는 각각 분리되어 발전하게 된다. 우리가 보고 있는 웹 페이지는 **DOM과 스크립트 언어(Python, Javascript, ASP.NET 등)** 이 함께 어우러진 결과이다.

스크립트 언어에 대한 설명은 [다음의 링크를](https://m.blog.naver.com/rlarbtjq7913/221711007833) 참조하자.

DOM에 대한 문서를 본격적으로 작성하기 전에는 DOM이 자바스크립트 언어의 한 부분인 줄 알았지만, 이 둘은 완전 별개의 존재라는 것을 깨달았다. 파이썬 웹 크롤링 실습을 할 때 우리가 특정 페이지 요소에 접근할 수 있었던 이유에 대해 생각하게 되었는데,  바로 **DOM이라는 객체 모델에 파이썬이라는 스크립트 언어가 접근**하여 **요청에 따른 웹 페이지를 해석할 수 있었다**는 것으로부터 기인한다.

DOM을 파이썬이 해석하는 예제는 다음과 같다. [MDN(DOM 소개)](https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction#dom_and_javascript) 글을 참조하여 새롭게 예제 코드를 작성해보았다.

```python
# Python DOM example
import xml.dom.minidom as m
doc = m.parse("C:\\Users\\Parkjju\\Desktop\\sitemap.xml")
doc.nodeName # DOM property of document object;
p_list = doc.getElementsByTagName("url")
print(p_list)
```

실제 나의 뷰프레스 사이트맵 파일을 로컬에 저장하여 파이썬 파싱 모듈의 `parse` 메서드에 파라미터로 전달해보았다. 참고로 `parse` 메서드는 파라미터로 `file`만 받고 있다. (추후 `BeautifulSoup` 모듈을 활용하여 HTTP 프로토콜을 따르는 웹 사이트에 접근하는 예제도 추가 예정)

`getElementByTagName`이라는 메서드로 xml파일에 접근하고 있는데, 이게 실제로 정상적으로 이루어진다는 것으로부터 미루어 짐작하면 파이썬이라는 스크립트 언어도 **DOM이라는 객체 모델을 통해 xml사이트에 대한 해석을 정상적으로 처리하였다고 이해할 수 있겠다.**

DOM은 문서에 대한 객체 모델로 존재하여 API 역할을 하는 것 외에도 실제로 연결되어 있는 소스(HTML 등) 내의 요소에 접근 / 수정하는 기능도 제공한다. (각 요소가 갖는 프로퍼티와 메서드를 제공한다.)

## DOM 트리

문서에 대한 객체 트리 모델로써 존재하는 DOM이 바로 **DOM Tree이다.** HTML 문서가 DOM으로 구성된 후에는 웹 문서에 대한 동적 변경을 위해 각 요소에 대한 프로퍼티와 메서드를 자바스크립트 객체 형태로 제공한다. 이를 DOM API라고 한다.

> 달리 말하면 정적인 웹페이지에 접근하여 동적으로 웹페이지를 변경하기 위한 유일한 방법은 메모리 상에 존재하는 DOM을 변경하는 것이고, 이때 필요한 것이 DOM에 접근하고 변경하는 프로퍼티와 메소드의 집합인 DOM API이다. - [Poimeweb(DOM)](https://poiemaweb.com/js-dom)

(위의 두 문장을 요약하고 싶었지만 도저히 불가능했다. DOM과 DOM API에 대한 완벽한 설명이다👍)

DOM 트리는 네 종류의 노드로 구성된다.

1. **문서 노드(Document Node)**
2. **요소 노드(Element Node)**
3. **어트리뷰트 노드(Attribute Node)**
4. **텍스트 노드(Text Node)**

각 노드에 대한 개념은 다음과 같다.

1. 문서 노드 - 트리 최상위에 위치하며 나머지 노드에 접근하기 위해서는 문서 노드를 거쳐야한다. 즉, DOM 트리에 접근하기 위한 **시작점(Entry Point)이다.**
2. 요소 노드 - **HTML 요소를 표현한다.** HTML 요소는 중첩에 의해 부모-자식 관계를 맺게 된다. 이 관계들은 결과적으로 **HTML 문서의 구조를 서술한다고 말 할 수 있겠다.** 텍스트 노드에 접근하려면 먼저 요소 노드를 찾아 접근해야 한다. 요소 노드는 요소별 특성 표현을 위해 `HTMLElement` 객체를 상속한 객체로 구성된다.
3. 어트리뷰트 노드 - HTML 요소의 어트리뷰트를 표현한다. 요소 자식이 아닌 요소의 일부로 표현된다. 동일한 이름의 자바스크립트 객체 프로퍼티를 통해 접근할 수 있다.

   > Most HTML attributes can be accessed through the JavaScript object property of the same name. - ([Document Object Model](https://web.stanford.edu/class/cs98si/slides/the-document-object-model.html))
4. 텍스트 노드 - HTML 요소의 텍스트를 표현한다. 요소 노드의 자식이고 자신의 자식 노드를 가질 수 없다. **DOM 트리의 최종단이다.**

:::tip Attribute vs Property
어트리뷰트는 HTML 문서에서 작성되는 요소의 속성-값 쌍을 말하고, 프로퍼티는 HTML 문서가 DOM으로 파싱된 이후의 어트리뷰트를 말한다. 위의 정의에 따라 **어트리뷰트는 값이 정적**이고 **프로퍼티는 동적으로 변할 수 있다.**
:::

:::tip HTMLElement란?
[Javascript Reference](http://www.devdic.com/javascript/refer/dom:285/category:377/Inherited) 페이지를 참고해보자. DOM을 구성하는 노드 중 HTML 요소를 나타내는 **요소 노드는 각 요소 특성 표현을 위한 인터페이스를 마련해두고 있다.** 예를 들어, `HTMLAnchorElement`는 하이퍼링크 기능을 갖는 `<a></a>` 요소를 다루고 위 요소를 다루기 위한 속성과  메서드를 제공하는 인터페이스이다. 인터페이스에 대한 설명은 자바의 인터페이스 개념을 참고하자. 한 마디로 정리하면 프로토콜과 비슷하다고 볼 수 있겠다. 특정 기능을 구현하는 데에 있어서 필요한 기본 틀이라고 생각하자.
:::

DOM을 통해 웹페이지를 조작하기 위해서는 **요소를 찾고, 해당 요소의 텍스트 또는 어트리뷰트를 조작한다.** 자바스크립트는 이를 위한 API를 제공한다.

## DOM 쿼리

그렇다면 이제 자바스크립트에서 제공하는 API를 가지고 실제 HTML요소에 접근해보자.

* **`document.getElementById(id)`**
  * id 어트리뷰트를 통해 요소 노드 한 개를 선택한다.
  * DOM 노드 중 `HTMLElement`를 상속받는 객체를 리턴한다.
  * 모든 브라우저에서 동작

실제로 현재 열려있는 뷰프레스 문서 기준으로 `reference` id값을 갖는 요소를 선택해보자. 그 후에 이 요소의 프로토타입을 차례로 찍어보자.

프로토타입에 대한 설명은 [자바스크립트는 왜 프로토타입을 선택했을까?](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42) 문서를 참조하자.

```javascript
myElement = document.getElementById("reference");

console.log(myElement); // HTML 요소가 출력된다.
console.log(myElement.__proto__); // HTML 요소의 원형 - HTMLHeadingElement라는 인터페이스가 출력된다.
console.log(myElement.__proto__.__proto__); // 모든 HTML 요소의 원형인 HTMLElement가 출력된다.
console.log(myElement.__proto__.__proto__.__proto__); // 모든 요소 노드의 원형인 Element가 출력된다.
console.log(myElement.__proto__.proto__.proto__.__proto__); // 모든 노드의 원형인 Node가 출력된다.
```

* **document.querySelector(Selector)**
  * CSS 셀렉터를 통해 요소에 접근한다.
  * 셀렉터 값에 해당하는 요소 한 개만 가져온다. 중복될 경우 첫 번째 요소 하나만 가져온다.
  * IE8 이상의 브라우저에서 동작한다.

```javascript
myElement = document.querySelector('#reference');
console.log(myElement);
```

* **document.getElementsByClassName("className") & document.getElementsByTagName("TagName")**
  * 클래스명, 태그명에 따라 요소를 전부 선택하여 가져온다.
  * `HTMLCollection` 타입으로 가져온다. (주의)

```javascript
const myElements = document.getElementsByTagName("p");
console.log(myElements.__proto__) // HTMLCollection
```

HTMLCollection에 대한 설명은 `querySelectorAll` API까지 본 후에 후술하겠습니다.

* **document.querySelectorAll(Selector)**
  * CSS 셀렉터, 태그명 등에 해당하는 요소 전체를 가져온다.
  * `NodeList` 타입으로 반환한다.

```javascript
const myElements = document.querySelectorAll("p");
console.log(myElements.__proto__); // NodeList ...
```

:::tip HTMLCollection vs NodeList
`HTMLCollection` 타입은 살아있는 요소들의 집합이다. 이에 반해 `NodeList`는 죽어있다. 즉 **동적이냐 정적이냐의** 차이이다.

HTMLCollection은 **유사 배열(array-like object)이라고도 불린다.** 유사 배열이라 함은 배열과 유사한 역할(인덱를 통한 엘리먼트 접근)을 하지만 실제 배열에서 제공하는 모든 메서드를 가지고 있지 않다는 것이다.HTMLCollection은 배열의 `.forEach`, `.map`메서드 등을 제공하지 않는다.

HTMLCollection 객체 요소에 접근하기 위해서는 인덱스를 이용하거나, **속성명** 입력을 통해 접근할 수 있다. `name` 어트리뷰트가 지정되어 있는 요소의 경우 `namedItem` 메서드를 통해 접근할 수도 있고, 인덱스 접근 시 `item` 메서드를 통해 접근할 수도 있다.



:::

## Reference

1. [MDN - DOM 소개](https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction#dom_and_javascript)
2. [Javascript Info - DOM트리](https://ko.javascript.info/dom-nodes)
3. [PoiemaWeb - DOM](https://poiemaweb.com/js-dom)
4. [teo님 velog - DOM은 다들 어떤식으로 공부하시나요?](https://velog.io/@teo/dom)
5. [The Document Object Model](https://web.stanford.edu/class/cs98si/slides/the-document-object-model.html)