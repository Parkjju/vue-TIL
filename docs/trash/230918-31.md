---
title: Snack 31호 - RxSwift Input & Output
---

## 개요

MVVM 아키텍처 기반의 킥스타터 앱이 오픈소스로 열리게 되어 해당 앱의 소스코드를 살펴보며 뷰모델을 실제로 디자인해보려고 한다.

[RxSwift Sample App](https://github.com/khoren93/SwiftHub/tree/master#design)에 리스트업된 앱을 로컬에 설치한 뒤 빌드 후 직접 결과물을 테스트한다. 로컬에 세팅하는 과정은 리드미를 그대로 따라가면 된다.

```sh
cd SwiftHub
bundle install
bundle exec fastlane setup
```

## 뷰모델 디자인

아래 화면은 SwiftHub 앱의 이벤트 탭에 해당하는 뷰이다. 위 화면에서 사용자로부터 인풋으로 들어올 수 있는 대상을 표시하면 다음과 같다.

![31-1](../.vuepress/assets/snack/31-1.png)

1. 헤더 & 푸터 리프레시
2. 세그먼트 컨트롤 탭
3. 셀 셀렉션 이벤트

이들을 각각 인풋 프로토콜 내에 옵저버블 혹은 드라이버 타입으로 정의해둔 뒤 nested 구조체 타입으로 클래스 내에 정의한다. **이때 각 뷰모델 클래스들은 기본 뷰모델 인풋과 아웃풋 각각을 associatedType으로 갖는 저장속성을 구현 대상으로 하여 프로토콜을 하나 채택해야 한다.**

해당 프로토콜은 아래와 같다. 인풋으로 들어온 대상들을 아웃풋으로 내보내게 되는데, 뷰의 변경사항들은 반드시 아웃풋 중첩 구조체 타입에만 접근해야 한다.

```swift
protocol ViewModelType {
    associatedtype Input
    associatedtype Output

    func transform(input: Input) -> Output
}
```

```swift
// 원래 코드에는 모든 뷰모델에 베이스가 되는 ViewModel 프로토콜이 작성되어 있지만, 예시에서는 제외
class EventViewModel: ViewModelType {
    struct Input {
        let headerRefresh: Observable<Void>
        let footerRefresh: Observable<Void>
        let segmentSelection: Observable<EventSegments>
        let selection: Driver<EventCellViewModel>
    }
}
```

뷰에서 뷰모델을 참조하여 화면에 바인딩해야할 데이터는 크게 다음과 같이 나타난다.

![31-2](../.vuepress/assets/snack/31-2.png)

1. 깃헙 프로필 이미지 URL
2. 테이블뷰 셀에 바인딩할 배열 데이터
3. 그 외

실제 코드상에는 더 다양한 아웃풋 리스트들이 있다. 일단 기억할 것은 `imageUrl` 속성과 `items`정도가 된다.

`userSelected`와 `repositorySelected`의 경우 앱 기능에 특정적인 내용이므로 직접 실행해가며 이해하면 된다. userSelected는 셀 내의 프로필이미지 영역을 탭했을때 푸시되는 뷰이고, repositorySelected의 경우 그 외 영역을 탭했을때 나타나는 뷰이다. 푸시되는 뷰가 다르니 직접 확인하면 된다.

```swift
class EventViewModel: ViewModelType {
    struct Input {
        // ...
    }

    struct Output {
        let navigationTitle: Driver<String>
        let imageUrl: Driver<URL?>
        let items: BehaviorRelay<[EventCellViewModel]>
        let userSelected: Driver<UserViewModel>
        let repositorySelected: Driver<RepositoryViewModel>
        let hidesSegment: Driver<Bool>
    }
}
```

인풋과 아웃풋에 대한 정의가 끝났으면 인풋으로 들어온 이벤트를 적절히 데이터로 정제하여 뷰에 뿌려줘야 한다. 이 역할을 `transform` 함수가 한다.

위 예시 기준으로 리프레시 이벤트가 전달되었다고 가정하고 `transform` 함수 코드를 작성하면 다음과 같은 흐름으로 이루어진다.

1. `input` 파라미터를 구독한다.
2. API 요청 이후 반환된 데이터를 릴레이 객체에 accept로 전달한다.
3. 릴레이 객체는 **클래스 저장속성이 아닌 함수 내에서 변수로 선언한 뒤, 뷰 내에서만 사용하고 메모리에서 해제되도록 설계한다.**

```swift
func transform(input: Input) -> Output {
    let elements = BehaviorRelay<[데이터 모델]>(value: [])

    input.headerRefresh
        .flatMapLatest({ [weak self] () -> Observable<[EventCellViewModel]> in
            guard let self = self else { return Observable.just([]) }
            self.page = 1
            return APIRequest() // API 요청 후 [데이터모델] 반환
        })
        .subscribe(onNext: { (items) in
            elements.accept(items)
        }).disposed(by: rx.disposeBag)

    // ...
}
```

인풋을 통해 아웃풋에 담을 데이터 정의가 끝났다면, `Output` 중첩 타입 객체를 생성하여 리턴하며 함수를 종료한다.

```swift
func transform(input: Input) -> Output {
    let elements = BehaviorRelay<[데이터 모델]>(value: [])

    // Input을 통해 elements에 데이터 담기

    return Output(navigationTitle: .... , items: elements, ....)
}
```

이렇게 정의된 뷰모델을 뷰 컨트롤러에서 다루게 되는 흐름은 다음과 같다. 뷰모델 중첩타입 인풋에 접근하여 인스턴스를 생성, 뷰 컨트롤러 내의 뷰모델 바인딩 함수에서 `transform` 함수 호출에 대한 파라미터에 이를 전달한다.

아래 코드에서 `headerRefreshTrigger`, `segmentSelected` 등의 코드 역시 예제에 종속되는 코드이므로 직접 돌려가며 이해하면 된다.

```swift
func bindViewModel() {
    let refresh = Observable.of(Observable.just(()), headerRefreshTrigger, segmentSelected.mapToVoid().skip(1)).merge() // 리프레시 옵저버블 생성

    // 인풋객체 생성 후 변수에 할당
    let input = EventsViewModel.Input(headerRefresh: refresh,
                                        footerRefresh: footerRefreshTrigger,
                                        segmentSelection: segmentSelected,
                                        selection: tableView.rx.modelSelected(EventCellViewModel.self).asDriver())

    // 아웃풋객체 할당받은 후 본격적인 데이터바인딩 시작
    let output = viewModel.transform(input: input)

    // 바인딩할 대상은 여러개지만, 우선 예시로 테이블뷰 데이터들만 바인딩 진행
    output.items.asDriver(onErrorJustReturn: [])
        .drive(tableView.rx.items(cellIdentifier: reuseIdentifier, cellType: EventCell.self)) { tableView, viewModel, cell in
            cell.bind(to: viewModel)
        }.disposed(by: rx.disposeBag)
}
```

## 코드 리팩토링

현재 프로젝트에서 사용하는 뷰모델을 리팩토링하려고 한다. 화면은 다음과 같다.

![31-3](../.vuepress/assets/snack/31-3.png)

현재 코드를 살펴보면 다음과 같다.

```swift
class CompletionViewModel: BindableViewModel {

    // MARK: BindableViewModel Properties
    var apiSession: APIService = APISession()

    var bag = DisposeBag()

    // MARK: - Output
    var goalResponse: Observable<Result<BaseModel<GoalResponse>, APIError>> {
        requestAllGoals(lastGoalId: -1, goalStatusParameter: .complete)
    }

    var enabledRetrospectCountResponse: Observable<Result<BaseModel<RetrospectCount>, APIError>> {
        requestEnabledRetrospectCount()
    }

    var goalData = BehaviorRelay<[ParentGoal]>(value: [])

    var goalDataCount = PublishRelay<Int>()
    var enabledRetrospectCount = BehaviorRelay<Int>(value: 0)
    let isTableviewUpdated = BehaviorRelay<Bool>(value: false)

    var isLoading = BehaviorRelay<Bool>(value: false)
    var presentModal = BehaviorRelay<Bool>(value: false)

    let retrospect = PublishRelay<Retrospect>()
    var lastPageId = -1
    var isLastPage = false

    deinit {
        bag = DisposeBag()
    }
}

extension CompletionViewModel {
    func retrieveGoalData() {
        isLoading.accept(true)

        goalResponse
            .subscribe(onNext: { [unowned self] result in
                switch result {
                case .success(let response):
                    self.goalData.accept(response.data.contents)
                    self.goalDataCount.accept(response.data.contents.count)
                    self.lastPageId = response.data.contents.last?.goalId ?? -1
                    self.isLoading.accept(false)
                    self.isTableviewUpdated.accept(true)
                case .failure(let error):
                    print(error)
                    self.isLoading.accept(false)
                }
            })
            .disposed(by: bag)
    }

    func retrieveGoalDataAtIndex(index: Int) -> ParentGoal {
        return goalData.value[index]
    }

    func retrieveRetrospectWithId(goalId: Int) {
        requestRetrospect(goalId: goalId)
            .subscribe(onNext: { [unowned self] result in
                switch result {
                case .success(let response):
                    self.retrospect.accept(response.data)
                case .failure(let error):
                    print(error)
                }
            })
            .disposed(by: bag)
    }

    func retrieveRetrospectCount() {
        enabledRetrospectCountResponse
            .subscribe(onNext: { [unowned self] result in
                switch result {
                case .success(let countResponse):
                    enabledRetrospectCount.accept(countResponse.data.count)

                    self.retrieveGoalData()

                case .failure(let error):
                    print(error)
                }
            })
            .disposed(by: bag)
    }

    /// 로딩 & lastPage 관련 로직도 추가 필요
    func retrieveMoreRetrospect() {
        isLoading.accept(true)
        requestAllGoals(lastGoalId: lastPageId, goalStatusParameter: .complete)
            .subscribe(onNext: { [unowned self] result in
                switch result {
                case .success(let response):
                    self.isLoading.accept(false)
                    var newData = self.goalData.value
                    newData.append(contentsOf: response.data.contents)
                    self.goalData.accept(newData)
                    self.isLastPage = !response.data.next
                    if !isLastPage {
                        self.lastPageId = response.data.contents.last?.goalId ?? -1
                    }
                case .failure:
                    self.isLoading.accept(false)
                }
            })
            .disposed(by: bag)
    }
}

/// input
extension CompletionViewModel {

    @discardableResult
    func saveRetrospect(goalId: Int, retrospect: Retrospect) -> Observable<Result<BaseModel<Int>, APIError>> {
        return postReview(higherLevelGoalId: goalId, retrospect: retrospect)
    }

    func handlingPostResponse(result: Result<BaseModel<Int>, APIError>) {
        switch result {
        case .success:
            isLoading.accept(false)
            self.presentModal.accept(true)
        case .failure(let error):
            isLoading.accept(false)
            print(error)
        }
    }
}
```

나름 인풋과 아웃풋을 역할에 따라 extension으로 구분하여 정의해두긴 했지만, 직관적이지가 않은 상황이다. 또한 문제는 뷰모델 클래스 인스턴스 자체에 저장속성을 마련하여 클래스 자체가 무거워진다는 단점도 있다.

`Input` & `Output` 프로토콜 정의 후 위 코드를 간단히 수정해보자.

## 리팩토링 1. 원시타입 데이터 바인딩

위 뷰의 인풋은 아래와 같이 정의된다.

1. 완료함 세그먼트 컨트롤 탭에 의해 뷰가 로드되는 시점
2. 테이블뷰 셀 버튼 클릭을 통해 다음 뷰로 푸시

세그먼트 컨트롤의 경우 주의할 점은, 현재 코드의 구성이 세그먼트 아래에 세 개의 서브 뷰컨트롤러를 관리하는 형태이므로 세그먼트 동작 자체를 뷰모델에 삽입하기에 까다로운 상태이다. 따라서 완료함 뷰 자체에 대해서만 인풋과 아웃풋을 정의해야 한다.

```swift
class RefactoredCompletionViewModel: ViewModelType, BindableViewModel {

    var bag = DisposeBag()
    var apiSession: APIService = APISession()

    struct Input {
        let viewDidAppear: Observable<Void>
    }

    struct Output {
        let retrospectCount: BehaviorRelay<Int>
    }

    func transform(input: Input) -> Output {
        // 카운트값 외에 테이블뷰 셀 바인딩을 위한 데이터 요청 로직은 테이블뷰 작성시 추가 예정
        let count = BehaviorRelay<Int>(value: 0)

        input.viewDidAppear
            .flatMapLatest { [unowned self] () -> Observable<Result<BaseModel<RetrospectCount>, APIError>> in
                return self.requestRetrospectCount()
            }
            .subscribe(onNext: {
                switch $0 {
                case .success(let response):
                    count.accept(response.data.count)
                case .failure:
                    count.accept(0)
                }
            })
            .disposed(by: bag)

        return Output(retrospectCount: count, items: elements)
    }

    // apiSession은
    func requestRetrospectCount() -> Observable<Result<BaseModel<RetrospectCount>, APIError>> {
        apiSession.request(.requestEnabledRetrospectCount)
    }

    deinit {
        bag = DisposeBag()
    }
}
```

1. 데이터 요청이 시작되는 트리거를 인풋으로 설정하여 옵저버블로 선언한다.
2. 뷰 컨트롤러에서 생성한 Input 객체를 파라미터로 전달받아 트리거 옵저버블을 구독한다.
3. API 요청후 flatMap 연산자로 데이터를 추출하고 릴레이 객체에 값으로 전달한다.
4. 아웃풋 리턴시 추출된 릴레이 객체를 속성에 담아주고 뷰 컨트롤러에서 해당 값을 바인딩하면 된다.

아래는 뷰 컨트롤러에서의 호출 과정이다.

```swift
// 클래스 내 저장속성 - 트리거 옵저버블
let viewDidAppearTrigger = PublishSubject<Void>()

override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    // viewDidAppear 트리거 후 next 전달
    viewDidAppearTrigger.onNext(())
}

func bindViewModel() {
    // viewDidAppear를 트리거 하여 API 호출이 이루어진다
    let input = RefactoredCompletionViewModel.Input(viewDidAppear: viewDidAppearTrigger, selection: tableView.rx.modelSelected(Retrospect.self).asDriver())

    let output = refactoredViewModel.transform(input: input)

    output.retrospectCount
        .map { count -> NSAttributedString in
            print("COUNT : \(count)")
            let stringValue = "총 \(count)개의 목표 회고를 작성할 수 있어요!"
            let attributedString: NSMutableAttributedString = NSMutableAttributedString(string: stringValue)
            attributedString.setColorForText(textForAttribute: "총 \(count)개의 목표 회고", withColor: .pointPurple)
            return attributedString
        }
        .bind(to: alertBox.label.rx.attributedText)
        .disposed(by: disposeBag)
}
```

## 리팩토링 2. 테이블뷰 바인딩 - 뷰 푸시를 하지 않을때

테이블뷰 내의 셀들에 데이터들을 바인딩해주는 방식을 정리한다. 레퍼런스 프로젝트의 경우 **각 셀에 해당하는 데이터들에 직접 데이터를 바인딩해주지 않고, 뷰모델 클래스를 따로 정의하여 뷰모델을 바인딩해주고 있다.**

아래 예제코드를 살펴보자.

```swift
output.items.asDriver(onErrorJustReturn: [])
    .drive(tableView.rx.items(cellIdentifier: reuseIdentifier, cellType: EventCell.self)) { tableView, viewModel, cell in
        cell.bind(to: viewModel)
    }.disposed(by: rx.disposeBag)
```

셀에 대한 뷰모델을 정의해두고, 뷰모델 객체 자체를 바인딩해주는 방식으로 코드를 구현하게 된다. 이렇게 되면 테이블 뷰를 부착하는 컨트롤러가 비대해지지 않고 셀에 대한 UI 바인딩 로직이 셀 클래스로 분리된다.

![31-4](../.vuepress/assets/snack/31-4.png)

셀이 위와같은 UI로 구성되어 있을때 뷰모델을 정의하면 다음과 같게 된다.

```swift
class CompletionTableViewCellViewModel {
    let title = BehaviorRelay<String>(value: "")
    let startDate = BehaviorRelay<String>(value: "")
    let endDate = BehaviorRelay<String>(value: "")
    let reward = BehaviorRelay<String>(value: "")
    let hasRetrospect = BehaviorRelay<Bool>(value: false)

    let parentGoalSelected = PublishSubject<ParentGoal>()

    init(with parentGoal: ParentGoal) {
        title.accept(parentGoal.title)
        startDate.accept(parentGoal.startDate)
        endDate.accept(parentGoal.endDate)
        reward.accept(parentGoal.reward ?? "")
        hasRetrospect.accept(parentGoal.hasRetrospect)
    }
}
```

1. `title`: 셀 타이틀
2. `startDate` & `endDate`: 시작일자, 종료일자
3. `reward`: 다이아 이미지
4. `hasRetrospect`: 회고 작성 여부에 따른 버튼 스타일 분기

셀 생성자 함수를 구현하여 인스턴스 생성과 동시에 데이터 바인딩을 바로 진행하게 된다.

뷰모델 클래스 정의는 이루어졌으니, 뷰모델 객체를 셀에 바인딩하는 로직을 작성하면 된다. `UITableViewCell` 클래스 내에 커스텀 함수로 `bind(to: 셀 뷰모델)`를 새롭게 정의한다.

```swift
class CompletionTableViewCell: BaseTableViewCell {
    func bind(to viewModel: CompletionTableViewCellViewModel) {
        viewModel.title.asDriver().drive(label.rx.text).disposed(by: disposeBag) // 레이블 바인딩

        // 셀 내의 각종 UI요소 바인딩
    }
}
```

바인딩 로직을 작성했으니, 위의 함수를 적절한 타이밍에 호출만 하면 된다. 현재 API요청은 회고 작성가능 수에 대해서만 이루어지고 있다. `viewDidAppear`시점에 테이블뷰 셀에 바인딩할 `items` 배열 데이터를 아웃풋으로 내보내야 한다.

이때 주의할점은 Output 객체의 `items`속성 타입은 실제 모델 클래스를 참조하지 않고 **데이터를 바인딩할 뷰모델 클래스를 참조한다는 것이다.**

중첩타입 `Output` 구조체의 `items`속성 타입을 테이블뷰 셀 클래스의 뷰모델로 지정한 것을 볼 수 있다.

```swift
struct Output {
    let retrospectCount: BehaviorRelay<Int>
    let items: BehaviorRelay<[CompletionTableViewCellViewModel]>
}
```

컨트롤러에서 output객체를 생성한 뒤 `tableView.rx.items` 메서드로 바인딩을 진행한다.

```swift
output.items.asDriver(onErrorJustReturn: [])
    .drive(tableView.rx.items(cellIdentifier: CompletionTableViewCell.identifier, cellType: CompletionTableViewCell.self)) { row, viewModel, cell in
        cell.bind(to: viewModel)
    }
    .disposed(by: disposeBag)
```

어떤 셀에 바인딩할지 셀 클래스에 대한 메타 데이터들을 `items` 메서드에 전달하고 클로저 파라미터로 전달되는 `items` 속성의 각 원소를 셀에 바인딩해주면 된다.

위와 같이 코드를 작성하면 `bind` 메서드가 자동적으로 호출되며 데이터가 셀 내에 바인딩된다.

## 리팩토링 2-1. Single Trait 활용

기존 코드에서 API 요청을 할때는 아래와 같이 프로토콜을 정의하여 함수를 구현했다.

```swift
protocol APIService {
    func request<T: Codable> (_ request: APIRouter) -> Observable<Result<T, APIError>>
}
```

옵저버블에 `Result`타입을 결합하여 구독시 switch-case 분기처리를 통해 **onNext** 이벤트로 전달된 데이터임에도 해당 클로저에서 에러를 처리해야만 했다. 이러한 코드 구성은 에러 처리에 직관성을 떨어트린다.

참고한 예시 프로젝트에서는 API 요청에 대한 응답 타입을 Rx의 `Single` Trait을 활용하는 것을 볼 수 있었다. 한개의 에러 혹은 정상값을 반환하기때문에 switch-case 분기처리 없이 `onError`에서 에러처리를 하면 된다.

기존 APISession 객체의 `request` 함수의 구현부를 살펴보면 다음과 같다.

```swift
func request<T: Codable> (_ request: APIRouter) -> Observable<Result<T, APIError>> {
    return Observable<Result<T, APIError>>.create { observer in
        let request = API.session.request(request, interceptor: APIInterceptor()).responseDecodable { (response: DataResponse<T, AFError>) in

            guard let statusCode = response.response?.statusCode else {
                observer.onNext(.failure(.unknown))
                return
            }

            guard (200 ... 399).contains(statusCode) else {
                observer.onNext(.failure(.http(status: statusCode)))
                return
            }

            guard let decoded = response.data?.decode(T.self) else {
                observer.onNext(.failure(.decode))
                return
            }

            observer.onNext(.success(decoded))
            observer.onCompleted()
        }

        return Disposables.create {
            request.cancel()
        }
    }
}
```

형태 자체는 `Single` Trait을 활용한 리팩토링 이후와 양식이 거의 유사하다. 달라지는 점은 에러 전달형태 및 함수 리턴타입에만 있다.

```swift
func requestSingle<T: Codable> (_ request: APIRouter) -> Single<T> {
    return Single<T>.create { observer -> Disposable in
        let request = API.session.request(request, interceptor: APIInterceptor()).responseDecodable { (response: DataResponse<T, AFError>) in
            guard let statusCode = response.response?.statusCode else {
                observer(.failure(APIError.unknown))
                return
            }

            guard (200 ... 399).contains(statusCode) else {
                observer(.failure(APIError.http(status: statusCode)))
                return
            }

            guard let decoded = response.data?.decode(T.self) else {
                observer(.failure(APIError.decode))
                return
            }

            observer(.success(decoded))
            return
        }

        return Disposables.create {
            request.cancel()
        }
    }
}
```

`Single` Trait의 Success로 반환되는 타입을 제네릭으로 선언하여 리턴하면 되고, 에러 전달시에는 기존 `request` 함수에서 `Result` 타입의 `failure`케이스처럼 명시적으로 에러 타입을 지정해놓지 않은 상황이기 때문에 타입 추론이 불가능하다.

따라서 `observer(.failure(APIError.어떤에러))`와 같이 `Error` 프로토콜을 채택한 에러 객체만 전달하면 된다.

API 요청에 대한 제네릭 함수 수정 후 실제 라우터 전달과 함께 특정 API에 요청을 보내는 함수를 정의한다. 아래는 기존 코드이다.

```swift
func requestRetrospects() -> Observable<Result<BaseModel<GoalResponse>, APIError>> {
    apiSession.request(.requestAllGoals(lastGoalId: -1, goalStatus: .complete))
}
```

APISession 객체의 리턴 타입이 `Result` 타입을 래핑한 옵저버블이었으므로 함수 리턴타입도 동일하게 Result를 래핑한 옵저버블이 된다.

해당 코드를 수정하면 아래와 같다.

```swift
 func requestRetrospectsSingle() -> Observable<[CompletionTableViewCellViewModel]> {
    var request: Single<BaseModel<GoalResponse>> = apiSession.requestSingle(.requestAllGoals(lastGoalId: -1, goalStatus: .complete))

    return request.map {
        $0.data.contents.map { [unowned self] parentGoal -> CompletionTableViewCellViewModel in
            let viewModel = CompletionTableViewCellViewModel(with: parentGoal)
            viewModel.parentGoalSelected.bind(to: self.parentGoalSelected)
                .disposed(by: self.bag)
            return viewModel
        }
    }.asObservable()
}
```

APISession의 요청 리턴값을 함수 내에 잠시 저장해두고, 적절한 정제 이후 해당 요청을 리턴하게 된다. 정제 과정은 다음과 같다.

1. Single Trait으로 리턴된 변수 저장
2. 테이블뷰 셀들을 위한 데이터를 요청하는 것이므로, 기본적으로 Single Trait의 디코딩 데이터는 배열이다.
3. 배열을 map으로 순회하며 각 요소를 뷰모델 객체로 변환한다.
4. 생성된 뷰모델 배열 객체를 기존 Single에서 옵저버블에 새롭게 담아 리턴한다.

## 리팩토링 3. 테이블뷰 바인딩 - 뷰를 푸시할때

위와 같이 테이블뷰 데이터를 바인딩하면 UI구성은 완료된다. 셀 탭후 선택된 셀이 가지고 있던 데이터들을 기반으로 새로운 뷰를 푸시해야 하는 경우도 있는데, 기존 코드에서 구현했던 방식은 셀의 인덱스값을 기준으로 각각의 셀 데이터를 루트 뷰모델에서 한번 더 요청하는 방법으로 구현했다.

이렇게 되면 루트 뷰모델의 크기가 방대해지고, 관리할 옵저버블도 많아져 메모리상 문제가 발생할 가능성이 높다.

## Reference

1. [RxSwift + MVVM: how to feed ViewModels](https://medium.com/blablacar/rxswift-mvvm-66827b8b3f10)
2. [Dealing with Massive View Models using MVVM on iOS](https://medium.com/etermax-technology/dealing-with-massive-view-models-using-mvvm-on-ios-74b2697557ce)
3. [iOS Swift : MVVM/RxSwift Unit Testing](https://medium.com/@saad-eloulladi/ios-swift-mvvm-rxswift-unit-testing-b71183ecaf44)
4. [RxSwift Unit Testing Explained in 2 Minutes](https://betterprogramming.pub/rxswift-unit-testing-explained-in-3-minutes-c024b7a26d)
5. [kickstarter/ios-oss: Kickstarter for iOS. Bring new ideas to life, anywhere.](https://github.com/kickstarter/ios-oss)
6. [SwiftHub](https://github.com/khoren93/SwiftHub/tree/master#design)
