---
title: Snack 31호 - RxSwift Input & Output
---

## 개요

MVVM 아키텍처 기반의 킥스타터 앱이 오픈소스로 열리게 되어 해당 앱의 소스코드를 살펴보며 뷰모델을 실제로 디자인해보려고 한다.

[RxSwift Sample App](https://github.com/khoren93/SwiftHub/tree/master#design)에 리스트업된 앱을 로컬에 설치한 뒤 빌드 후 직접 결과물을 테스트한다. 로컬에 세팅하는 과정은 리드미를 그대로 따라가면 된다.

```sh
cd SwiftHub
bundle install
bundle exec fastlane setup
```

## 뷰모델 디자인

아래 화면은 SwiftHub 앱의 이벤트 탭에 해당하는 뷰이다. 위 화면에서 사용자로부터 인풋으로 들어올 수 있는 대상을 표시하면 다음과 같다.

![31-1](../.vuepress/assets/snack/31-1.png)

1. 헤더 & 푸터 리프레시
2. 세그먼트 컨트롤 탭
3. 셀 셀렉션 이벤트

이들을 각각 인풋 프로토콜 내에 옵저버블 혹은 드라이버 타입으로 정의해둔 뒤 nested 구조체 타입으로 클래스 내에 정의한다. **이때 각 뷰모델 클래스들은 기본 뷰모델 인풋과 아웃풋 각각을 associatedType으로 갖는 저장속성을 구현 대상으로 하여 프로토콜을 하나 채택해야 한다.**

해당 프로토콜은 아래와 같다. 인풋으로 들어온 대상들을 아웃풋으로 내보내게 되는데, 뷰의 변경사항들은 반드시 아웃풋 중첩 구조체 타입에만 접근해야 한다.

```swift
protocol ViewModelType {
    associatedtype Input
    associatedtype Output

    func transform(input: Input) -> Output
}
```

```swift
// 원래 코드에는 모든 뷰모델에 베이스가 되는 ViewModel 프로토콜이 작성되어 있지만, 예시에서는 제외
class EventViewModel: ViewModelType {
    struct Input {
        let headerRefresh: Observable<Void>
        let footerRefresh: Observable<Void>
        let segmentSelection: Observable<EventSegments>
        let selection: Driver<EventCellViewModel>
    }
}
```

뷰에서 뷰모델을 참조하여 화면에 바인딩해야할 데이터는 크게 다음과 같이 나타난다.

![31-2](../.vuepress/assets/snack/31-2.png)

1. 깃헙 프로필 이미지 URL
2. 테이블뷰 셀에 바인딩할 배열 데이터
3. 그 외

실제 코드상에는 더 다양한 아웃풋 리스트들이 있다. 일단 기억할 것은 `imageUrl` 속성과 `items`정도가 된다.

`userSelected`와 `repositorySelected`의 경우 앱 기능에 특정적인 내용이므로 직접 실행해가며 이해하면 된다. userSelected는 셀 내의 프로필이미지 영역을 탭했을때 푸시되는 뷰이고, repositorySelected의 경우 그 외 영역을 탭했을때 나타나는 뷰이다. 푸시되는 뷰가 다르니 직접 확인하면 된다.

```swift
class EventViewModel: ViewModelType {
    struct Input {
        // ...
    }

    struct Output {
        let navigationTitle: Driver<String>
        let imageUrl: Driver<URL?>
        let items: BehaviorRelay<[EventCellViewModel]>
        let userSelected: Driver<UserViewModel>
        let repositorySelected: Driver<RepositoryViewModel>
        let hidesSegment: Driver<Bool>
    }
}
```

인풋과 아웃풋에 대한 정의가 끝났으면 인풋으로 들어온 이벤트를 적절히 데이터로 정제하여 뷰에 뿌려줘야 한다. 이 역할을 `transform` 함수가 한다.

위 예시 기준으로 리프레시 이벤트가 전달되었다고 가정하고 `transform` 함수 코드를 작성하면 다음과 같은 흐름으로 이루어진다.

1. `input` 파라미터를 구독한다.
2. API 요청 이후 반환된 데이터를 릴레이 객체에 accept로 전달한다.
3. 릴레이 객체는 **클래스 저장속성이 아닌 함수 내에서 변수로 선언한 뒤, 뷰 내에서만 사용하고 메모리에서 해제되도록 설계한다.**

```swift
func transform(input: Input) -> Output {
    let elements = BehaviorRelay<[데이터 모델]>(value: [])

    input.headerRefresh
        .flatMapLatest({ [weak self] () -> Observable<[EventCellViewModel]> in
            guard let self = self else { return Observable.just([]) }
            self.page = 1
            return APIRequest() // API 요청 후 [데이터모델] 반환
        })
        .subscribe(onNext: { (items) in
            elements.accept(items)
        }).disposed(by: rx.disposeBag)

    // ...
}
```

인풋을 통해 아웃풋에 담을 데이터 정의가 끝났다면, `Output` 중첩 타입 객체를 생성하여 리턴하며 함수를 종료한다.

```swift
func transform(input: Input) -> Output {
    let elements = BehaviorRelay<[데이터 모델]>(value: [])

    // Input을 통해 elements에 데이터 담기

    return Output(navigationTitle: .... , items: elements, ....)
}
```

이렇게 정의된 뷰모델을 뷰 컨트롤러에서 다루게 되는 흐름은 다음과 같다. 뷰모델 중첩타입 인풋에 접근하여 인스턴스를 생성, 뷰 컨트롤러 내의 뷰모델 바인딩 함수에서 `transform` 함수 호출에 대한 파라미터에 이를 전달한다.

아래 코드에서 `headerRefreshTrigger`, `segmentSelected` 등의 코드 역시 예제에 종속되는 코드이므로 직접 돌려가며 이해하면 된다.

```swift
func bindViewModel() {
    let refresh = Observable.of(Observable.just(()), headerRefreshTrigger, segmentSelected.mapToVoid().skip(1)).merge() // 리프레시 옵저버블 생성

    // 인풋객체 생성 후 변수에 할당
    let input = EventsViewModel.Input(headerRefresh: refresh,
                                        footerRefresh: footerRefreshTrigger,
                                        segmentSelection: segmentSelected,
                                        selection: tableView.rx.modelSelected(EventCellViewModel.self).asDriver())

    // 아웃풋객체 할당받은 후 본격적인 데이터바인딩 시작
    let output = viewModel.transform(input: input)

    // 바인딩할 대상은 여러개지만, 우선 예시로 테이블뷰 데이터들만 바인딩 진행
    output.items.asDriver(onErrorJustReturn: [])
        .drive(tableView.rx.items(cellIdentifier: reuseIdentifier, cellType: EventCell.self)) { tableView, viewModel, cell in
            cell.bind(to: viewModel)
        }.disposed(by: rx.disposeBag)
}
```

## 코드 리팩토링

현재 프로젝트에서 사용하는 뷰모델을 리팩토링하려고 한다. 화면은 다음과 같다.

![31-3](../.vuepress/assets/snack/31-3.png)

현재 코드를 살펴보면 다음과 같다.

```swift
class CompletionViewModel: BindableViewModel {

    // MARK: BindableViewModel Properties
    var apiSession: APIService = APISession()

    var bag = DisposeBag()

    // MARK: - Output
    var goalResponse: Observable<Result<BaseModel<GoalResponse>, APIError>> {
        requestAllGoals(lastGoalId: -1, goalStatusParameter: .complete)
    }

    var enabledRetrospectCountResponse: Observable<Result<BaseModel<RetrospectCount>, APIError>> {
        requestEnabledRetrospectCount()
    }

    var goalData = BehaviorRelay<[ParentGoal]>(value: [])

    var goalDataCount = PublishRelay<Int>()
    var enabledRetrospectCount = BehaviorRelay<Int>(value: 0)
    let isTableviewUpdated = BehaviorRelay<Bool>(value: false)

    var isLoading = BehaviorRelay<Bool>(value: false)
    var presentModal = BehaviorRelay<Bool>(value: false)

    let retrospect = PublishRelay<Retrospect>()
    var lastPageId = -1
    var isLastPage = false

    deinit {
        bag = DisposeBag()
    }
}

extension CompletionViewModel {
    func retrieveGoalData() {
        isLoading.accept(true)

        goalResponse
            .subscribe(onNext: { [unowned self] result in
                switch result {
                case .success(let response):
                    self.goalData.accept(response.data.contents)
                    self.goalDataCount.accept(response.data.contents.count)
                    self.lastPageId = response.data.contents.last?.goalId ?? -1
                    self.isLoading.accept(false)
                    self.isTableviewUpdated.accept(true)
                case .failure(let error):
                    print(error)
                    self.isLoading.accept(false)
                }
            })
            .disposed(by: bag)
    }

    func retrieveGoalDataAtIndex(index: Int) -> ParentGoal {
        return goalData.value[index]
    }

    func retrieveRetrospectWithId(goalId: Int) {
        requestRetrospect(goalId: goalId)
            .subscribe(onNext: { [unowned self] result in
                switch result {
                case .success(let response):
                    self.retrospect.accept(response.data)
                case .failure(let error):
                    print(error)
                }
            })
            .disposed(by: bag)
    }

    func retrieveRetrospectCount() {
        enabledRetrospectCountResponse
            .subscribe(onNext: { [unowned self] result in
                switch result {
                case .success(let countResponse):
                    enabledRetrospectCount.accept(countResponse.data.count)

                    self.retrieveGoalData()

                case .failure(let error):
                    print(error)
                }
            })
            .disposed(by: bag)
    }

    /// 로딩 & lastPage 관련 로직도 추가 필요
    func retrieveMoreRetrospect() {
        isLoading.accept(true)
        requestAllGoals(lastGoalId: lastPageId, goalStatusParameter: .complete)
            .subscribe(onNext: { [unowned self] result in
                switch result {
                case .success(let response):
                    self.isLoading.accept(false)
                    var newData = self.goalData.value
                    newData.append(contentsOf: response.data.contents)
                    self.goalData.accept(newData)
                    self.isLastPage = !response.data.next
                    if !isLastPage {
                        self.lastPageId = response.data.contents.last?.goalId ?? -1
                    }
                case .failure:
                    self.isLoading.accept(false)
                }
            })
            .disposed(by: bag)
    }
}

/// input
extension CompletionViewModel {

    @discardableResult
    func saveRetrospect(goalId: Int, retrospect: Retrospect) -> Observable<Result<BaseModel<Int>, APIError>> {
        return postReview(higherLevelGoalId: goalId, retrospect: retrospect)
    }

    func handlingPostResponse(result: Result<BaseModel<Int>, APIError>) {
        switch result {
        case .success:
            isLoading.accept(false)
            self.presentModal.accept(true)
        case .failure(let error):
            isLoading.accept(false)
            print(error)
        }
    }
}
```

나름 인풋과 아웃풋을 역할에 따라 extension으로 구분하여 정의해두긴 했지만, 직관적이지가 않은 상황이다. 또한 문제는 뷰모델 클래스 인스턴스 자체에 저장속성을 마련하여 클래스 자체가 무거워진다는 단점도 있다.

`Input` & `Output` 프로토콜 정의 후 위 코드를 간단히 수정해보자.

## 리팩토링 1. 인풋 정의

위 뷰의 인풋은 아래와 같이 정의된다.

1. 완료함 세그먼트 컨트롤 탭에 의해 뷰가 로드되는 시점
2. 테이블뷰 셀 버튼 클릭을 통해 다음 뷰로 푸시

세그먼트 컨트롤의 경우 주의할 점은, 현재 코드의 구성이 세그먼트 아래에 세 개의 서브 뷰컨트롤러를 관리하는 형태이므로 세그먼트 동작 자체를 뷰모델에 삽입하기에 까다로운 상태이다. 따라서 완료함 뷰 자체에 대해서만 인풋과 아웃풋을 정의해야 한다.

```swift
class RefactoredCompletionViewModel: ViewModelType, BindableViewModel {

    var bag = DisposeBag()
    var apiSession: APIService = APISession()

    struct Input {
        let viewDidAppear: Observable<Void>
    }

    struct Output {
        let retrospectCount: BehaviorRelay<Int>
    }

    func transform(input: Input) -> Output {
        // 카운트값 외에 테이블뷰 셀 바인딩을 위한 데이터 요청 로직은 테이블뷰 작성시 추가 예정
        let count = BehaviorRelay<Int>(value: 0)

        input.viewDidAppear
            .flatMapLatest { [unowned self] () -> Observable<Result<BaseModel<RetrospectCount>, APIError>> in
                return self.requestRetrospectCount()
            }
            .subscribe(onNext: {
                switch $0 {
                case .success(let response):
                    count.accept(response.data.count)
                case .failure:
                    count.accept(0)
                }
            })
            .disposed(by: bag)

        return Output(retrospectCount: count, items: elements)
    }

    // apiSession은
    func requestRetrospectCount() -> Observable<Result<BaseModel<RetrospectCount>, APIError>> {
        apiSession.request(.requestEnabledRetrospectCount)
    }

    deinit {
        bag = DisposeBag()
    }
}
```

1. 데이터 요청이 시작되는 트리거를 인풋으로 설정하여 옵저버블로 선언한다.
2. 뷰 컨트롤러에서 생성한 Input 객체를 파라미터로 전달받아 트리거 옵저버블을 구독한다.
3. API 요청후 flatMap 연산자로 데이터를 추출하고 릴레이 객체에 값으로 전달한다.
4. 아웃풋 리턴시 추출된 릴레이 객체를 속성에 담아주고 뷰 컨트롤러에서 해당 값을 바인딩하면 된다.

아래는 뷰 컨트롤러에서의 호출 과정이다.

```swift
// 클래스 내 저장속성 - 트리거 옵저버블
let viewDidAppearTrigger = PublishSubject<Void>()

override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    // viewDidAppear 트리거 후 next 전달
    viewDidAppearTrigger.onNext(())
}

func bindViewModel() {
    // viewDidAppear를 트리거 하여 API 호출이 이루어진다
    let input = RefactoredCompletionViewModel.Input(viewDidAppear: viewDidAppearTrigger, selection: tableView.rx.modelSelected(Retrospect.self).asDriver())

    let output = refactoredViewModel.transform(input: input)

    output.retrospectCount
        .map { count -> NSAttributedString in
            print("COUNT : \(count)")
            let stringValue = "총 \(count)개의 목표 회고를 작성할 수 있어요!"
            let attributedString: NSMutableAttributedString = NSMutableAttributedString(string: stringValue)
            attributedString.setColorForText(textForAttribute: "총 \(count)개의 목표 회고", withColor: .pointPurple)
            return attributedString
        }
        .bind(to: alertBox.label.rx.attributedText)
        .disposed(by: disposeBag)
}
```

## Reference

1. [RxSwift + MVVM: how to feed ViewModels](https://medium.com/blablacar/rxswift-mvvm-66827b8b3f10)
2. [Dealing with Massive View Models using MVVM on iOS](https://medium.com/etermax-technology/dealing-with-massive-view-models-using-mvvm-on-ios-74b2697557ce)
3. [iOS Swift : MVVM/RxSwift Unit Testing](https://medium.com/@saad-eloulladi/ios-swift-mvvm-rxswift-unit-testing-b71183ecaf44)
4. [RxSwift Unit Testing Explained in 2 Minutes](https://betterprogramming.pub/rxswift-unit-testing-explained-in-3-minutes-c024b7a26d)
5. [kickstarter/ios-oss: Kickstarter for iOS. Bring new ideas to life, anywhere.](https://github.com/kickstarter/ios-oss)
6. [SwiftHub](https://github.com/khoren93/SwiftHub/tree/master#design)
