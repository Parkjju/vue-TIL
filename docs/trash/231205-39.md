---
title: Snack 39호 - [iOS] Kingfisher 네트워크 목업 테스트
---

# 들어가며

이 글은 `RxTest`기반의 테스트 코드 작성과 관련된 글입니다. 다음 글들을 먼저 읽고 오시면 아래에 이어질 글을 이해하는 데에 더 큰 도움이 됩니다.

1. [유닛 테스트 환경 구축](https://parkjju.github.io/vue-TIL/trash/230918-32.html)
2. [RxBlocking, RxTest로 테스트코드 작성하기](https://parkjju.github.io/vue-TIL/trash/231129-37.html)
3. [네트워크 목업 테스트](https://parkjju.github.io/vue-TIL/trash/231202-38.html)

:::tip 필요한 사전지식

1. `RxSwift`
2. `Kingfisher`
3. 유닛 테스트에 대한 이해

:::

## 이미지 캐싱과 외부환경 의존성

테스트 코드 작성에 있어 가장 중요한 대전제는 **외부 환경에 의존해서는 안된다는 것이다.**

Kingfisher 라이브러리는 메모리에 이미지들을 캐싱하여 컬렉션뷰와 같이 빠른 속도로 컨텐츠 로딩이 필요한 뷰 구성에 많은 도움을 준다. 아래 화면을 잠깐 확인해보자.

![39-1](../.vuepress/assets/snack/39-1.gif)

위 화면을 구현하는 데에 작성된 코드 흐름은 다음과 같다.

1. 포즈피드 메뉴 이동과 동시에 피드 초기 데이터 로딩 (API 요청)
2. 스크롤이 끝에 닿았을때 다음 페이지 데이터 요청

이때 API 요청을 통해 불러온 JSON 데이터 일부를 보면 아래와 같다.

```json
"content": [
    {
      "poseInfo": {
        "createdAt": "2023-09-24T20:07:07.44874",
        "updatedAt": "2023-09-24T23:27:53.504153",
        "imageKey": "https://AmazonS3 URL/이미지명.jpg",
        "poseId": 325,
      }
    },
    {
      "poseInfo": {
        "createdAt": "2023-09-24T20:09:52.465325",
        "updatedAt": "2023-09-24T20:09:52.465325",
        "imageKey": "https://AmazonS3 URL/이미지명.jpg",
        "poseId": 327,
      }
    },
    // ....
]
```

위의 데이터 속성값 중 `imageKey`가 아마존 S3에서 넘겨받은 이미지 URL이다. 이미지 데이터를 직접 넘겨주지 않고 위와 같이 이미지 URL을 클라이언트에 넘겨주면 직접 다운로드 받는 방식으로 구현하는 것이 일반적이다.

이때 이미지를 다운로드 한다는 점에서 클라이언트 자체 리소스를 사용한다는 부분이 중요하다. 컬렉션뷰 구성 시 스크롤이 되면서 기존 셀들을 재사용하는 형태로 내부가 구현되는데 기존 이미지를 초기화하면 동일한 셀 위치로 스크롤이 다시 이루어져 해당 셀을 표기하고자 할때 **전에 다운로드 했던 이미지를 또 다시 다운로드 받아야 한다는 점이 큰 문제이다.**

킹피셔 라이브러리는 이러한 문제를 쉽게 관리할 수 있게끔 캐시 CRUD에 대한 접근성을 쉽게 추상화 해두었다.

위 화면 구현에 사용된 코드의 일부를 보면 다음과 같다.

```swift
input.requestAllPoseTrigger
    .flatMapLatest { [unowned self] _ -> Observable<PoseFeed> in
        loadable.accept(true)
        return self.apiSession.requestSingle(.retrieveAllPoseFeed(pageNumber: self.currentPage, pageSize: 8)).asObservable()
    }
    .map { $0.content }
    .flatMapLatest { [unowned self] posefeed -> Observable<[PoseFeedPhotoCellViewModel]> in
        return self.retrieveCacheObservable(posefeed: posefeed) // 이미지 캐싱!
    }
    .subscribe(onNext: {
        loadable.accept(false)
        filterSection.accept($0)
    })
    .disposed(by: disposeBag)
```

1. `viewDidLoad` 시점에 퍼블리시 서브젝트로 `requestAllPoseTrigger`를 트리거 하여 API 요청을 진행한다.
2. 로드된 객체의 `content` 속성에 접근하여 배열을 순회하며 `imageKey`값을 기준으로 이미지 캐싱 로직을 실행한다.
3. 불러온 이미지를 기준으로 컬렉션뷰 셀 뷰모델을 `BehaviorRelay`객체에 `accept`시켜 뷰 컨트롤러로 전달 및 바인딩을 진행한다.

이때 중간의 `flatMapLatest` 코드를 보면 `retrieveCacheObservable`이라는 함수를 호출하는 것을 볼 수 있다.

## retrieveCacheObservable 함수에 대한 이해

아래 함수는 직접 작성한 코드이다.

```swift
func retrieveCacheObservable(posefeed: [PosePick], isFilterSection: Bool = true) -> Observable<[CellViewModel]> {
    let viewModelObservable = BehaviorRelay<[CellViewModel]>(value: [])

    posefeed.forEach { posepick in
        ImageCache.default.retrieveImage(forKey: posepick.poseInfo.imageKey, options: nil) { [weak self] result in
            guard let self = self else { return }
            switch result {
            case .success(let value):
                if let image = value.image {
                    let viewModel = CellViewModel(image: image, poseId: posepick.poseInfo.poseId)
                    viewModelObservable.accept(viewModelObservable.value + [viewModel])
                } else {
                    guard let url = URL(string: posepick.poseInfo.imageKey) else { return }
                    KingfisherManager.shared.retrieveImage(with: url) { downloadResult in
                        switch downloadResult {
                        case .success(let downloadImage):
                            let viewModel = CellViewModel(image: downloadImage.image, poseId: posepick.poseInfo.poseId)
                            viewModelObservable.accept(viewModelObservable.value + [viewModel])
                        case .failure:
                            return
                        }
                    }
                }
            case .failure:
                return
            }
        }
    }
    return viewModelObservable.asObservable().skip(while: { $0.count < posefeed.count })
}
```

함수 파라미터로 `[PosePick]` 타입의 데이터를 전달받는데, 위의 JSON 예시 데이터에서 `content` 키값에 대한 밸류값이 `[PosePick]`에 해당한다. 이 값을 `forEach`로 순회하며 `imageKey`값을 추출하여 킹피셔의 이미지 캐싱 로직을 호출하게 된다.

셀 뷰모델 배열을 생성하여 리턴하는 이유에 대해서는 `Input` & `Output` & `transform`에 대한 이해가 필요하다. 자세한 내용은 [다음 글을](https://parkjju.github.io/vue-TIL/trash/230918-31.html) 참고하자.

중요한 `viewModelObservable`에 셀 뷰모델을 `accept`하는 등의 내용은 미뤄두고, 킹피셔 로직 자체에만 집중해보자.

1. 초기에 킹피셔 캐시 저장소의 `ImageCache.default` 객체의 `retrieveImage(forKey: )` 파라미터를 통해 이미지 URL 기준으로 캐시에 이미지가 저장되어 있는지 여부를 체크한다.
2. 이미지 URL을 키값으로 하여 이미지가 이미 캐싱되어 있었다면 그대로 이미지를 객체화하여 로드한다.
3. 이미지가 캐싱되어 있지 않았다면 `KingfisherManager.shared.retrieveImage(with: url)` 메서드를 호출하여 이미지를 직접 다운로드한다.
4. 다운로드된 이미지 객체는 해당 URL을 기준으로 자동으로 캐싱된다.

이때 3~4번으로 이어지는 과정이 바로 네트워크라는 외부 환경에 종속되는 문제가 있다. 캐싱된 이미지에 접근하는 경우 메모리 내부 상황이 역시나 매번 동일한 상황이 아니기에 이에 대한 독립성 보장도 필요한데, 이는 **매 테스트 셋업 단계에서 캐시를 비워줌으로써 네트워크를 통한 이미지 설치 로직만 거쳐가도록 강제하는 방법으로 우선 구현해두었다.**

## 테스트 코드 작성
