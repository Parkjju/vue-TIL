---
title: Snack 39Ìò∏ - [iOS] Kingfisher ÎÑ§Ìä∏ÏõåÌÅ¨ Î™©ÏóÖ ÌÖåÏä§Ìä∏
tags:
    [
        'Snack',
        'RxSwift',
        'UIKit',
        'Kingfisher',
        'Unit Test',
        'Ìè¨Ï¶àÌîºÏª§ Í∞úÎ∞ú Ïù¥ÏïºÍ∏∞',
    ]
---

ÌîÑÎ°úÏ†ùÌä∏ Ìè¨Ï¶àÌîºÏª§ Í∞úÎ∞ú Ïù¥ÏïºÍ∏∞ÏûÖÎãàÎã§! Í∂ÅÍ∏àÌïòÏãúÎã§Î©¥ ÎÜÄÎü¨ÏôÄÏ£ºÏÑ∏Ïöî :) [[Ìè¨Ï¶àÌîºÏª§ Îã§Ïö¥Î∞õÍ∏∞üîó]](https://apps.apple.com/kr/app/%ED%8F%AC%EC%A6%88%ED%94%BC%EC%BB%A4-%EB%84%A4%EC%BB%B7%EC%82%AC%EC%A7%84-%ED%8F%AC%EC%A6%88%EC%B6%94%EC%B2%9C/id6474260471)

# Îì§Ïñ¥Í∞ÄÎ©∞

Ïù¥ Í∏ÄÏùÄ `RxTest`Í∏∞Î∞òÏùò ÌÖåÏä§Ìä∏ ÏΩîÎìú ÏûëÏÑ±Í≥º Í¥ÄÎ†®Îêú Í∏ÄÏûÖÎãàÎã§. Îã§Ïùå Í∏ÄÎì§ÏùÑ Î®ºÏ†Ä ÏùΩÍ≥† Ïò§ÏãúÎ©¥ ÏïÑÎûòÏóê Ïù¥Ïñ¥Ïßà Í∏ÄÏùÑ Ïù¥Ìï¥ÌïòÎäî Îç∞Ïóê Îçî ÌÅ∞ ÎèÑÏõÄÏù¥ Îê©ÎãàÎã§.

1. [Ïú†Îãõ ÌÖåÏä§Ìä∏ ÌôòÍ≤Ω Íµ¨Ï∂ï](https://parkjju.github.io/vue-TIL/trash/230918-32.html)
2. [RxBlocking, RxTestÎ°ú ÌÖåÏä§Ìä∏ÏΩîÎìú ÏûëÏÑ±ÌïòÍ∏∞](https://parkjju.github.io/vue-TIL/trash/231129-37.html)
3. [ÎÑ§Ìä∏ÏõåÌÅ¨ Î™©ÏóÖ ÌÖåÏä§Ìä∏](https://parkjju.github.io/vue-TIL/trash/231202-38.html)

:::tip ÌïÑÏöîÌïú ÏÇ¨Ï†ÑÏßÄÏãù

1. `RxSwift`
2. `Kingfisher`
3. Ïú†Îãõ ÌÖåÏä§Ìä∏Ïóê ÎåÄÌïú Ïù¥Ìï¥

:::

## Ïù¥ÎØ∏ÏßÄ Ï∫êÏã±Í≥º Ïô∏Î∂ÄÌôòÍ≤Ω ÏùòÏ°¥ÏÑ±

ÌÖåÏä§Ìä∏ ÏΩîÎìú ÏûëÏÑ±Ïóê ÏûàÏñ¥ Í∞ÄÏû• Ï§ëÏöîÌïú ÎåÄÏ†ÑÏ†úÎäî **Ïô∏Î∂Ä ÌôòÍ≤ΩÏóê ÏùòÏ°¥Ìï¥ÏÑúÎäî ÏïàÎêúÎã§Îäî Í≤ÉÏù¥Îã§.**

Kingfisher ÎùºÏù¥Î∏åÎü¨Î¶¨Îäî Î©îÎ™®Î¶¨Ïóê Ïù¥ÎØ∏ÏßÄÎì§ÏùÑ Ï∫êÏã±ÌïòÏó¨ Ïª¨Î†âÏÖòÎ∑∞ÏôÄ Í∞ôÏù¥ Îπ†Î•∏ ÏÜçÎèÑÎ°ú Ïª®ÌÖêÏ∏† Î°úÎî©Ïù¥ ÌïÑÏöîÌïú Î∑∞ Íµ¨ÏÑ±Ïóê ÎßéÏùÄ ÎèÑÏõÄÏùÑ Ï§ÄÎã§. ÏïÑÎûò ÌôîÎ©¥ÏùÑ Ïû†Íπê ÌôïÏù∏Ìï¥Î≥¥Ïûê.

![39-1](../.vuepress/assets/snack/39-1.gif)

ÏúÑ ÌôîÎ©¥ÏùÑ Íµ¨ÌòÑÌïòÎäî Îç∞Ïóê ÏûëÏÑ±Îêú ÏΩîÎìú ÌùêÎ¶ÑÏùÄ Îã§ÏùåÍ≥º Í∞ôÎã§.

1. Ìè¨Ï¶àÌîºÎìú Î©îÎâ¥ Ïù¥ÎèôÍ≥º ÎèôÏãúÏóê ÌîºÎìú Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î°úÎî© (API ÏöîÏ≤≠)
2. Ïä§ÌÅ¨Î°§Ïù¥ ÎÅùÏóê ÎãøÏïòÏùÑÎïå Îã§Ïùå ÌéòÏù¥ÏßÄ Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠

Ïù¥Îïå API ÏöîÏ≤≠ÏùÑ ÌÜµÌï¥ Î∂àÎü¨Ïò® JSON Îç∞Ïù¥ÌÑ∞ ÏùºÎ∂ÄÎ•º Î≥¥Î©¥ ÏïÑÎûòÏôÄ Í∞ôÎã§.

```json
"content": [
    {
      "poseInfo": {
        "createdAt": "2023-09-24T20:07:07.44874",
        "updatedAt": "2023-09-24T23:27:53.504153",
        "imageKey": "https://AmazonS3 URL/Ïù¥ÎØ∏ÏßÄÎ™Ö.jpg",
        "poseId": 325,
      }
    },
    {
      "poseInfo": {
        "createdAt": "2023-09-24T20:09:52.465325",
        "updatedAt": "2023-09-24T20:09:52.465325",
        "imageKey": "https://AmazonS3 URL/Ïù¥ÎØ∏ÏßÄÎ™Ö.jpg",
        "poseId": 327,
      }
    },
    // ....
]
```

ÏúÑÏùò Îç∞Ïù¥ÌÑ∞ ÏÜçÏÑ±Í∞í Ï§ë `imageKey`Í∞Ä ÏïÑÎßàÏ°¥ S3ÏóêÏÑú ÎÑòÍ≤®Î∞õÏùÄ Ïù¥ÎØ∏ÏßÄ URLÏù¥Îã§. Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞Î•º ÏßÅÏ†ë ÎÑòÍ≤®Ï£ºÏßÄ ÏïäÍ≥† ÏúÑÏôÄ Í∞ôÏù¥ Ïù¥ÎØ∏ÏßÄ URLÏùÑ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïóê ÎÑòÍ≤®Ï£ºÎ©¥ ÏßÅÏ†ë Îã§Ïö¥Î°úÎìú Î∞õÎäî Î∞©ÏãùÏúºÎ°ú Íµ¨ÌòÑÌïòÎäî Í≤ÉÏù¥ ÏùºÎ∞òÏ†ÅÏù¥Îã§.

Ïù¥Îïå Ïù¥ÎØ∏ÏßÄÎ•º Îã§Ïö¥Î°úÎìú ÌïúÎã§Îäî Ï†êÏóêÏÑú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏûêÏ≤¥ Î¶¨ÏÜåÏä§Î•º ÏÇ¨Ïö©ÌïúÎã§Îäî Î∂ÄÎ∂ÑÏù¥ Ï§ëÏöîÌïòÎã§. Ïª¨Î†âÏÖòÎ∑∞ Íµ¨ÏÑ± Ïãú Ïä§ÌÅ¨Î°§Ïù¥ ÎêòÎ©¥ÏÑú Í∏∞Ï°¥ ÏÖÄÎì§ÏùÑ Ïû¨ÏÇ¨Ïö©ÌïòÎäî ÌòïÌÉúÎ°ú ÎÇ¥Î∂ÄÍ∞Ä Íµ¨ÌòÑÎêòÎäîÎç∞ Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄÎ•º Ï¥àÍ∏∞ÌôîÌïòÎ©¥ ÎèôÏùºÌïú ÏÖÄ ÏúÑÏπòÎ°ú Ïä§ÌÅ¨Î°§Ïù¥ Îã§Ïãú Ïù¥Î£®Ïñ¥Ï†∏ Ìï¥Îãπ ÏÖÄÏùÑ ÌëúÍ∏∞ÌïòÍ≥†Ïûê Ìï†Îïå **Ï†ÑÏóê Îã§Ïö¥Î°úÎìú ÌñàÎçò Ïù¥ÎØ∏ÏßÄÎ•º Îòê Îã§Ïãú Îã§Ïö¥Î°úÎìú Î∞õÏïÑÏïº ÌïúÎã§Îäî Ï†êÏù¥ ÌÅ∞ Î¨∏Ï†úÏù¥Îã§.**

ÌÇπÌîºÏÖî ÎùºÏù¥Î∏åÎü¨Î¶¨Îäî Ïù¥Îü¨Ìïú Î¨∏Ï†úÎ•º ÏâΩÍ≤å Í¥ÄÎ¶¨Ìï† Ïàò ÏûàÍ≤åÎÅî Ï∫êÏãú CRUDÏóê ÎåÄÌïú Ï†ëÍ∑ºÏÑ±ÏùÑ ÏâΩÍ≤å Ï∂îÏÉÅÌôî Ìï¥ÎëêÏóàÎã§.

ÏúÑ ÌôîÎ©¥ Íµ¨ÌòÑÏóê ÏÇ¨Ïö©Îêú ÏΩîÎìúÏùò ÏùºÎ∂ÄÎ•º Î≥¥Î©¥ Îã§ÏùåÍ≥º Í∞ôÎã§.

```swift
input.requestAllPoseTrigger
    .flatMapLatest { [unowned self] _ -> Observable<PoseFeed> in
        loadable.accept(true)
        return self.apiSession.requestSingle(.retrieveAllPoseFeed(pageNumber: self.currentPage, pageSize: 8)).asObservable()
    }
    .map { $0.content }
    .flatMapLatest { [unowned self] posefeed -> Observable<[PoseFeedPhotoCellViewModel]> in
        return self.retrieveCacheObservable(posefeed: posefeed) // Ïù¥ÎØ∏ÏßÄ Ï∫êÏã±!
    }
    .subscribe(onNext: {
        loadable.accept(false)
        filterSection.accept($0)
    })
    .disposed(by: disposeBag)
```

1. `viewDidLoad` ÏãúÏ†êÏóê ÌçºÎ∏îÎ¶¨Ïãú ÏÑúÎ∏åÏ†ùÌä∏Î°ú `requestAllPoseTrigger`Î•º Ìä∏Î¶¨Í±∞ ÌïòÏó¨ API ÏöîÏ≤≠ÏùÑ ÏßÑÌñâÌïúÎã§.
2. Î°úÎìúÎêú Í∞ùÏ≤¥Ïùò `content` ÏÜçÏÑ±Ïóê Ï†ëÍ∑ºÌïòÏó¨ Î∞∞Ïó¥ÏùÑ ÏàúÌöåÌïòÎ©∞ `imageKey`Í∞íÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Ïù¥ÎØ∏ÏßÄ Ï∫êÏã± Î°úÏßÅÏùÑ Ïã§ÌñâÌïúÎã§.
3. Î∂àÎü¨Ïò® Ïù¥ÎØ∏ÏßÄÎ•º Í∏∞Ï§ÄÏúºÎ°ú Ïª¨Î†âÏÖòÎ∑∞ ÏÖÄ Î∑∞Î™®Îç∏ÏùÑ `BehaviorRelay`Í∞ùÏ≤¥Ïóê `accept`ÏãúÏºú Î∑∞ Ïª®Ìä∏Î°§Îü¨Î°ú Ï†ÑÎã¨ Î∞è Î∞îÏù∏Îî©ÏùÑ ÏßÑÌñâÌïúÎã§.

Ïù¥Îïå Ï§ëÍ∞ÑÏùò `flatMapLatest` ÏΩîÎìúÎ•º Î≥¥Î©¥ `retrieveCacheObservable`Ïù¥ÎùºÎäî Ìï®ÏàòÎ•º Ìò∏Ï∂úÌïòÎäî Í≤ÉÏùÑ Î≥º Ïàò ÏûàÎã§.

## retrieveCacheObservable Ìï®ÏàòÏóê ÎåÄÌïú Ïù¥Ìï¥

ÏïÑÎûò Ìï®ÏàòÎäî ÏßÅÏ†ë ÏûëÏÑ±Ìïú ÏΩîÎìúÏù¥Îã§.

```swift
func retrieveCacheObservable(posefeed: [PosePick], isFilterSection: Bool = true) -> Observable<[CellViewModel]> {
    let viewModelObservable = BehaviorRelay<[CellViewModel]>(value: [])

    posefeed.forEach { posepick in
        ImageCache.default.retrieveImage(forKey: posepick.poseInfo.imageKey, options: nil) { [weak self] result in
            guard let self = self else { return }
            switch result {
            case .success(let value):
                if let image = value.image {
                    let viewModel = CellViewModel(image: image, poseId: posepick.poseInfo.poseId)
                    viewModelObservable.accept(viewModelObservable.value + [viewModel])
                } else {
                    guard let url = URL(string: posepick.poseInfo.imageKey) else { return }
                    KingfisherManager.shared.retrieveImage(with: url) { downloadResult in
                        switch downloadResult {
                        case .success(let downloadImage):
                            let viewModel = CellViewModel(image: downloadImage.image, poseId: posepick.poseInfo.poseId)
                            viewModelObservable.accept(viewModelObservable.value + [viewModel])
                        case .failure:
                            return
                        }
                    }
                }
            case .failure:
                return
            }
        }
    }
    return viewModelObservable.asObservable().skip(while: { $0.count < posefeed.count })
}
```

Ìï®Ïàò ÌååÎùºÎØ∏ÌÑ∞Î°ú `[PosePick]` ÌÉÄÏûÖÏùò Îç∞Ïù¥ÌÑ∞Î•º Ï†ÑÎã¨Î∞õÎäîÎç∞, ÏúÑÏùò JSON ÏòàÏãú Îç∞Ïù¥ÌÑ∞ÏóêÏÑú `content` ÌÇ§Í∞íÏóê ÎåÄÌïú Î∞∏Î•òÍ∞íÏù¥ `[PosePick]`Ïóê Ìï¥ÎãπÌïúÎã§. Ïù¥ Í∞íÏùÑ `forEach`Î°ú ÏàúÌöåÌïòÎ©∞ `imageKey`Í∞íÏùÑ Ï∂îÏ∂úÌïòÏó¨ ÌÇπÌîºÏÖîÏùò Ïù¥ÎØ∏ÏßÄ Ï∫êÏã± Î°úÏßÅÏùÑ Ìò∏Ï∂úÌïòÍ≤å ÎêúÎã§.

ÏÖÄ Î∑∞Î™®Îç∏ Î∞∞Ïó¥ÏùÑ ÏÉùÏÑ±ÌïòÏó¨ Î¶¨ÌÑ¥ÌïòÎäî Ïù¥Ïú†Ïóê ÎåÄÌï¥ÏÑúÎäî `Input` & `Output` & `transform`Ïóê ÎåÄÌïú Ïù¥Ìï¥Í∞Ä ÌïÑÏöîÌïòÎã§. ÏûêÏÑ∏Ìïú ÎÇ¥Ïö©ÏùÄ [Îã§Ïùå Í∏ÄÏùÑ](https://parkjju.github.io/vue-TIL/trash/230918-31.html) Ï∞∏Í≥†ÌïòÏûê.

Ï§ëÏöîÌïú `viewModelObservable`Ïóê ÏÖÄ Î∑∞Î™®Îç∏ÏùÑ `accept`ÌïòÎäî Îì±Ïùò ÎÇ¥Ïö©ÏùÄ ÎØ∏Î§ÑÎëêÍ≥†, ÌÇπÌîºÏÖî Î°úÏßÅ ÏûêÏ≤¥ÏóêÎßå ÏßëÏ§ëÌï¥Î≥¥Ïûê.

1. Ï¥àÍ∏∞Ïóê ÌÇπÌîºÏÖî Ï∫êÏãú Ï†ÄÏû•ÏÜåÏùò `ImageCache.default` Í∞ùÏ≤¥Ïùò `retrieveImage(forKey: )` ÌååÎùºÎØ∏ÌÑ∞Î•º ÌÜµÌï¥ Ïù¥ÎØ∏ÏßÄ URL Í∏∞Ï§ÄÏúºÎ°ú Ï∫êÏãúÏóê Ïù¥ÎØ∏ÏßÄÍ∞Ä Ï†ÄÏû•ÎêòÏñ¥ ÏûàÎäîÏßÄ Ïó¨Î∂ÄÎ•º Ï≤¥ÌÅ¨ÌïúÎã§.
2. Ïù¥ÎØ∏ÏßÄ URLÏùÑ ÌÇ§Í∞íÏúºÎ°ú ÌïòÏó¨ Ïù¥ÎØ∏ÏßÄÍ∞Ä Ïù¥ÎØ∏ Ï∫êÏã±ÎêòÏñ¥ ÏûàÏóàÎã§Î©¥ Í∑∏ÎåÄÎ°ú Ïù¥ÎØ∏ÏßÄÎ•º Í∞ùÏ≤¥ÌôîÌïòÏó¨ Î°úÎìúÌïúÎã§.
3. Ïù¥ÎØ∏ÏßÄÍ∞Ä Ï∫êÏã±ÎêòÏñ¥ ÏûàÏßÄ ÏïäÏïòÎã§Î©¥ `KingfisherManager.shared.retrieveImage(with: url)` Î©îÏÑúÎìúÎ•º Ìò∏Ï∂úÌïòÏó¨ Ïù¥ÎØ∏ÏßÄÎ•º ÏßÅÏ†ë Îã§Ïö¥Î°úÎìúÌïúÎã§.
4. Îã§Ïö¥Î°úÎìúÎêú Ïù¥ÎØ∏ÏßÄ Í∞ùÏ≤¥Îäî Ìï¥Îãπ URLÏùÑ Í∏∞Ï§ÄÏúºÎ°ú ÏûêÎèôÏúºÎ°ú Ï∫êÏã±ÎêúÎã§.

Ïù¥Îïå 3~4Î≤àÏúºÎ°ú Ïù¥Ïñ¥ÏßÄÎäî Í≥ºÏ†ïÏù¥ Î∞îÎ°ú ÎÑ§Ìä∏ÏõåÌÅ¨ÎùºÎäî Ïô∏Î∂Ä ÌôòÍ≤ΩÏóê Ï¢ÖÏÜçÎêòÎäî Î¨∏Ï†úÍ∞Ä ÏûàÎã§. Ï∫êÏã±Îêú Ïù¥ÎØ∏ÏßÄÏóê Ï†ëÍ∑ºÌïòÎäî Í≤ΩÏö∞ Î©îÎ™®Î¶¨ ÎÇ¥Î∂Ä ÏÉÅÌô©Ïù¥ Ïó≠ÏãúÎÇò Îß§Î≤à ÎèôÏùºÌïú ÏÉÅÌô©Ïù¥ ÏïÑÎãàÍ∏∞Ïóê Ïù¥Ïóê ÎåÄÌïú ÎèÖÎ¶ΩÏÑ± Î≥¥Ïû•ÎèÑ ÌïÑÏöîÌïúÎç∞, Ïù¥Îäî **Îß§ ÌÖåÏä§Ìä∏ ÏÖãÏóÖ Îã®Í≥ÑÏóêÏÑú Ï∫êÏãúÎ•º ÎπÑÏõåÏ§åÏúºÎ°úÏç® ÎÑ§Ìä∏ÏõåÌÅ¨Î•º ÌÜµÌïú Ïù¥ÎØ∏ÏßÄ ÏÑ§Ïπò Î°úÏßÅÎßå Í±∞Ï≥êÍ∞ÄÎèÑÎ°ù Í∞ïÏ†úÌïòÎäî Î∞©Î≤ïÏúºÎ°ú Ïö∞ÏÑ† Íµ¨ÌòÑÌï¥ÎëêÏóàÎã§.**

## ÌÇπÌîºÏÖî options ÎëòÎü¨Î≥¥Í∏∞

ÌÖåÏä§Ìä∏ ÏΩîÎìú ÏûëÏÑ±ÏùÑ ÏúÑÌï¥ ÌïÑÏöîÌïú Î™©ÏóÖ ÎÑ§Ìä∏ÏõåÌÇπÏùÄ Îã§ÏùåÍ≥º Í∞ôÎã§.

1. Î∂ÅÎßàÌÅ¨ Ïª®ÌÖêÏ∏†Îì§Ïóê ÎåÄÌïú Ï†ïÎ≥¥Î•º Í∞ñÎäî JSON ÌååÏùº ÏöîÏ≤≠
2. 1Î≤àÏóêÏÑú ÌöçÎìùÌïú JSON ÎÇ¥ÏóêÏÑú Ïù¥ÎØ∏ÏßÄ URLÏùÑ Ï∂îÏ∂úÌïòÏó¨ Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞ Îã§Ïö¥Î°úÎìú

Ïù¥Îïå 1Î≤à Í≥ºÏ†ïÏùÄ [Ïù¥Ï†Ñ Í∏Ä](./231202-38.md)ÏóêÏÑú ÏûëÏÑ±Ìïú `MockURLProtocol`ÏùÑ ÌÜµÌï¥ ÏßÅÏ†ë ÏûëÏÑ±Ìïú Î°úÏª¨Ïùò JSON ÌååÏùºÏùÑ ÎîîÏΩîÎî©ÌïòÎäî Í≤ÉÏúºÎ°ú Ìï¥Í≤∞ÌïòÏòÄÎã§.

ÌÖåÏä§Ìä∏ ÏΩîÎìúÎ•º ÏûëÏÑ±Ìï†Îïå Ìïú Í∞ÄÏßÄ Ïú†ÎÖêÌï¥Ïïº ÌïúÎã§Í≥† ÏÉùÍ∞ÅÌïú Í≤ÉÏùÄ ÌÖåÏä§Ìä∏ ÎåÄÏÉÅÏù¥ ÌòÑÏû¨ ÏûêÏã†Ïù¥ ÌÖåÏä§Ìä∏ Ïó¨Î∂ÄÏù∏ÏßÄÎ•º Ïù∏ÏßÄÌïòÎ©¥ ÏïàÎêúÎã§Îäî Í≤ÉÏù¥Îã§. ÏΩîÎìúÎ•º Ïù¥Îü¨Ìïú Î∞©Ìñ•ÏÑ±ÏúºÎ°ú ÏûëÏÑ±ÌïòÍ≤å ÎêòÎ©¥ `let isTest: Bool`Í≥º Í∞ôÏù¥ ÌÖåÏä§Ìä∏ Ïó¨Î∂ÄÎ•º ÏÉÅÌÉúÍ∞íÏúºÎ°ú Ï∂îÍ∞ÄÌïòÏó¨ Í¥ÄÎ¶¨ÌïòÍ≤å ÎêòÍ≥†, Ïù¥Ïóê Îî∞Îùº ÎèôÏùºÌïú Î∑∞Î™®Îç∏ ÌòπÏùÄ Î∑∞Ïª®Ìä∏Î°§Îü¨ ÎÇ¥ÏóêÏÑú Î≥µÏû°ÏÑ±ÏùÑ Í∞ÄÏßÄÍ≥† ÏΩîÎìúÎ•º ÏûëÏÑ±ÌïòÍ≤å ÎêúÎã§.

Îî∞ÎùºÏÑú ÏµúÎåÄÌïúÏúºÎ°ú ÌÖåÏä§Ìä∏ Ïó¨Î∂ÄÎ•º ÌåêÎã®Ìï† Ïàò ÏûàÎäî ÎßàÏßÄÎÖ∏ÏÑ†ÏùÑ ÌÖåÏä§Ìä∏ ÎåÄÏÉÅ Í∞ùÏ≤¥Í∞Ä ÏÉùÏÑ±ÎêòÎäî ÏãúÏ†êÏóê ÌäπÏ†ï Í∞ùÏ≤¥Î•º Ï£ºÏûÖÌïòÎäî Í≤É Ïù¥ÏÉÅÏúºÎ°ú ÏΩîÎìúÏùò Î≥ÄÍ≤ΩÏù¥ ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú Ïù¥Î£®Ïñ¥ÏßÄÎ©¥ ÏïàÎêúÎã§. ÏòàÏª®ÎåÄ Î™©ÏóÖ URL ÌîÑÎ°úÌÜ†ÏΩúÏùÑ ÏÇ¨Ïö©Ìï†Îïå **Î∑∞Î™®Îç∏Ïóê Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩú ÌÅ¥ÎûòÏä§Í∞Ä ÏßÄÏ†ïÎêú ÏÑ∏ÏÖò Í∞ùÏ≤¥Î•º Ï£ºÏûÖÌï¥Ï£ºÎäî Í≤É Ïô∏Ïóê Î∑∞Î™®Îç∏ ÌÅ¥ÎûòÏä§ ÎÇ¥Î∂Ä Î≥ÄÍ≤ΩÏÇ¨Ìï≠Ïù¥ ÏûàÏßÄÎäî ÏïäÏïòÎã§.**

Ïù¥Îü¨Ìïú Ï†êÏóêÏÑú Ï∂úÎ∞úÌïòÏó¨, 2Î≤à Í≥ºÏ†ïÏóêÏÑú Ïù¥ÎØ∏ÏßÄ URL Ï∂îÏ∂ú ÌõÑ ÏßÅÏ†ë Îã§Ïö¥Î°úÎìúÌïòÎäî Í≥ºÏ†ïÏùÑ ÌÖåÏä§Ìä∏ÏΩîÎìúÎ°ú ÏûëÏÑ±Ìï† ÎïåÏóê ÌòÑÏû¨ Î∑∞Î™®Îç∏Ïù¥ ÌÖåÏä§Ìä∏ Ïó¨Î∂ÄÏù∏ÏßÄ ÏÉÅÌÉúÍ∞íÏùÑ Ï∂îÍ∞ÄÌïòÏó¨ ÏΩîÎìúÎ•º ÏûëÏÑ±ÌïòÎ©¥ `retrieveCacheObservable` Ìï®ÏàòÏóêÏÑú Í∞ÄÏßú Í∞ùÏ≤¥Î•º Î¶¨ÌÑ¥ÌïòÎäî Î∞©ÏãùÏúºÎ°ú ÏΩîÎìú ÏûëÏÑ±Ïù¥ Í∞ÄÎä•ÏùÄ ÌïòÏßÄÎßå ÏÇ¨Ïã§ÏÉÅÏùò ÌÖåÏä§Ìä∏ ÏΩîÎìú ÏûëÏÑ±Ïùò ÏùòÎØ∏Í∞Ä ÎßéÏù¥ Ìá¥ÏÉâÎêúÎã§Îäî Í≤ÉÏùÑ Ïïå Ïàò ÏûàÎã§.

ÏúÑ Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌïòÍ∏∞ ÏúÑÌïú ÏÇ¨Í≥†Ïùò ÌùêÎ¶ÑÏùÄ Îã§ÏùåÍ≥º Í∞ôÏïòÎã§.

1. `setUp` ÎùºÏù¥ÌîÑÏÇ¨Ïù¥ÌÅ¥ÏóêÏÑú Ï∫êÏãú Ï†ÄÏû•ÏÜåÎ•º ÏôÑÏ†ÑÌûà ÎπÑÏö¥Îã§.
2. 1Î≤à Í≥ºÏ†ïÏóê Îî∞Îùº Î™©ÏóÖ ÎÑ§Ìä∏ÏõåÌÇπÏùÑ ÌÜµÌï¥ Ï†ÑÎã¨Î∞õÏùÄ JSON ÎîîÏΩîÎî© Í∞ùÏ≤¥Ïùò Ïù¥ÎØ∏ÏßÄ URLÏùÑ ÌÇ§Í∞íÏúºÎ°ú Ìï†Îïå Ïù¥Ïóê ÎåÄÏùëÎêòÎäî Î∞∏Î•òÏùò Ïù¥ÎØ∏ÏßÄ Í∞ùÏ≤¥Îäî Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÏÉÅÌÉúÏù¥Îã§.
3. Î™®Îì† Ïù¥ÎØ∏ÏßÄ URLÏùÄ ÎÑ§Ìä∏ÏõåÌÇπÏùÑ ÌÜµÌï¥ Îã§Ïö¥Î°úÎìúÎ•º ÏßÑÌñâÌï¥Ïïº ÌïúÎã§.
4. ÌÇπÌîºÏÖî ÎùºÏù¥Î∏åÎü¨Î¶¨ ÎÇ¥Ïóê Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩúÏùÑ Ï£ºÏûÖÌïòÏó¨ Ïù¥ÎØ∏ÏßÄÍ∞Ä Ïã§Ï†ú Îã§Ïö¥Î°úÎìú ÎêúÍ≤É Ï≤òÎüº Ìï† Ïàò ÏûàÎÇò?

4Î≤à Í≥ºÏ†ïÏóê ÌÖåÏä§Ìä∏ ÏΩîÎìú ÏûëÏÑ±Ïóê ÌïµÏã¨Ïù¥ ÎêòÎäî Î∂ÄÎ∂ÑÏù¥ÏóàÎäîÎç∞, Í≤∞Íµ≠ ÌÇπÌîºÏÖîÏóêÏÑúÎèÑ URL Í∞ùÏ≤¥Î•º ÌÜµÌïú Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎìú Í≥ºÏ†ïÎèÑ ÏΩîÎìú Ï∂îÏÉÅÌôî Îã®Í≥ÑÎ•º ÎÑòÏñ¥ Î°úÏö∞Ìïú Îã®Í≥ÑÎ°ú ÎÑòÏñ¥Í∞ÄÍ≤å ÎêòÎ©¥ JSON Îç∞Ïù¥ÌÑ∞Î•º ÏöîÏ≤≠ÌïòÎäî Í≤ÉÍ≥º Ïú†ÏÇ¨Ìïú Î∞©Î≤ïÏúºÎ°ú Î°úÏª¨ ÎÇ¥Ïóê Îì±Î°ùÎêú Í∞ÄÏßú Ïù¥ÎØ∏ÏßÄÎ•º ÎÑòÍ≤®Ï£ºÎäî Î∞©ÏãùÏúºÎ°ú ÎèôÏûëÌïòÎèÑÎ°ù ÎßåÎì§ Ïàò ÏûàÏóàÎã§Îäî Í≤ÉÏù¥Îã§.

ÏúÑÏùò `retrieveCacheObservable` Ìï®ÏàòÎ•º Î≥¥Î©¥ `imageKey`Í∞íÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Ï∫êÏãúÏóê Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Í≤ΩÏö∞ URL Í∞ùÏ≤¥Î•º ÏÉùÏÑ±ÌïòÏó¨ ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠ÏúºÎ°ú ÎÑòÏñ¥Í∞ÄÎäî Îã®Í≥ÑÍ∞Ä ÏûàÎã§.

```swift
guard let url = URL(string: posepick.poseInfo.imageKey) else { return }
KingfisherManager.shared.retrieveImage(with: url) { downloadResult in
    switch downloadResult {
    case .success(let downloadImage):
        let viewModel = CellViewModel(image: downloadImage.image, poseId: posepick.poseInfo.poseId)
        viewModelObservable.accept(viewModelObservable.value + [viewModel])
    case .failure:
        return
    }
}
```

Ïù¥Îïå `KingfisherManager.shared.retrieveImage` Î©îÏÑúÎìúÏóê Îã§ÏñëÌïú ÌååÎùºÎØ∏ÌÑ∞Î•º ÌôúÏö©Ìï† Ïàò ÏûàÎäîÎç∞, Í∑∏ Ï§ë `options` ÌååÎùºÎØ∏ÌÑ∞ ÌÉÄÏûÖÏùÑ ÏÇ¥Ìé¥Î≥¥Ïûê. ÌååÎùºÎØ∏ÌÑ∞ ÌÉÄÏûÖÏùÄ `KingfisherOptionsInfoItem`Ïù∏Îç∞ ÎÇ¥Î∂ÄÏóê ÏÉÅÎãπÌûà ÎßéÏùÄ ÏòµÏÖòÎì§Ïù¥ Ïó¥Í±∞ÌòïÏúºÎ°ú ÏßÄÏ†ïÎêòÏñ¥ ÏûàÎäî Í≤ÉÏùÑ Î≥º Ïàò ÏûàÎã§. Í∑∏ Ï§ë Ïö∞Î¶¨Í∞Ä ÏÇ¥Ìé¥Î≥º ÏºÄÏù¥Ïä§Îäî `downloader` ÏºÄÏù¥Ïä§Ïù¥Îã§.

```swift
public enum KingfisherOptionsInfoItem {

    /// Kingfisher will use the associated `ImageCache` object when handling related operations,
    /// including trying to retrieve the cached images and store the downloaded image to it.
    case targetCache(ImageCache)

    /// The `ImageCache` for storing and retrieving original images. If `originalCache` is
    /// contained in the options, it will be preferred for storing and retrieving original images.
    /// If there is no `.originalCache` in the options, `.targetCache` will be used to store original images.
    ///
    /// When using KingfisherManager to download and store an image, if `cacheOriginalImage` is
    /// applied in the option, the original image will be stored to this `originalCache`. At the
    /// same time, if a requested final image (with processor applied) cannot be found in `targetCache`,
    /// Kingfisher will try to search the original image to check whether it is already there. If found,
    /// it will be used and applied with the given processor. It is an optimization for not downloading
    /// the same image for multiple times.
    case originalCache(ImageCache)

    /// Kingfisher will use the associated `ImageDownloader` object to download the requested images.
    case downloader(ImageDownloader)

    /// ....
    /// ....
}
```

Îã§Ïö¥Î°úÎçî ÏòµÏÖòÏùò ÏÑ§Î™ÖÏùÑ Î≥¥Î©¥ `Kingfisher will use the associated ImageDownloader object to download the requested images.`ÎùºÍ≥† ÎêòÏñ¥ ÏûàÎã§. ÏöîÏ≤≠ÌïòÎäî Ïù¥ÎØ∏ÏßÄÏóê ÎåÄÌï¥ Îã§Ïö¥Î°úÎìúÎ•º Ïó∞Í¥ÄÍ∞íÏúºÎ°ú ÏßÄÏ†ïÎêú `ImageDownloader` Í∞ùÏ≤¥Î•º ÌÜµÌï¥ ÏßÄÏ†ïÌïòÍ≤†Îã§Îäî ÏùòÎØ∏Ïù¥Îã§.

`ImageDownloader` Í∞ùÏ≤¥Î•º ÏÇ¥Ìé¥Î≥¥Î©¥ ÎòêÌïú ÎèôÏùºÌïòÍ≤å ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú Îã§ÏñëÌïú ÏÜçÏÑ±Îì§Ïù¥ Ï°¥Ïû¨ÌïúÎã§.

```swift
open class ImageDownloader {

    // MARK: Singleton
    /// The default downloader.
    public static let `default` = ImageDownloader(name: "default")

    // MARK: Public Properties
    /// The duration before the downloading is timeout. Default is 15 seconds.
    open var downloadTimeout: TimeInterval = 15.0

    /// A set of trusted hosts when receiving server trust challenges. A challenge with host name contained in this
    /// set will be ignored. You can use this set to specify the self-signed site. It only will be used if you don't
    /// specify the `authenticationChallengeResponder`.
    ///
    /// If `authenticationChallengeResponder` is set, this property will be ignored and the implementation of
    /// `authenticationChallengeResponder` will be used instead.
    open var trustedHosts: Set<String>?

    /// Use this to set supply a configuration for the downloader. By default,
    /// NSURLSessionConfiguration.ephemeralSessionConfiguration() will be used.
    ///
    /// You could change the configuration before a downloading task starts.
    /// A configuration without persistent storage for caches is requested for downloader working correctly.
    open var sessionConfiguration = URLSessionConfiguration.ephemeral {
        didSet {
            session.invalidateAndCancel()
            session = URLSession(configuration: sessionConfiguration, delegate: sessionDelegate, delegateQueue: nil)
        }
    }

    /// ...
    /// ...
}
```

Ïù¥Ï§ë ÎààÏó¨Í≤® Î≥º Î∂ÄÎ∂ÑÏùÄ Î∞îÎ°ú `sessionConfiguration`Ïù¥Îã§. `You could change the configuration before a downloading task starts.`ÎùºÎäî ÏÑ§Î™ÖÏúºÎ°ú ÎØ∏Î£®Ïñ¥ Î≥¥ÏïÑ Ïù¥ÎØ∏ÏßÄ Í∞ùÏ≤¥ Îã§Ïö¥Î°úÎìúÎ•º ÏßÑÌñâÌïòÍ∏∞ Ï†Ñ ÏÑ∏ÏÖò Í∞ùÏ≤¥Î•º ÏßÅÏ†ë Ï£ºÏûÖÌï¥Ï§Ñ Ïàò ÏûàÏùåÏùÑ Ïïå Ïàò ÏûàÎã§.

JSON Îç∞Ïù¥ÌÑ∞Î•º Ï£ºÍ≥†Î∞õÏùÑÎïå ÏöîÏ≤≠ÏùÑ ÏãúÏûëÌïòÍ∏∞ Ï†Ñ ÏÑ∏ÏÖò Í∞ùÏ≤¥Ïùò `Configuration` ÏÜçÏÑ±Ïóê Ï†ëÍ∑ºÌïú Îí§ `protocolClasses`Î•º Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩúÎ°ú ÏßÄÏ†ïÌï¥Ï§¨Îçò Í≤ÉÍ≥º ÎßàÏ∞¨Í∞ÄÏßÄÎ°ú ÌÖåÏä§Ìä∏ÏΩîÎìú ÏÖãÏóÖ Îã®Í≥ÑÏóêÏÑú `ImageDownloader` Í∞ùÏ≤¥Î•º ÏÉùÏÑ±ÌïòÎêò `protocolClasses`Î•º Ïù¥ÎØ∏ÏßÄ URLÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Î™©ÏóÖ Îç∞Ïù¥ÌÑ∞Î•º ÎøåÎ†§Ï£ºÎäî ÌîÑÎ°úÌÜ†ÏΩúÎ°ú ÏßÄÏ†ïÌïòÎ©¥ ÎêòÎäî Í≤ÉÏù¥Îã§.

Ïù¥Îü¨Ìïú ÎÖºÎ¶¨ Íµ¨Ï°∞Î•º Í∏∞Î∞òÏúºÎ°ú ÌïòÏó¨ ÏûëÏÑ±Ìïú Î™©ÏóÖ Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎìú ÌîÑÎ°úÌÜ†ÏΩúÏùÄ Îã§ÏùåÍ≥º Í∞ôÎã§.

:::details MockImageDownloaderIURLProtocol ÏΩîÎìú Ï†ÑÎ¨∏ ÌéºÏ≥êÎ≥¥Í∏∞

```swift
import Foundation

final class MockImageDownloaderIURLProtocol: URLProtocol {

    private lazy var session: URLSession = {
        let configuration: URLSessionConfiguration = URLSessionConfiguration.default
        return URLSession(configuration: configuration)
    }()

    enum ResponseType {
        case error(APIError)
        case success(HTTPURLResponse)
    }

    static var responseType: ResponseType!
    static var dtoType: MockDTOType!
}

extension MockImageDownloaderIURLProtocol {

    static func responseWithFailure() {
        MockImageDownloaderIURLProtocol.responseType = MockImageDownloaderIURLProtocol.ResponseType.error(APIError.unknown)
    }

    static func responseWithStatusCode(code: Int) {
        MockImageDownloaderIURLProtocol.responseType = MockImageDownloaderIURLProtocol.ResponseType.success(HTTPURLResponse(url: URL(string: K.baseUrl)!, statusCode: code, httpVersion: nil, headerFields: nil)!)
    }

    static func responseWithDTO(type: MockDTOType) {
        MockImageDownloaderIURLProtocol.dtoType = type
    }
}


extension MockImageDownloaderIURLProtocol {

    enum MockDTOType {
        case empty
        case cacheImage

        var fileName: String {
            switch self {
            case .empty: return ""
            case .cacheImage: return "image.jpeg"
            }
        }
    }

    override class func canInit(with request: URLRequest) -> Bool {
        return true
    }

    override class func canonicalRequest(for request: URLRequest) -> URLRequest {
        return request
    }

    override func startLoading() {
        let response = setUpMockResponse()
        let data = setUpMockData()

        client?.urlProtocol(self, didReceive: response!, cacheStoragePolicy: .notAllowed)

        client?.urlProtocol(self, didLoad: data!)

        self.client?.urlProtocolDidFinishLoading(self)
    }

    private func setUpMockResponse() -> HTTPURLResponse? {
        var response: HTTPURLResponse?
        switch MockImageDownloaderIURLProtocol.responseType {
        case .error(let error)?:
            client?.urlProtocol(self, didFailWithError: error)
        case .success(let newResponse)?:
            response = newResponse
        default:
            fatalError("No fake responses found.")
        }
        return response!
    }

    private func setUpMockData() -> Data? {
        let fileName: String = MockImageDownloaderIURLProtocol.dtoType.fileName
       // Î≤àÎì§Ïóê ÏûàÎäî json ÌååÏùºÎ°ú Data Í∞ùÏ≤¥Î•º ÎΩëÏïÑÎÇ¥Îäî Í≥ºÏ†ï.
        guard let file = Bundle.main.url(forResource: fileName, withExtension: nil) else {
            return Data()
        }
        return try? Data(contentsOf: file)
    }

    override func stopLoading() {
    }
}
```

:::

`MockDTOType` Ïó¥Í±∞Ìòï Î≥ÄÍ≤Ω Ïô∏ÏóêÎäî Í∏∞Ï°¥ ÏΩîÎìúÏóêÏÑú Îã¨ÎùºÏßÄÎäî Ï†êÏùÄ ÏóÜÎã§.

:::tip Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩúÏùÑ Í∞ÅÍ∞Å ÏßÄÏ†ïÌïú Ïù¥Ïú†?

Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎìú Î™©ÏóÖ ÎÑ§Ìä∏ÏõåÌÅ¨ ÌîÑÎ°úÌÜ†ÏΩúÍ≥º ÏùºÎ∞ò ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÜµÏã† Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩúÏùÑ Í∞ÅÏûê ÏßÄÏ†ïÌïú Ïù¥Ïú†Îäî **ÎèôÏùºÌïú ÌÖåÏä§Ìä∏ ÏºÄÏù¥Ïä§ÏóêÏÑú ÏÑúÎ°ú Îã§Î•∏ ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠Ïù¥ Î≥ëÎ†¨Ï†ÅÏúºÎ°ú Ïù¥Î£®Ïñ¥ÏßÄÍ∏∞ ÎïåÎ¨∏Ïù¥Îã§.** ÌÖåÏä§Ìä∏ ÏΩîÎìú ÏûëÏÑ±Ïãú `responseWithDTO`, `responseWithStatusCode`Î•º ÌÜµÌï¥ Í∞ÄÏßú ÏùëÎãµÏóê ÎåÄÌïú Ï†ïÏùòÎ•º ÎØ∏Î¶¨ Í≤∞Ï†ïÌï¥ÎëêÍ≥† ÏãúÏûëÌïòÎäîÎç∞ Ïù¥Îü¨Ìïú Î∂ÄÎ∂ÑÏù¥ **ÌÉÄÏûÖ ÏÜçÏÑ±(static property)ÏùÑ** Í∏∞Î∞òÏúºÎ°ú Ïù¥Î£®Ïñ¥ÏßÄÍ∏∞ ÎïåÎ¨∏Ïóê ÌïòÎÇòÏùò ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠Ïóê ÎåÄÌï¥ `responseWithStatusCode`Í∞íÏùÄ ÎèôÏùºÌï† Ïàò ÏûàÏñ¥ÎèÑ `responseWithDTO`Îäî Îã¨ÎùºÏßà Ïàò ÏûàÎã§.

:::

## ÌÖåÏä§Ìä∏ ÏΩîÎìú ÏûëÏÑ±

ÏûëÏÑ±Ìïú ÌÖåÏä§Ìä∏ ÏΩîÎìúÎ•º ÏÇ¥Ìé¥Î≥¥Ïûê. `setUp`Î∂ÄÌÑ∞ Î≥¥Î©¥ Îã§ÏùåÍ≥º Í∞ôÏù¥ ÏΩîÎìúÎ•º ÏûëÏÑ±Ìï† Ïàò ÏûàÎã§.

```swift
final class bookmarkTests: XCTestCase {
    var disposeBag: DisposeBag!
    var sut: APISession!
    var scheduler: TestScheduler!
    var viewModel: BookMarkViewModel!

    override func setUp() {
        super.setUp()
        let session: Session = {
            let configuration: URLSessionConfiguration = {
                let configuration = URLSessionConfiguration.default
                configuration.protocolClasses = [MockURLProtocol.self]
                return configuration
            }()
            return Session(configuration: configuration)
        }()

        let imageDownloader: ImageDownloader = {
            let downloader = ImageDownloader.default
            let configuration = URLSessionConfiguration.default
            configuration.protocolClasses = [MockImageDownloaderIURLProtocol.self]
            downloader.sessionConfiguration = configuration
            return downloader
        }()

        sut = APISession(session: session)
        disposeBag = DisposeBag()
        scheduler = TestScheduler(initialClock: 0)
        viewModel = BookMarkViewModel(apiSession: sut, imageDownloader: imageDownloader) // Î™©ÏóÖ ÏÑ∏ÏÖò Ï£ºÏûÖ
        ImageCache.default.clearCache() // Ï∫êÏãú ÎπÑÏö∞Í∏∞
    }
}
```

Ï§ëÍ∞ÑÏùò `ImageDownloader` Í∞ùÏ≤¥Î•º ÏÉùÏÑ±ÌïòÎäî Í≥ºÏ†ïÏóêÏÑú ÏÑ∏ÏÖò `configuration` ÏÜçÏÑ±Ïóê Ï†ëÍ∑ºÌïòÏó¨ Î™©ÏóÖ Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎìú ÌîÑÎ°úÌÜ†ÏΩúÏùÑ ÏßÅÏ†ë ÏßÄÏ†ïÌï¥Ï£ºÎäî Î∂ÄÎ∂ÑÏùÑ Î≥º Ïàò ÏûàÎã§. Ïù¥ÌõÑ Î∑∞Î™®Îç∏ Í∞ùÏ≤¥ ÏÉùÏÑ±Ïãú Îã§Ïö¥Î°úÎçî Í∞ùÏ≤¥Î•º Ï£ºÏûÖÌï¥Ï§åÏúºÎ°úÏç® Î∑∞Î™®Îç∏ÏóêÏÑú `retrieveCacheObservable`ÏùÑ Ìò∏Ï∂úÌï†Îïå ÏûêÏã† Í∞ùÏ≤¥Ïùò Îã§Ïö¥Î°úÎçî Í∞ùÏ≤¥Î•º Ï∞∏Ï°∞ÌïòÎ©¥ **Ïô∏Î∂ÄÏóêÏÑú Îã§Ïö¥Î°úÎçîÍ∞Ä Ï£ºÏûÖÎêú ÏÉÅÌÉúÏùºÎïåÎäî Ìï¥Îãπ Í∞ùÏ≤¥Î•º ÏÇ¨Ïö©ÌïòÍ≥†, Í∑∏Î†áÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ ÌÇπÌîºÏÖîÏùò ÎîîÌè¥Ìä∏ Îã§Ïö¥Î°úÎçîÎ•º ÏÇ¨Ïö©ÌïòÍ≤å ÎêòÎäî Í≤ÉÏù¥Îã§.**

Î∑∞Î™®Îç∏ ÌÅ¥ÎûòÏä§Ïùò Ïù¥ÎãàÏÖúÎùºÏù¥Ï†ÄÎ•º Ïû†Íπê ÏÇ¥Ìé¥Î≥¥Í≥† Îã§Ïãú Ïò§Ïûê.

```swift
class BookMarkViewModel {

    var apiSession: APISession
    var disposeBag = DisposeBag()
    var imageDownloader: ImageDownloader

    init(apiSession: APISession = APISession(), imageDownloader: ImageDownloader = ImageDownloader.default) {
        self.apiSession = apiSession
        self.imageDownloader = imageDownloader
    }

    // ...
}
```

ÏúÑ ÏΩîÎìúÎ•º Î≥¥Î©¥ Ïù¥ÎãàÏÖúÎùºÏù¥Ï†ÄÏóê ÎîîÌè¥Ìä∏Í∞íÏúºÎ°ú `ImageDownloader.default`Í∞íÏùÑ ÎëêÍ≥† ÏÜçÏÑ±Í∞íÏùÑ Ï¥àÍ∏∞ÌôîÌï¥Ï£ºÎäî Í≤ÉÏùÑ Î≥º Ïàò ÏûàÎã§.

Îã§Ïãú ÌÖåÏä§Ìä∏ÏΩîÎìúÎ°ú ÎÑòÏñ¥ÏôÄÏÑú, `setUp`Ïù¥ÌõÑ Î≥∏Í≤©Ï†ÅÏù∏ ÌÖåÏä§Ìä∏ ÏΩîÎìúÎ•º ÏûëÏÑ±Ìï¥Î≥¥Ïûê.

```swift
func test_Îç∞Ïù¥ÌÑ∞Í∞Ä_ÏóÜÏùÑÎïå_emptyÎ∑∞Î•º_ÎùÑÏõåÏ£ºÎäîÏßÄ() {

    MockURLProtocol.responseWithStatusCode(code: 200)
    MockURLProtocol.responseWithDTO(type: .bookmarkFeed)

    MockImageDownloaderIURLProtocol.responseWithStatusCode(code: 200)
    MockImageDownloaderIURLProtocol.responseWithDTO(type: .cacheImage)

    var input = retrieveDefaultInputObservable()

    input.viewDidLoadTrigger = scheduler.createColdObservable([
        .next(1, ())
    ]).asObservable()

    let output = viewModel.transform(input: input)
    let expectation = XCTestExpectation(description: "Î∂ÅÎßàÌÅ¨ API ÌÖåÏä§Ìä∏")

    scheduler.start()

    // ÎÑ§Ìä∏ÏõåÌÅ¨Ïóê ÏùòÏ°¥Ï§ë..
    output.bookmarkItems
        .compactMap { $0 }
        .drive(onNext: {
            $0.forEach { element in
                print(element.image.value)
                print(element.poseId.value)
            }
            expectation.fulfill()
        })
        .disposed(by: disposeBag)

    wait(for: [expectation], timeout: 5)
}
```

1. JSON Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠Í≥º ÎçîÎ∂àÏñ¥ Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎìú Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩúÏóê ÎåÄÌïú ÏùëÎãµ ÌòïÌÉúÎ•º ÏßÄÏ†ïÌïúÎã§.
2. Ïù∏Ìíã Í∞ùÏ≤¥Î•º ÏñªÍ≥† Ïä§ÏºÄÏ§ÑÎü¨Î•º ÌÜµÌï¥ Ìä∏Î¶¨Í±∞ ÏòµÏ†ÄÎ≤ÑÎ∏îÏùÑ ÎèôÏûëÏãúÌÇ®Îã§.
3. ÏïÑÏõÉÌíã transform Í∞ùÏ≤¥ Î∞è `XCTestExpectation` Í∞ùÏ≤¥Î•º Ï†ïÏùòÌïúÎã§.
4. Ïä§ÏºÄÏ§ÑÎü¨Î•º ÏãúÏûëÌïúÎã§.
5. Î∑∞Î™®Îç∏ ÎÇ¥ÏóêÏÑú Ï†ïÏùòÎêú Ïù∏Ìíã Ìä∏ÎûúÏä§Ìèº Î°úÏßÅÏóê Îî∞Îùº ÏïÑÏõÉÌíã Í∞ùÏ≤¥Îì§ÏùÑ ÏñªÏñ¥ÎÇ∏Îã§.
6. ÌÜµÏã†ÏùÑ ÎßàÏπòÍ≥† `fulfill` Ìò∏Ï∂úÏùÑ ÌÜµÌï¥ ÌÖåÏä§Ìä∏Î•º ÎßàÏπúÎã§.

ÏúÑÏùò `output.bookmarkItems` ÏΩîÎìúÏóê ÎåÄÌïú Ïù¥Ìï¥Î•º ÏúÑÌï¥ Ïû†Ïãú Î∑∞Î™®Îç∏ `transform` Ìï®ÏàòÎ°ú Îã§Ïãú Ïù¥ÎèôÌï¥Î≥¥Ïûê.

```swift
func transform(input: Input) -> Output {
    let bookmarkItems = BehaviorRelay<[BookmarkFeedCellViewModel]?>(value: nil)

    /// 1. Î∑∞ Î°úÎìú Ïù¥ÌõÑ Ïª¨Î†âÏÖòÎ∑∞ ÏÖÄ ÏïÑÏù¥ÌÖú API ÏöîÏ≤≠
    input.viewDidLoadTrigger
        .flatMapLatest { [unowned self] _ -> Observable<PoseFeed> in
            return apiSession.requestSingle(.retrieveBookmarkFeed(userId: 0, pageNumber: 0, pageSize: 8)).asObservable()
        }
        .map { $0.content }
        .flatMapLatest { [unowned self] posefeed -> Observable<[BookmarkFeedCellViewModel]> in
            return retrieveCacheObservable(posefeed: posefeed)
        }
        .subscribe(onNext: {
            bookmarkItems.accept($0)
        })
        .disposed(by: disposeBag)

    return Output(bookmarkItems: bookmarkItems.asDriver())
}
```

Ïª¨Î†âÏÖòÎ∑∞ ÏÖÄÏóê Î∞îÏù∏Îî©Ìï† ÏÖÄ Î∑∞Î™®Îç∏ Í∞ùÏ≤¥Îì§ÏùÑ Ï∞çÏñ¥ÎÇ¥Îäî Í≥ºÏ†ïÏù∏Îç∞, Ïù∏Ìíã Ìä∏Î¶¨Í±∞ Ïù¥ÌõÑ `requestSingle`ÏóêÏÑú 1Ï∞®Ï†ÅÏúºÎ°ú Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩú Í∏∞Î∞òÏúºÎ°ú ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÜµÏã†Ïù¥ Ïù¥Î£®Ïñ¥ÏßÄÍ≥† `retrieveCacheObservable`ÏóêÏÑú Ïù¥ÎØ∏ÏßÄ `downloadTask`Ïóê Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎìú Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩú Í∏∞Î∞òÏúºÎ°ú ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÜµÏã†Ïù¥ Ïù¥Î£®Ïñ¥ÏßÑÎã§.

Ïù¥Îïå Ìò∏Ï∂úÎêòÎäî `retrieveCacheObservable` Ìï®ÏàòÎ•º Îã§Ïãú ÏÇ¥Ìé¥Î≥¥Î©¥ Îã§ÏùåÍ≥º Í∞ôÎã§. Ïö∞ÏÑ† Î∑∞Î™®Îç∏ ÎÇ¥ÏóêÏÑú Ïù¥ÎãàÏÖúÎùºÏù¥Ï†ÄÎ•º ÌÜµÌï¥ `ImageDownloader` Í∞ùÏ≤¥Î•º Ï†ïÏùòÌï¥ÎëêÏóàÏùåÏùÑ Í∏∞ÏñµÌïòÍ≥† ÏïÑÎûò ÏΩîÎìúÎ•º ÏÇ¥Ìé¥Î≥¥Ïûê.

```swift
func retrieveCacheObservable(posefeed: [PosePick]) -> Observable<[CellViewModel]> {

    let viewModelObservable = BehaviorRelay<[CellViewModel]>(value: [])

    posefeed.forEach { posepick in
        ImageCache.default.retrieveImage(forKey: posepick.poseInfo.imageKey, options: nil) { [weak self] result in
            guard let self = self else { return }
            switch result {
            case .success(let value):
                if let image = value.image {
                    let viewModel = CellViewModel(image: image, poseId: posepick.poseInfo.poseId)
                    viewModelObservable.accept(viewModelObservable.value + [viewModel])
                } else {
                    guard let url = URL(string: posepick.poseInfo.imageKey) else { return }

                    // Ï£ºÏûÖÎêú Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎçîÎ•º Ï†ÑÎã¨!
                    KingfisherManager.shared.retrieveImage(with: url, options: [.downloader(self.imageDownloader)]) { downloadResult in
                        switch downloadResult {
                        case .success(let downloadImage):
                            let viewModel = CellViewModel(image: downloadImage.image, poseId: posepick.poseInfo.poseId)
                            viewModelObservable.accept(viewModelObservable.value + [viewModel])
                        case .failure:
                            return
                        }
                    }
                }
            case .failure:
                return
            }
        }
    }
    return viewModelObservable.asObservable().skip(while: { $0.count < posefeed.count })
}
```

Ï§ëÍ∞ÑÏóê Î≥¥Î©¥ `KingfisherManager.shared.retrieveImage(with: url, options: [.downloader(self.imageDownloader)])` ÏΩîÎìúÍ∞Ä ÏûëÏÑ±Îêú Í≤ÉÏùÑ Î≥º Ïàò ÏûàÎã§.

Î∑∞Î™®Îç∏Ïóê Ï£ºÏûÖÎêú Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎçî Í∞ùÏ≤¥Î•º ÏòµÏÖòÏóê Ï†ÑÎã¨Ìï®ÏúºÎ°úÏç® Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩúÎ°ú ÏÑ∏ÌåÖÎêú Îã§Ïö¥Î°úÎìúÎ•º ÏßÑÌñâÌï† Ïàò ÏûàÍ≤å ÎêòÎäî Í≤ÉÏù¥Îã§.

## ÌÖåÏä§Ìä∏ Ïã§Ìñâ Í≤∞Í≥º

Í∑∏Î†áÎã§Î©¥ Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩúÎ°ú Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎìúÍ∞Ä ÏßÑÌñâÎêú Í≤ÉÏùÑ Ïñ¥ÎñªÍ≤å Í≤ÄÏ¶ùÌïòÎäîÍ∞Ä? Î∏åÎ†àÏù¥ÌÅ¨ Ìè¨Ïù∏Ìä∏ ÏÑ§Ï†ïÏùÑ ÌÜµÌï¥ ÌòÑÏû¨ Ï∞∏Ï°∞ÌïòÍ≥† ÏûàÎäî `UIImage` Í∞ùÏ≤¥Î•º ÏßÅÏ†ë ÎØ∏Î¶¨Î≥º Ïàò ÏûàÎäî Í∏∞Îä•ÏùÑ xcodeÏóêÏÑú Ï†úÍ≥µÌïúÎã§. Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩúÏù¥ ÏÉùÏÑ±Îêú Í≤ΩÏö∞ÏôÄ Í∑∏Î†áÏßÄ ÏïäÏùÄ Í≤ΩÏö∞Ïóê ÎåÄÌï¥ xcodeÏóêÏÑú Í≤∞Í≥ºÍ∞Ä Ïñ¥ÎñªÍ≤å Îã¨ÎùºÏßÄÎäîÏßÄ ÌôïÏù∏Ìï¥Î≥¥Ïûê.

![39-2](../.vuepress/assets/snack/39-2.gif)

ÏúÑ ÌôîÎ©¥ÏùÄ Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩúÏùÑ Í±∞Ï≥ê ÏñªÏñ¥Ïò® JSON Í∞ùÏ≤¥ÏóêÏÑú Í∞Å Ïù¥ÎØ∏ÏßÄ URLÏóê Ï†ëÍ∑º ÌõÑ Îã§Ïö¥Î°úÎìúÌïú Ïù¥ÎØ∏ÏßÄÎì§ÏùÑ xcode Î∏åÎ†àÏù¥ÌÅ¨ Ìè¨Ïù∏Ìä∏ ÏÑ§Ï†ïÏùÑ ÌÜµÌï¥ ÌîÑÎ¶¨Î∑∞ÌïòÎäî Î™®ÏäµÏù¥Îã§. ÌîÑÎ¶¨Î∑∞ÌïòÎäî Í≥ºÏ†ïÏóêÏÑú Ïù¥ÎØ∏ÏßÄÍ∞Ä Í≥ÑÏÜç Îã¨ÎùºÏßÄÎäî Í≤ÉÏùÑ Î≥º Ïàò ÏûàÎäîÎç∞, Ïù¥Îäî Í∞Å JSONÏúºÎ°úÎ∂ÄÌÑ∞ Ï∂îÏ∂úÌïú Ïù¥ÎØ∏ÏßÄ URLÎßàÎã§ ÏÉàÎ°ú Ïù¥ÎØ∏ÏßÄÎì§ÏùÑ Îã§Ïö¥Î°úÎìú ÌïòÍ≥† ÏûàÍ∏∞ ÎïåÎ¨∏Ïù¥Îã§.

![39-3](../.vuepress/assets/snack/39-3.gif)

ÏúÑ ÌôîÎ©¥ÏùÑ Îã§Ïãú Î≥¥Î©¥, Í≥†ÏñëÏù¥ ÏÇ¨ÏßÑÏúºÎ°ú ÏùºÍ¥ÄÎêòÍ≤å ÌîÑÎ¶¨Î∑∞Ïóê ÌëúÏãúÎêòÎäî Í≤ÉÏùÑ Î≥º Ïàò ÏûàÎäîÎç∞ Ïù¥Îäî `ImageDownloader` Í∞ùÏ≤¥ÏóêÍπåÏßÄ Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩúÏùÑ Ï†ÅÏö©ÌñàÍ∏∞ ÎïåÎ¨∏Ïù¥Îã§. Î°úÏª¨Ïóê Ï†ÄÏû•ÎêòÏñ¥ ÏûàÎäî Ïù¥ÎØ∏ÏßÄÎ•º Í∞ÄÏßú ÏùëÎãµÏúºÎ°ú ÎÇ¥Î≥¥ÎÇ¥Îäî ÌòïÌÉúÎ°ú ÎèôÏûëÌïòÍ∏∞Ïóê Í≥†ÏñëÏù¥ ÏÇ¨ÏßÑÏúºÎ°ú ÏùºÍ¥ÄÎêòÍ≤å Ï≤òÎ¶¨ÎêòÎäî Í≤ÉÏù¥Îã§.

Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩúÏù¥Í∏∞Ïóê ÏùºÍ¥ÄÎêòÍ≤å Ï≤òÎ¶¨ÎêòÏóàÎã§Í∏∞Î≥¥Îã§, Îã§Ïãú Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩú ÏΩîÎìúÎ•º ÏÇ¥Ìé¥Î≥¥Î©¥ `MockDTOType` Ïó¥Í±∞Ìòï ÏºÄÏù¥Ïä§Ïóê Í≥†ÏñëÏù¥ Ïù¥ÎØ∏ÏßÄÏóê ÎåÄÌïú Ïó¥Í±∞Ìòï ÌïòÎÇòÎßå Ï†ïÏùòÎêòÏñ¥ ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê Ïù¥Îü∞ Í≤ÉÏù¥Îã§.

```swift
enum MockDTOType {
    case empty
    case cacheImage

    var fileName: String {
        switch self {
        case .empty: return ""
        case .cacheImage: return "image.jpeg" // Í≥†ÏñëÏù¥ Ïù¥ÎØ∏ÏßÄ
        }
    }
}
```

Ïù¥ÎØ∏ÏßÄ Î™©ÏóÖ ÌîÑÎ°úÌÜ†ÏΩúÏùÑ Ï†ÅÏö©ÌïòÍ≤å ÎêòÎ©¥ xcode Í∞úÎ∞úÏûê ÎèÑÍµ¨ÏóêÏÑú ÎÑ§Ìä∏ÏõåÌÅ¨ ÎßÅÌÅ¨ Ïª®ÎîîÏÖîÎÑàÏóê `100% Loss` ÏòµÏÖòÏùÑ Í±∏Ïñ¥ÎëêÍ≥† ÌÖåÏä§Ìä∏ ÌïòÎçîÎùºÎèÑ Î°úÏª¨ÏóêÏÑú Í∞ÄÏßú ÏùëÎãµÏúºÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÎïåÎ¨∏Ïóê ÌÖåÏä§Ìä∏Í∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Ïù¥Î£®Ïñ¥ÏßÄÍ≤å ÎêúÎã§. ÌÖåÏä§Ìä∏ ÌôòÍ≤ΩÏù¥ ÎÑ§Ìä∏ÏõåÌÅ¨ ÌôòÍ≤ΩÏúºÎ°úÎ∂ÄÌÑ∞ ÏôÑÏ†ÑÌûà ÎèÖÎ¶ΩÏ†ÅÏúºÎ°ú Íµ¨ÏÑ±Îêú Í≤ÉÏù¥Îã§.

## Reference

1. [Simulate low network with Network Link Conditioner](https://medium.com/@itsanurag/simulate-low-network-with-network-link-conditioner-a1a7f14423b6)
2. [Ïú†Îãõ ÌÖåÏä§Ìä∏ ÌôòÍ≤Ω Íµ¨Ï∂ï](https://parkjju.github.io/vue-TIL/trash/230918-32.html)
3. [RxBlocking, RxTestÎ°ú ÌÖåÏä§Ìä∏ÏΩîÎìú ÏûëÏÑ±ÌïòÍ∏∞](https://parkjju.github.io/vue-TIL/trash/231129-37.html)
4. [ÎÑ§Ìä∏ÏõåÌÅ¨ Î™©ÏóÖ ÌÖåÏä§Ìä∏](https://parkjju.github.io/vue-TIL/trash/231202-38.html)
