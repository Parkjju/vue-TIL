---
title: Snack 47호 - Kingfisher를 통한 캐시 성능 향상 확인해보기
tags: ['Snack', 'Kingfisher', 'Concurrency', '포즈피커 개발 이야기']
---

## 개요

프로젝트 포즈피커 개발 이야기입니다! 궁금하시다면 놀러와주세요 :) [[포즈피커 다운받기🔗]](https://apps.apple.com/kr/app/%ED%8F%AC%EC%A6%88%ED%94%BC%EC%BB%A4-%EB%84%A4%EC%BB%B7%EC%82%AC%EC%A7%84-%ED%8F%AC%EC%A6%88%EC%B6%94%EC%B2%9C/id6474260471)

킹피셔는 이미지를 캐싱 처리를 도와주는 라이브러리입니다. 디스크 혹은 메모리 캐시 접근을 지원하고 캐시 미스가 발생한 경우 내부적으로 네트워크를 통한 다운로드 비동기 태스크까지 진행해주는 편리한 라이브러리입니다.

이번 글에서는 메모리 캐시, 디스크 캐시, 캐시 miss시 발생하는 성능 차이를 비교하고 어떻게 활용하면 좋을지 고민하는 과정을 소개해보겠습니다.

## 킹피셔 retrieveImage 함수

킹피셔에서는 `retrieveImage`라는 함수를 제공합니다. 해당 함수는 파라미터에 전달된 키 문자열 값을 기준으로 디스크 해시를 진행합니다. 만약 캐시 저장소에 데이터가 존재한 경우 **캐시 히트**가 발생하여 `completionHandler` 콜백의 `Result`타입 파라미터가 `success` 케이스로 분류됩니다. 반대로 데이터가 존재하지 않은 경우 **캐시 미스**가 발생하여 `completionHandler` 콜백의 `Result` 타입 파라미터가 `failure` 케이스로 분류됩니다.

이때, 캐시 미스가 발생하여 `failure`케이스로 분류되었을 때 내부적으로 네트워크를 통해 이미지 다운로드를 진행하고 다운로드된 이미지를 캐시에 저장하는 역할을 바로 `KingfisherManager.shared.retrieveImage`가 진행합니다.

이러한 흐름을 이해하고 내부 코드를 간단히 뜯어보도록 하겠습니다.

## 1. ImageCache.default.retrieveImage 뜯어보기

내부 코드를 뜯어보면 다음과 같습니다.

```swift
open func retrieveImage(
        forKey key: String,
        options: KingfisherParsedOptionsInfo,
        callbackQueue: CallbackQueue = .mainCurrentOrAsync,
        completionHandler: ((Result<ImageCacheResult, KingfisherError>) -> Void)?)
    {
        // No completion handler. No need to start working and early return.
        guard let completionHandler = completionHandler else { return }

        // Try to check the image from memory cache first.
        if let image = retrieveImageInMemoryCache(forKey: key, options: options) {
            callbackQueue.execute { completionHandler(.success(.memory(image))) }
        } else if options.fromMemoryCacheOrRefresh {
            callbackQueue.execute { completionHandler(.success(.none)) }
        } else {

            // Begin to disk search.
            self.retrieveImageInDiskCache(forKey: key, options: options, callbackQueue: callbackQueue) {
                result in
                switch result {
                case .success(let image):

                    guard let image = image else {
                        // No image found in disk storage.
                        callbackQueue.execute { completionHandler(.success(.none)) }
                        return
                    }
                    // ... 나머지 코드
                case .failure(let error):
                    callbackQueue.execute { completionHandler(.failure(error)) }
                }
            }
        }
    }
```

위 코드의 주요 흐름을 정리하면 다음과 같습니다.

1. `completionHandler` 클로저 전달 유무에 따라 코드 실행 여부가 결정됩니다. early-return 패턴으로 함수가 조기 종료됩니다.
2. `retrieveImageInMemoryCache`: 메모리 캐시 접근을 먼저 진행합니다. 캐시 히트가 발생한 경우 `success` 케이스를 리턴하고 종료합니다.
3. `fromMemoryCacheOrRefresh`: 해당 옵션이 지정되어 있는 경우에만 코드가 실행되며, 메모리 캐시 접근 시도 후 캐시 미스가 발생하면 디스크 캐시에 접근합니다. 디스크 캐시에서도 캐시 미스가 발생한 경우 별도의 네트워크를 통한 이미지 다운로드는 처리하지 않습니다.
4. 아무 옵션도 지정되지 않고, 메모리 캐시도 미스난 경우 디스크 캐시에 접근합니다.
5. 킹피셔 에러가 발생한 경우 에러를 `Result`에 담아 콜백을 호출하고, 만약 디스크 캐시까지 미스난 경우 `.none`열거형 값을 콜백에 담아 리턴합니다. **.none**은 에러가 아님에 주의해야 합니다.
6. `.none`이 리턴되면 `success`케이스의 파라미터에는 `nil`이 담기게 됩니다. 아래 코드를 더 살펴보겠습니다.

```swift
ImageCache.default.retrieveImage(forKey: pose.poseInfo.imageKey) { result in
    switch result {
    case .success(let value):
        if let image = value.image {
            print("CACHE HIT!!: \(value.cacheType)")
        }
    case .failure:
        print("Unknown error")
        return
    }
}
```

`retrieveImage`에서 `success`케이스로 분류 되었을 때, 파라미터에는 `ImageCacheResult` 타입 값이 담겨있게 됩니다.

```swift
public enum ImageCacheResult {

    /// The image can be retrieved from disk cache.
    case disk(KFCrossPlatformImage)

    /// The image can be retrieved memory cache.
    case memory(KFCrossPlatformImage)

    /// The image does not exist in the cache.
    case none

    /// Extracts the image from cache result. It returns the associated `Image` value for
    /// `.disk` and `.memory` case. For `.none` case, `nil` is returned.
    public var image: KFCrossPlatformImage? {
        switch self {
        case .disk(let image): return image
        case .memory(let image): return image
        case .none: return nil
        }
    }

    /// Returns the corresponding `CacheType` value based on the result type of `self`.
    public var cacheType: CacheType {
        switch self {
        case .disk: return .disk
        case .memory: return .memory
        case .none: return .none
        }
    }
}
```

위와 같이 값이 구성되어 있으며 이미지 속성이 `none`인 경우 `nil`값을 리턴합니다.

옵셔널 바인딩을 통해 이미지가 정상적으로 추출되었으면 캐시 히트를 통해 이미지가 정상적으로 렌더링 될 준비가 된 것입니다.

`cacheType` 속성을 사용하면 캐시 히트 이후 어디에 캐싱 되어있는지 알 수 있습니다.

## 2. 캐시 미스 이후

캐시 미스가 발생한 경우 이미지를 다운로드 받아야 합니다. 네트워크 통신을 통한 이미지 다운로드 기능을 지원하는 메서드는 `ImageCache.default`에 있지 않고 `KingfisherManager.shared`객체에 포함되어 있습니다.

`KingfisherManager.shared.retrieveImage` 함수 내부 구현은 중첩 호출 형태로 구현되어 있습니다. 호출되는 함수들을 쭉 파고들다 보면 아래와 같은 함수를 마주하게 됩니다.

```swift
private func retrieveImage(
    with source: Source,
    context: RetrievingContext,
    completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask?
{
    let options = context.options
    if options.forceRefresh {
        return loadAndCacheImage(
            source: source,
            context: context,
            completionHandler: completionHandler)?.value

    } else {
        let loadedFromCache = retrieveImageFromCache(
            source: source,
            context: context,
            completionHandler: completionHandler)

        if loadedFromCache {
            return nil
        }

        if options.onlyFromCache {
            let error = KingfisherError.cacheError(reason: .imageNotExisting(key: source.cacheKey))
            completionHandler?(.failure(error))
            return nil
        }

        return loadAndCacheImage(
            source: source,
            context: context,
            completionHandler: completionHandler)?.value
    }
}
```

함수 파라미터의 `options` 중 `onlyFromCache`가 지정되어 있는 경우 캐시 미스가 발생했을 때 에러를 리턴하고 함수를 종료합니다. `forceRefresh` 옵션이 지정되어 있는 경우 캐시 체크를 하지 않고 네트워크를 통해 이미지를 새로 받아오도록 강제합니다.

해당 옵션이 지정되어 있지 않으면 `loadAndCacheImage`로 함수 호출이 넘어갑니다.

```swift
@discardableResult
func loadAndCacheImage(
    source: Source,
    context: RetrievingContext,
    completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask.WrappedTask?
{
    let options = context.options

    switch source {
    case .network(let resource):
        let downloader = options.downloader ?? self.downloader
        let task = downloader.downloadImage(
            with: resource.downloadURL, options: options, completionHandler: _cacheImage
        )

        if let task = task {
            return .download(task)
        } else {
            return nil
        }

    case .provider(let provider):
        provideImage(provider: provider, options: options, completionHandler: _cacheImage)
        return .dataProviding
    }
}
```

위 함수에서는 `source` 파라미터를 통해 URL을 추출하고 다운로드 태스크를 통해 이미지를 로드합니다.

이때 `downloader`옵션을 체크하여 객체가 전달된 경우 해당 다운로더 객체를 통해 이미지 다운로드를 진행합니다. 이 코드를 통해 네트워크 환경 없이 로컬에 저장된 이미지를 테스트 환경에서 불러올 수 있게 됩니다. 이와 관련된 자세한 내용은 [다음 문서를](https://parkjju.github.io/vue-TIL/trash/231205-39.html) 참고해주세요.

`KingfisherManager.shared.retrieveImage`를 통해 이미지 다운로드가 가능하다는 것을 알았으니, 코드를 직접 작성해볼까요?

```swift
ImageCache.default.retrieveImage(forKey: pose.poseInfo.imageKey) { result in
    switch result {
    case .success(let value):
        if let image = value.image {
            // image UI 바인딩
            print("CACHE HIT!!: \(value.cacheType)")
        } else if let url = URL(string: pose.poseInfo.imageKey) {
            print("CACHE MISS!!")
            KingfisherManager.shared.retrieveImage(with: url) { downloadResult in
                switch downloadResult {
                case .success(let downloaded):
                    // downloaded.image에 접근 후 이미지 UI 바인딩
                case .failure(let error):
                    return
                }
            }
        }
    case .failure:
        return
    }
}
```

1. `ImageCache.default.retrieveImage`로 캐시 접근을 진행합니다.
2. 이미지가 nil값이 아니면 UI 바인딩을 진행합니다.
3. 이미지가 nil값인 경우 캐시 미스가 발생한 것이므로 `KingfisherManager.shared.retrieveImage`에서 이미지 다운로드를 진행합니다

:::tip 중첩 클로저와 Thread-safe 코드

클로저가 중첩되어도 스레드는 안전한 상태로 코드가 실행됩니다.

```swift
open var sessionDelegate: SessionDelegate {
    didSet {
        session.invalidateAndCancel()
        session = URLSession(configuration: sessionConfiguration, delegate: sessionDelegate, delegateQueue: nil)
        setupSessionHandler()
    }
}
```

`ImageDownloader`객체의 `delegateQueue` 파라미터를 보면 nil로 설정되어 있습니다. URLSession 이니셜라이저 문서 중 `delegateQueue`에 대한 일부 내용을 발췌하여 아래 내용을 볼 수 있습니다.

> If nil, the session creates a serial operation queue for performing all delegate method calls and completion handler calls.

nil로 설정된 경우 직렬 오퍼레이션 큐를 직접 생성하여 네트워크 관련 태스크들을 관리합니다.

:::

`retrieveImage`함수에서 이미지 다운로드와 프로세싱이 모두 마무리 되면 `completionHandler`가 실행됩니다. 이때 옵션 파라미터에 따로 값을 지정하지 않으면 콜백 큐로 메인 스레드가 지정됩니다.

이미지를 UI에 바인딩 해주어야 하기 때문에 메인 스레드에서 실행해야 합니다. 만약 `callbackQueue`값에 글로벌 큐를 할당하면 UI 바인딩 시 에러가 발생하게 됩니다.

```swift
KingfisherManager.shared.retrieveImage(
    with: url,
    options: [
        .callbackQueue(
            .dispatch(
                .global()
            )
        )
    ]
    )  {
    // ...
}
// 불러온 이미지를 UI에 바로 바인딩 하려고 하면 에러 발생
```

## 성능 테스트

코드 구축은 완료하였으니 캐시 히트 여부와 어떤 캐시를 사용하는 지에 따라 성능 차이가 얼마나 발생하는 지를 테스트 해보도록 하겠습니다. 먼저, 캐시 미스가 발생했을 때 이미지를 다운로드 받는 속도에 얼마나 차이가 발생하는 지를 확인해보도록 하겠습니다.

이를 테스트 하기 위해, 다른 요인들로 인해 속도 차이가 발생하는 것을 통제하는 조건들을 마련하였습니다.

1. `AppDelegate`의 `didFinishLaunchingWithOptions` 함수가 호출될 때 `ImageCache.default.clearCache()`를 호출하여 캐시를 비웠습니다.
2. 네트워크 환경은 DSL(전화선) 속도로 강제로 제한하였습니다.
3. 다운로드가 이루어지는 이미지는 총 세개입니다. 각 이미지 사이즈는 아래와 같습니다.
    - `0.12 MB`
    - `0.30 MB`
    - `1.11 MB`

네트워크 링크 컨디셔너에서의 DSL 스펙은 다음과 같습니다. (다운링크만 고려)

1. 대역폭: 2Mbps
2. 패킷 드롭: 0%
3. 딜레이 5ms

네트워크 이론에 따라 이미지 패킷이 다운링크를 따라 전송되는 시간을 계산하면 다음과 같습니다. 딜레이는 무시해도 되는 정도의 수치라 계산에서 제외하였습니다.

$$
time_{transmission}=\frac{data(Mbps)}{bandwidth}
$$

$$
time_{transmission}=\frac{0.12MB}{2Mbps} + \frac{0.30MB}{2Mbps} + \frac{1.11MB}{2Mbps}
$$

$$
\frac{0.12 \times 8 (Mbit)}{2Mbps} + \frac{0.30 \times 8 (Mbit)}{2Mbps} + \frac{1.11 \times 8 (Mbit) }{2Mbps} = 0.48s + 1.2s + 4.44s = 6.12s
$$

그렇다면 실제로 컨텐츠 다운로드까지 걸리는 시간을 계산해볼까요? 이미지 다운로드 시간 측정과 이미지 사이즈를 출력한 결과는 다음과 같습니다.

```text
processingTime: 1.971391458 seconds
MEGA: 0.11989974975585938

processingTime: 5.402707917 seconds
MEGA: 0.2960662841796875

processingTime: 6.923137832999999 seconds
MEGA: 1.0994071960449219
```

컨텐츠 다운로드 시간과 사이즈 측정 방법은 아래에서 자세히 설명하겠습니다.

## 다운로드 시간 측정

`KingfisherManager.shared.retrieveImage` 함수는 파라미터로 `progressBlock` 클로저를 전달할 수 있습니다.

```swift
KingfisherManager.shared.retrieveImage(with: url) { [weak self] processingSize, totalSize in
    guard let self = self else { return }

    if self.dict[url.absoluteString] != nil {
        self.sizeDict[url.absoluteString] = Double(totalSize) / 1024 / 1024
        self.sizeAppendingCheck[url.absoluteString]?.append(processingSize)
        self.dict[url.absoluteString]?.append(self.clock.now)
    } else {
        self.sizeAppendingCheck[url.absoluteString] = [processingSize]
        self.dict[url.absoluteString] = [self.clock.now]
    }
} completionHandler: { downloadResult in
    switch downloadResult {
    case .success(let downloaded):
        print("===")
        print("processingTime: \(self.dict[url.absoluteString]!.first!.duration(to: self.dict[url.absoluteString]!.last!))")
        print("MEGA: \(self.sizeDict[url.absoluteString]!)")
        print("===")
        let viewModel = PoseFeedPhotoCellViewModel(
            image: downloaded.image,
            poseId: pose.poseInfo.poseId ?? 0,
            bookmarkCheck: pose.poseInfo.bookmarkCheck ?? false)
        viewModelObservable.accept(viewModelObservable.value + [viewModel])
    case .failure(let error):
        print("error in first: ", error)
        return
    }
}
```
