---
title: Snack 47í˜¸ - Kingfisherë¥¼ í†µí•œ ìºì‹œ ì„±ëŠ¥ í–¥ìƒ í™•ì¸í•´ë³´ê¸°
tags: ['Snack', 'Kingfisher', 'Concurrency', 'í¬ì¦ˆí”¼ì»¤ ê°œë°œ ì´ì•¼ê¸°']
---

## ê°œìš”

í”„ë¡œì íŠ¸ í¬ì¦ˆí”¼ì»¤ ê°œë°œ ì´ì•¼ê¸°ì…ë‹ˆë‹¤! ê¶ê¸ˆí•˜ì‹œë‹¤ë©´ ë†€ëŸ¬ì™€ì£¼ì„¸ìš” :) [[í¬ì¦ˆí”¼ì»¤ ë‹¤ìš´ë°›ê¸°ğŸ”—]](https://apps.apple.com/kr/app/%ED%8F%AC%EC%A6%88%ED%94%BC%EC%BB%A4-%EB%84%A4%EC%BB%B7%EC%82%AC%EC%A7%84-%ED%8F%AC%EC%A6%88%EC%B6%94%EC%B2%9C/id6474260471)

í‚¹í”¼ì…”ëŠ” ì´ë¯¸ì§€ë¥¼ ìºì‹± ì²˜ë¦¬ë¥¼ ë„ì™€ì£¼ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ì…ë‹ˆë‹¤. ë””ìŠ¤í¬ í˜¹ì€ ë©”ëª¨ë¦¬ ìºì‹œ ì ‘ê·¼ì„ ì§€ì›í•˜ê³  ìºì‹œ ë¯¸ìŠ¤ê°€ ë°œìƒí•œ ê²½ìš° ë‚´ë¶€ì ìœ¼ë¡œ ë„¤íŠ¸ì›Œí¬ë¥¼ í†µí•œ ë‹¤ìš´ë¡œë“œ ë¹„ë™ê¸° íƒœìŠ¤í¬ê¹Œì§€ ì§„í–‰í•´ì£¼ëŠ” í¸ë¦¬í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ì…ë‹ˆë‹¤.

ì´ë²ˆ ê¸€ì—ì„œëŠ” ë©”ëª¨ë¦¬ ìºì‹œ, ë””ìŠ¤í¬ ìºì‹œ, ìºì‹œ missì‹œ ë°œìƒí•˜ëŠ” ì„±ëŠ¥ ì°¨ì´ë¥¼ ë¹„êµí•˜ê³  ì–´ë–»ê²Œ í™œìš©í•˜ë©´ ì¢‹ì„ì§€ ê³ ë¯¼í•˜ëŠ” ê³¼ì •ì„ ì†Œê°œí•´ë³´ê² ìŠµë‹ˆë‹¤.

## í‚¹í”¼ì…” retrieveImage í•¨ìˆ˜

í‚¹í”¼ì…”ì—ì„œëŠ” `retrieveImage`ë¼ëŠ” í•¨ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤. í•´ë‹¹ í•¨ìˆ˜ëŠ” íŒŒë¼ë¯¸í„°ì— ì „ë‹¬ëœ í‚¤ ë¬¸ìì—´ ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ë””ìŠ¤í¬ í•´ì‹œë¥¼ ì§„í–‰í•©ë‹ˆë‹¤. ë§Œì•½ ìºì‹œ ì €ì¥ì†Œì— ë°ì´í„°ê°€ ì¡´ì¬í•œ ê²½ìš° **ìºì‹œ íˆíŠ¸**ê°€ ë°œìƒí•˜ì—¬ `completionHandler` ì½œë°±ì˜ `Result`íƒ€ì… íŒŒë¼ë¯¸í„°ê°€ `success` ì¼€ì´ìŠ¤ë¡œ ë¶„ë¥˜ë©ë‹ˆë‹¤. ë°˜ëŒ€ë¡œ ë°ì´í„°ê°€ ì¡´ì¬í•˜ì§€ ì•Šì€ ê²½ìš° **ìºì‹œ ë¯¸ìŠ¤**ê°€ ë°œìƒí•˜ì—¬ `completionHandler` ì½œë°±ì˜ `Result` íƒ€ì… íŒŒë¼ë¯¸í„°ê°€ `failure` ì¼€ì´ìŠ¤ë¡œ ë¶„ë¥˜ë©ë‹ˆë‹¤.

ì´ë•Œ, ìºì‹œ ë¯¸ìŠ¤ê°€ ë°œìƒí•˜ì—¬ `failure`ì¼€ì´ìŠ¤ë¡œ ë¶„ë¥˜ë˜ì—ˆì„ ë•Œ ë‚´ë¶€ì ìœ¼ë¡œ ë„¤íŠ¸ì›Œí¬ë¥¼ í†µí•´ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œë¥¼ ì§„í–‰í•˜ê³  ë‹¤ìš´ë¡œë“œëœ ì´ë¯¸ì§€ë¥¼ ìºì‹œì— ì €ì¥í•˜ëŠ” ì—­í• ì„ ë°”ë¡œ `KingfisherManager.shared.retrieveImage`ê°€ ì§„í–‰í•©ë‹ˆë‹¤.

ì´ëŸ¬í•œ íë¦„ì„ ì´í•´í•˜ê³  ë‚´ë¶€ ì½”ë“œë¥¼ ê°„ë‹¨íˆ ëœ¯ì–´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

## ImageCache.default.retrieveImage ëœ¯ì–´ë³´ê¸°

ë‚´ë¶€ ì½”ë“œë¥¼ ëœ¯ì–´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```swift
open func retrieveImage(
        forKey key: String,
        options: KingfisherParsedOptionsInfo,
        callbackQueue: CallbackQueue = .mainCurrentOrAsync,
        completionHandler: ((Result<ImageCacheResult, KingfisherError>) -> Void)?)
    {
        // No completion handler. No need to start working and early return.
        guard let completionHandler = completionHandler else { return }

        // Try to check the image from memory cache first.
        if let image = retrieveImageInMemoryCache(forKey: key, options: options) {
            callbackQueue.execute { completionHandler(.success(.memory(image))) }
        } else if options.fromMemoryCacheOrRefresh {
            callbackQueue.execute { completionHandler(.success(.none)) }
        } else {

            // Begin to disk search.
            self.retrieveImageInDiskCache(forKey: key, options: options, callbackQueue: callbackQueue) {
                result in
                switch result {
                case .success(let image):

                    guard let image = image else {
                        // No image found in disk storage.
                        callbackQueue.execute { completionHandler(.success(.none)) }
                        return
                    }
                    // ... ë‚˜ë¨¸ì§€ ì½”ë“œ
                case .failure(let error):
                    callbackQueue.execute { completionHandler(.failure(error)) }
                }
            }
        }
    }
```

ìœ„ ì½”ë“œì˜ ì£¼ìš” íë¦„ì„ ì •ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

1. `completionHandler` í´ë¡œì € ì „ë‹¬ ìœ ë¬´ì— ë”°ë¼ ì½”ë“œ ì‹¤í–‰ ì—¬ë¶€ê°€ ê²°ì •ë©ë‹ˆë‹¤. early-return íŒ¨í„´ìœ¼ë¡œ í•¨ìˆ˜ê°€ ì¡°ê¸° ì¢…ë£Œë©ë‹ˆë‹¤.
2. `retrieveImageInMemoryCache`: ë©”ëª¨ë¦¬ ìºì‹œ ì ‘ê·¼ì„ ë¨¼ì € ì§„í–‰í•©ë‹ˆë‹¤. ìºì‹œ íˆíŠ¸ê°€ ë°œìƒí•œ ê²½ìš° `success` ì¼€ì´ìŠ¤ë¥¼ ë¦¬í„´í•˜ê³  ì¢…ë£Œí•©ë‹ˆë‹¤.
3. `fromMemoryCacheOrRefresh`: í•´ë‹¹ ì˜µì…˜ì´ ì§€ì •ë˜ì–´ ìˆëŠ” ê²½ìš°ì—ë§Œ ì½”ë“œê°€ ì‹¤í–‰ë˜ë©°, ë©”ëª¨ë¦¬ ìºì‹œ ì ‘ê·¼ ì‹œë„ í›„ ìºì‹œ ë¯¸ìŠ¤ê°€ ë°œìƒí•˜ë©´ ë””ìŠ¤í¬ ìºì‹œì— ì ‘ê·¼í•©ë‹ˆë‹¤. ë””ìŠ¤í¬ ìºì‹œì—ì„œë„ ìºì‹œ ë¯¸ìŠ¤ê°€ ë°œìƒí•œ ê²½ìš° ë³„ë„ì˜ ë„¤íŠ¸ì›Œí¬ë¥¼ í†µí•œ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œëŠ” ì²˜ë¦¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
4. ì•„ë¬´ ì˜µì…˜ë„ ì§€ì •ë˜ì§€ ì•Šê³ , ë©”ëª¨ë¦¬ ìºì‹œë„ ë¯¸ìŠ¤ë‚œ ê²½ìš° ë””ìŠ¤í¬ ìºì‹œì— ì ‘ê·¼í•©ë‹ˆë‹¤.
5. í‚¹í”¼ì…” ì—ëŸ¬ê°€ ë°œìƒí•œ ê²½ìš° ì—ëŸ¬ë¥¼ `Result`ì— ë‹´ì•„ ì½œë°±ì„ í˜¸ì¶œí•˜ê³ , ë§Œì•½ ë””ìŠ¤í¬ ìºì‹œê¹Œì§€ ë¯¸ìŠ¤ë‚œ ê²½ìš° `.none`ì—´ê±°í˜• ê°’ì„ ì½œë°±ì— ë‹´ì•„ ë¦¬í„´í•©ë‹ˆë‹¤. **.none**ì€ ì—ëŸ¬ê°€ ì•„ë‹˜ì— ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.
6. `.none`ì´ ë¦¬í„´ë˜ë©´ `success`ì¼€ì´ìŠ¤ì˜ íŒŒë¼ë¯¸í„°ì—ëŠ” `nil`ì´ ë‹´ê¸°ê²Œ ë©ë‹ˆë‹¤. ì•„ë˜ ì½”ë“œë¥¼ ë” ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

```swift
ImageCache.default.retrieveImage(forKey: pose.poseInfo.imageKey) { result in
    switch result {
    case .success(let value):
        if let image = value.image {
            print("CACHE HIT!!: \(value.cacheType)")
        }
    case .failure:
        print("Unknown error")
        return
    }
}
```

`retrieveImage`ì—ì„œ `success`ì¼€ì´ìŠ¤ë¡œ ë¶„ë¥˜ ë˜ì—ˆì„ ë•Œ, íŒŒë¼ë¯¸í„°ì—ëŠ” `ImageCacheResult` íƒ€ì… ê°’ì´ ë‹´ê²¨ìˆê²Œ ë©ë‹ˆë‹¤.

```swift
public enum ImageCacheResult {

    /// The image can be retrieved from disk cache.
    case disk(KFCrossPlatformImage)

    /// The image can be retrieved memory cache.
    case memory(KFCrossPlatformImage)

    /// The image does not exist in the cache.
    case none

    /// Extracts the image from cache result. It returns the associated `Image` value for
    /// `.disk` and `.memory` case. For `.none` case, `nil` is returned.
    public var image: KFCrossPlatformImage? {
        switch self {
        case .disk(let image): return image
        case .memory(let image): return image
        case .none: return nil
        }
    }

    /// Returns the corresponding `CacheType` value based on the result type of `self`.
    public var cacheType: CacheType {
        switch self {
        case .disk: return .disk
        case .memory: return .memory
        case .none: return .none
        }
    }
}
```

ìœ„ì™€ ê°™ì´ ê°’ì´ êµ¬ì„±ë˜ì–´ ìˆìœ¼ë©° ì´ë¯¸ì§€ ì†ì„±ì´ `none`ì¸ ê²½ìš° `nil`ê°’ì„ ë¦¬í„´í•©ë‹ˆë‹¤.

ì˜µì…”ë„ ë°”ì¸ë”©ì„ í†µí•´ ì´ë¯¸ì§€ê°€ ì •ìƒì ìœ¼ë¡œ ì¶”ì¶œë˜ì—ˆìœ¼ë©´ ìºì‹œ íˆíŠ¸ë¥¼ í†µí•´ ì´ë¯¸ì§€ê°€ ì •ìƒì ìœ¼ë¡œ ë Œë”ë§ ë  ì¤€ë¹„ê°€ ëœ ê²ƒì…ë‹ˆë‹¤.

`cacheType` ì†ì„±ì„ ì‚¬ìš©í•˜ë©´ ìºì‹œ íˆíŠ¸ ì´í›„ ì–´ë””ì— ìºì‹± ë˜ì–´ìˆëŠ”ì§€ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ìºì‹œ ë¯¸ìŠ¤ ìƒí™©

ìºì‹œ ë¯¸ìŠ¤ê°€ ë°œìƒí•œ ê²½ìš° ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œ ë°›ì•„ì•¼ í•©ë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬ í†µì‹ ì„ í†µí•œ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ê¸°ëŠ¥ì„ ì§€ì›í•˜ëŠ” ë©”ì„œë“œëŠ” `ImageCache.default`ì— ìˆì§€ ì•Šê³  `KingfisherManager.shared`ê°ì²´ì— í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

`KingfisherManager.shared.retrieveImage` í•¨ìˆ˜ ë‚´ë¶€ êµ¬í˜„ì€ ì¤‘ì²© í˜¸ì¶œ í˜•íƒœë¡œ êµ¬í˜„ë˜ì–´ ìˆìŠµë‹ˆë‹¤. í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜ë“¤ì„ ì­‰ íŒŒê³ ë“¤ë‹¤ ë³´ë©´ ì•„ë˜ì™€ ê°™ì€ í•¨ìˆ˜ë¥¼ ë§ˆì£¼í•˜ê²Œ ë©ë‹ˆë‹¤.

```swift
private func retrieveImage(
    with source: Source,
    context: RetrievingContext,
    completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask?
{
    let options = context.options
    if options.forceRefresh {
        return loadAndCacheImage(
            source: source,
            context: context,
            completionHandler: completionHandler)?.value

    } else {
        let loadedFromCache = retrieveImageFromCache(
            source: source,
            context: context,
            completionHandler: completionHandler)

        if loadedFromCache {
            return nil
        }

        if options.onlyFromCache {
            let error = KingfisherError.cacheError(reason: .imageNotExisting(key: source.cacheKey))
            completionHandler?(.failure(error))
            return nil
        }

        return loadAndCacheImage(
            source: source,
            context: context,
            completionHandler: completionHandler)?.value
    }
}
```

í•¨ìˆ˜ íŒŒë¼ë¯¸í„°ì˜ `options` ì¤‘ `onlyFromCache`ê°€ ì§€ì •ë˜ì–´ ìˆëŠ” ê²½ìš° ìºì‹œ ë¯¸ìŠ¤ê°€ ë°œìƒí–ˆì„ ë•Œ ì—ëŸ¬ë¥¼ ë¦¬í„´í•˜ê³  í•¨ìˆ˜ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤. `forceRefresh` ì˜µì…˜ì´ ì§€ì •ë˜ì–´ ìˆëŠ” ê²½ìš° ìºì‹œ ì²´í¬ë¥¼ í•˜ì§€ ì•Šê³  ë„¤íŠ¸ì›Œí¬ë¥¼ í†µí•´ ì´ë¯¸ì§€ë¥¼ ìƒˆë¡œ ë°›ì•„ì˜¤ë„ë¡ ê°•ì œí•©ë‹ˆë‹¤.

í•´ë‹¹ ì˜µì…˜ì´ ì§€ì •ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´ `loadAndCacheImage`ë¡œ í•¨ìˆ˜ í˜¸ì¶œì´ ë„˜ì–´ê°‘ë‹ˆë‹¤.

```swift
@discardableResult
func loadAndCacheImage(
    source: Source,
    context: RetrievingContext,
    completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask.WrappedTask?
{
    let options = context.options

    switch source {
    case .network(let resource):
        let downloader = options.downloader ?? self.downloader
        let task = downloader.downloadImage(
            with: resource.downloadURL, options: options, completionHandler: _cacheImage
        )

        if let task = task {
            return .download(task)
        } else {
            return nil
        }

    case .provider(let provider):
        provideImage(provider: provider, options: options, completionHandler: _cacheImage)
        return .dataProviding
    }
}
```

ìœ„ í•¨ìˆ˜ì—ì„œëŠ” `source` íŒŒë¼ë¯¸í„°ë¥¼ í†µí•´ URLì„ ì¶”ì¶œí•˜ê³  ë‹¤ìš´ë¡œë“œ íƒœìŠ¤í¬ë¥¼ í†µí•´ ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.

ì´ë•Œ `downloader`ì˜µì…˜ì„ ì²´í¬í•˜ì—¬ ê°ì²´ê°€ ì „ë‹¬ëœ ê²½ìš° í•´ë‹¹ ë‹¤ìš´ë¡œë” ê°ì²´ë¥¼ í†µí•´ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œë¥¼ ì§„í–‰í•©ë‹ˆë‹¤. ì´ ì½”ë“œë¥¼ í†µí•´ ë„¤íŠ¸ì›Œí¬ í™˜ê²½ ì—†ì´ ë¡œì»¬ì— ì €ì¥ëœ ì´ë¯¸ì§€ë¥¼ í…ŒìŠ¤íŠ¸ í™˜ê²½ì—ì„œ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤. ì´ì™€ ê´€ë ¨ëœ ìì„¸í•œ ë‚´ìš©ì€ [ë‹¤ìŒ ë¬¸ì„œë¥¼](https://parkjju.github.io/vue-TIL/trash/231205-39.html) ì°¸ê³ í•´ì£¼ì„¸ìš”.

`KingfisherManager.shared.retrieveImage`ë¥¼ í†µí•´ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œê°€ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œì•˜ìœ¼ë‹ˆ, ì½”ë“œë¥¼ ì§ì ‘ ì‘ì„±í•´ë³¼ê¹Œìš”?

```swift
ImageCache.default.retrieveImage(forKey: pose.poseInfo.imageKey) { result in
    switch result {
    case .success(let value):
        if let image = value.image {
            // image UI ë°”ì¸ë”©
            print("CACHE HIT!!: \(value.cacheType)")
        } else if let url = URL(string: pose.poseInfo.imageKey) {
            print("CACHE MISS!!")
            KingfisherManager.shared.retrieveImage(with: url) { downloadResult in
                switch downloadResult {
                case .success(let downloaded):
                    // downloaded.imageì— ì ‘ê·¼ í›„ ì´ë¯¸ì§€ UI ë°”ì¸ë”©
                case .failure(let error):
                    return
                }
            }
        }
    case .failure:
        return
    }
}
```

1. `ImageCache.default.retrieveImage`ë¡œ ìºì‹œ ì ‘ê·¼ì„ ì§„í–‰í•©ë‹ˆë‹¤.
2. ì´ë¯¸ì§€ê°€ nilê°’ì´ ì•„ë‹ˆë©´ UI ë°”ì¸ë”©ì„ ì§„í–‰í•©ë‹ˆë‹¤.
3. ì´ë¯¸ì§€ê°€ nilê°’ì¸ ê²½ìš° ìºì‹œ ë¯¸ìŠ¤ê°€ ë°œìƒí•œ ê²ƒì´ë¯€ë¡œ `KingfisherManager.shared.retrieveImage`ì—ì„œ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œë¥¼ ì§„í–‰í•©ë‹ˆë‹¤

:::tip ì¤‘ì²© í´ë¡œì €ì™€ Thread-safe ì½”ë“œ

í´ë¡œì €ê°€ ì¤‘ì²©ë˜ì–´ë„ ìŠ¤ë ˆë“œëŠ” ì•ˆì „í•œ ìƒíƒœë¡œ ì½”ë“œê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.

```swift
open var sessionDelegate: SessionDelegate {
    didSet {
        session.invalidateAndCancel()
        session = URLSession(configuration: sessionConfiguration, delegate: sessionDelegate, delegateQueue: nil)
        setupSessionHandler()
    }
}
```

`ImageDownloader`ê°ì²´ì˜ `delegateQueue` íŒŒë¼ë¯¸í„°ë¥¼ ë³´ë©´ nilë¡œ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤. URLSession ì´ë‹ˆì…œë¼ì´ì € ë¬¸ì„œ ì¤‘ `delegateQueue`ì— ëŒ€í•œ ì¼ë¶€ ë‚´ìš©ì„ ë°œì·Œí•˜ì—¬ ì•„ë˜ ë‚´ìš©ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

> If nil, the session creates a serial operation queue for performing all delegate method calls and completion handler calls.

nilë¡œ ì„¤ì •ëœ ê²½ìš° ì§ë ¬ ì˜¤í¼ë ˆì´ì…˜ íë¥¼ ì§ì ‘ ìƒì„±í•˜ì—¬ ë„¤íŠ¸ì›Œí¬ ê´€ë ¨ íƒœìŠ¤í¬ë“¤ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.

:::

`retrieveImage`í•¨ìˆ˜ì—ì„œ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œì™€ í”„ë¡œì„¸ì‹±ì´ ëª¨ë‘ ë§ˆë¬´ë¦¬ ë˜ë©´ `completionHandler`ê°€ ì‹¤í–‰ë©ë‹ˆë‹¤. ì´ë•Œ ì˜µì…˜ íŒŒë¼ë¯¸í„°ì— ë”°ë¡œ ê°’ì„ ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ ì½œë°± íë¡œ ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì§€ì •ë©ë‹ˆë‹¤.

ì´ë¯¸ì§€ë¥¼ UIì— ë°”ì¸ë”© í•´ì£¼ì–´ì•¼ í•˜ê¸° ë•Œë¬¸ì— ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤. ë§Œì•½ `callbackQueue`ê°’ì— ê¸€ë¡œë²Œ íë¥¼ í• ë‹¹í•˜ë©´ UI ë°”ì¸ë”© ì‹œ ì—ëŸ¬ê°€ ë°œìƒí•˜ê²Œ ë©ë‹ˆë‹¤.

```swift
KingfisherManager.shared.retrieveImage(
    with: url,
    options: [
        .callbackQueue(
            .dispatch(
                .global()
            )
        )
    ]
    )  {
    // ...
}
// ë¶ˆëŸ¬ì˜¨ ì´ë¯¸ì§€ë¥¼ UIì— ë°”ë¡œ ë°”ì¸ë”© í•˜ë ¤ê³  í•˜ë©´ ì—ëŸ¬ ë°œìƒ
```

## ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì‹œê°„ ì¸¡ì •

ì½”ë“œ êµ¬ì¶•ì€ ì™„ë£Œí•˜ì˜€ìœ¼ë‹ˆ ìºì‹œ íˆíŠ¸ ì—¬ë¶€ì™€ ì–´ë–¤ ìºì‹œë¥¼ ì‚¬ìš©í•˜ëŠ” ì§€ì— ë”°ë¼ ì„±ëŠ¥ ì°¨ì´ê°€ ì–¼ë§ˆë‚˜ ë°œìƒí•˜ëŠ” ì§€ë¥¼ í…ŒìŠ¤íŠ¸ í•´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤. ë¨¼ì €, ìºì‹œ ë¯¸ìŠ¤ê°€ ë°œìƒí–ˆì„ ë•Œ ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œ ë°›ëŠ” ì†ë„ì— ì–¼ë§ˆë‚˜ ì°¨ì´ê°€ ë°œìƒí•˜ëŠ” ì§€ë¥¼ í™•ì¸í•´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

ì´ë¥¼ í…ŒìŠ¤íŠ¸ í•˜ê¸° ìœ„í•´, ë‹¤ë¥¸ ìš”ì¸ë“¤ë¡œ ì¸í•´ ì†ë„ ì°¨ì´ê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ í†µì œí•˜ëŠ” ì¡°ê±´ë“¤ì„ ë§ˆë ¨í•˜ì˜€ìŠµë‹ˆë‹¤.

1. `AppDelegate`ì˜ `didFinishLaunchingWithOptions` í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œ `ImageCache.default.clearCache()`ë¥¼ í˜¸ì¶œí•˜ì—¬ ìºì‹œë¥¼ ë¹„ì› ìŠµë‹ˆë‹¤.
2. ë„¤íŠ¸ì›Œí¬ í™˜ê²½ì€ DSL(ì „í™”ì„ ) ì†ë„ë¡œ ê°•ì œë¡œ ì œí•œí•˜ì˜€ìŠµë‹ˆë‹¤.
3. ë‹¤ìš´ë¡œë“œê°€ ì´ë£¨ì–´ì§€ëŠ” ì´ë¯¸ì§€ëŠ” ì´ ì„¸ê°œì…ë‹ˆë‹¤. ê° ì´ë¯¸ì§€ ì‚¬ì´ì¦ˆëŠ” ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤.
    - `0.12 MB`
    - `0.30 MB`
    - `1.11 MB`

ë„¤íŠ¸ì›Œí¬ ë§í¬ ì»¨ë””ì…”ë„ˆì—ì„œì˜ DSL ìŠ¤í™ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤. (ë‹¤ìš´ë§í¬ë§Œ ê³ ë ¤)

1. ëŒ€ì—­í­: 2Mbps
2. íŒ¨í‚· ë“œë¡­: 0%
3. ë”œë ˆì´ 5ms

ë„¤íŠ¸ì›Œí¬ ì´ë¡ ì— ë”°ë¼ ì´ë¯¸ì§€ íŒ¨í‚·ì´ ë‹¤ìš´ë§í¬ë¥¼ ë”°ë¼ ì „ì†¡ë˜ëŠ” ì‹œê°„ì„ ê³„ì‚°í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤. ë”œë ˆì´ëŠ” ë¬´ì‹œí•´ë„ ë˜ëŠ” ì •ë„ì˜ ìˆ˜ì¹˜ë¼ ê³„ì‚°ì—ì„œ ì œì™¸í•˜ì˜€ìŠµë‹ˆë‹¤.

$$
time_{transmission}=\frac{data(Mbps)}{bandwidth}
$$

$$
time_{transmission}=\frac{0.12MB}{2Mbps} + \frac{0.30MB}{2Mbps} + \frac{1.11MB}{2Mbps}
$$

$$
\frac{0.12 \times 8 (Mbit)}{2Mbps} + \frac{0.30 \times 8 (Mbit)}{2Mbps} + \frac{1.11 \times 8 (Mbit) }{2Mbps} = 0.48s + 1.2s + 4.44s = 6.12s
$$

ê·¸ë ‡ë‹¤ë©´ ì‹¤ì œë¡œ ì»¨í…ì¸  ë‹¤ìš´ë¡œë“œê¹Œì§€ ê±¸ë¦¬ëŠ” ì‹œê°„ì„ ê³„ì‚°í•´ë³¼ê¹Œìš”? ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì‹œê°„ ì¸¡ì •ê³¼ ì´ë¯¸ì§€ ì‚¬ì´ì¦ˆë¥¼ ì¶œë ¥í•œ ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```text
processingTime: 1.971391458 seconds
MEGA: 0.11989974975585938

processingTime: 5.402707917 seconds
MEGA: 0.2960662841796875

processingTime: 6.923137832999999 seconds
MEGA: 1.0994071960449219
```

ìœ„ì™€ ê°™ì´ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œì— ì†Œìš”ë˜ëŠ” ì‹œê°„ì„ ì¶œë ¥í•˜ê¸° ìœ„í•´ ì„ íƒí•œ ë°©ë²•ì€ `retrieveImage`í•¨ìˆ˜ì˜ `progressBlock`í´ë¡œì €ë¥¼ í™œìš©í•˜ëŠ” ê²ƒì´ì—ˆìŠµë‹ˆë‹¤. í•´ë‹¹ í•¨ìˆ˜ëŠ” ì»¨í…ì¸  ë‹¤ìš´ë¡œë“œ ê³¼ì •ì—ì„œ Foundation Frameworkì˜ `urlSession`í•¨ìˆ˜ í˜¸ì¶œì„ í†µí•´ í˜„ì¬ ë‹¤ìš´ë¡œë“œëœ ì»¨í…ì¸  ì‚¬ì´ì¦ˆ, ì „ì²´ ì»¨í…ì¸  ì‚¬ì´ì¦ˆë¥¼ í•¨ìˆ˜ íŒŒë¼ë¯¸í„°ë¡œ ì œê³µí•©ë‹ˆë‹¤.

ì´ í•¨ìˆ˜ê°€ í˜¸ì¶œ ì‹œì‘ëœ ì‹œì ë¶€í„° ìµœì¢… ì»¨í…ì¸ ê°€ ë¦¬í„´ë˜ê¸°ê¹Œì§€ì˜ ì‹œìŠ¤í…œ ì‹œê°„ì„ `ContinousClock` APIë¥¼ í™œìš©í•˜ì—¬ ì¸¡ì •í•˜ì˜€ìŠµë‹ˆë‹¤. ì „ì²´ ì½”ë“œë¥¼ ì•Œì•„ë³´ê¸° ì „ `progressBlock`í´ë¡œì €ê°€ í˜¸ì¶œë˜ëŠ” ê³¼ì •ì„ ìì„¸íˆ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.

## progressBlock í´ë¡œì € ë™ì‘ ì´í•´í•˜ê¸°

`KingfisherManager.shared.retrieveImage` í•¨ìˆ˜ëŠ” íŒŒë¼ë¯¸í„°ë¡œ `progressBlock` í´ë¡œì €ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `progressBlock`í´ë¡œì €ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë‚´ë¶€ì ìœ¼ë¡œ í˜¸ì¶œë©ë‹ˆë‹¤.

```swift
func retrieveImage(
    with source: Source,
    options: KingfisherParsedOptionsInfo,
    progressBlock: DownloadProgressBlock? = nil,
    downloadTaskUpdated: DownloadTaskUpdatedBlock? = nil,
    completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask?
{
    var info = options
    if let block = progressBlock {
        info.onDataReceived = (info.onDataReceived ?? []) + [ImageLoadingProgressSideEffect(block)]
    }
    return retrieveImage(
        with: source,
        options: info,
        downloadTaskUpdated: downloadTaskUpdated,
        progressiveImageSetter: nil,
        completionHandler: completionHandler)
}
```

`options` ë³€ìˆ˜ì˜ íƒ€ì…ì€ `KingfisherParsedOptionsInfo`ì…ë‹ˆë‹¤. `public struct`ë¡œ ì„ ì–¸ë˜ì–´ ìˆê³  `retrieveImage`í•¨ìˆ˜ `options`íŒŒë¼ë¯¸í„°ì— ì „ë‹¬ë˜ëŠ” ê°’ì…ë‹ˆë‹¤. êµ¬ì¡°ì²´ ë‚´ë¶€ë¥¼ ë³´ë©´ `public`ìœ¼ë¡œ ì„ ì–¸ëœ ì˜µì…˜ í”„ë¡œí¼í‹°ë“¤ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

`onDataReceived` í”„ë¡œí¼í‹°ëŠ” `public`ìœ¼ë¡œ ì„ ì–¸ë˜ì–´ ìˆì§€ ì•Šì•„ ì™¸ë¶€ì—ì„œ ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. `progressBlock` í´ë¡œì €ê°€ ì •ì˜ë˜ì–´ ìˆëŠ” ê²½ìš° `ImageLoadingProgressSideEffect` ìƒì„±ìì— ì „ë‹¬ë˜ë©° `onDataReceived` ê°’ì´ ì •ì˜ë©ë‹ˆë‹¤.

```swift
/// parsed and converted to a `KingfisherParsedOptionsInfo` first, and pass through the internal methods.
public struct KingfisherParsedOptionsInfo {

    // public var ì˜µì…˜ë“¤ ...
    // public var ì˜µì…˜ë“¤ ...
    // public var ì˜µì…˜ë“¤ ...

    var onDataReceived: [DataReceivingSideEffect]? = nil

    // ...
}
```

í‚¹í”¼ì…” ì˜µì…˜ ê°ì²´ì˜ `onDataReceived`ëŠ” `[DataReceivingSideEffect]`íƒ€ì…ìœ¼ë¡œ ì„ ì–¸ë˜ì–´ ìˆìŠµë‹ˆë‹¤. `DataReceivingSideEffect`ëŠ” í”„ë¡œí† ì½œì´ë©° 1ê¸‰ ê°ì²´ë¡œì„œ ì—­í• ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```swift
protocol DataReceivingSideEffect: AnyObject {
    var onShouldApply: () -> Bool { get set }
    func onDataReceived(_ session: URLSession, task: SessionDataTask, data: Data)
}
```

ìœ„ í”„ë¡œí† ì½œì„ ì±„íƒí•˜ì—¬ êµ¬í˜„í•œ í´ë˜ìŠ¤ëŠ” `ImageLoadingProgressSideEffect`ì…ë‹ˆë‹¤.

```swift
class ImageLoadingProgressSideEffect: DataReceivingSideEffect {

    var onShouldApply: () -> Bool = { return true }

    let block: DownloadProgressBlock

    init(_ block: @escaping DownloadProgressBlock) {
        self.block = block
    }

    func onDataReceived(_ session: URLSession, task: SessionDataTask, data: Data) {
        guard self.onShouldApply() else { return }
        guard let expectedContentLength = task.task.response?.expectedContentLength,
                  expectedContentLength != -1 else
        {
            return
        }

        let dataLength = Int64(task.mutableData.count)
        DispatchQueue.main.async {
            self.block(dataLength, expectedContentLength)
        }
    }
}
```

ìœ„ì˜ í˜•íƒœë¡œ ì •ì˜ëœ í•¨ìˆ˜ ì¤‘ `onDataReceived`ê°€ í˜¸ì¶œë¨ì— ë”°ë¼ HTTP bodyì˜ content-lengthê°€ ê³„ì‚°ë˜ê³  `progressBlock` í´ë¡œì €ê°€ ì‹¤í–‰ë˜ëŠ” ê²ƒì…ë‹ˆë‹¤. (`self.block(dataLength, expectedContentLength)`)

ì‚¬ì´ë“œì´í™íŠ¸ í”„ë¡œí† ì½œì„ ì±„íƒí•˜ì—¬ `onDataReceived` êµ¬í˜„í–ˆëŠ”ë°, ê·¸ë ‡ë‹¤ë©´ ì´ í•¨ìˆ˜ê°€ ì§ì ‘ í˜¸ì¶œë˜ì–´ì•¼ í•˜ì§€ ì•Šì„ê¹Œìš”? í•¨ìˆ˜ê°€ ì–´ë””ì„œ í˜¸ì¶œë˜ëŠ”ì§€ ì•Œì•„ë³´ê¸° ìœ„í•´ì„œëŠ” ë‹¤ì‹œ `SessionDelegate`ë¡œ ì´ë™í•´ì•¼ í•©ë‹ˆë‹¤.

`SessionDelegate`ëŠ” í‚¹í”¼ì…” ë¼ì´ë¸ŒëŸ¬ë¦¬ë§Œì˜ ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬ ë°©ì‹ì„ ì •ì˜í•´ë‘” í´ë˜ìŠ¤ì…ë‹ˆë‹¤. `URLSessionDataDelegate`í”„ë¡œí† ì½œì„ ì±„íƒí•œ ë’¤ ë‚´ë¶€ì ìœ¼ë¡œ í˜¸ì¶œë˜ëŠ” ê°ì¢… í•¨ìˆ˜ë“¤ì˜ êµ¬í˜„ë¶€ë¥¼ ì •ì˜í•´ë‘ì—ˆìŠµë‹ˆë‹¤.

ì´ ì¤‘ `urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)`ë¥¼ ì‚´í´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

```swift
extension SessionDelegate: URLSessionDataDelegate {
    open func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
        guard let task = self.task(for: dataTask) else {
            return
        }

        task.didReceiveData(data)

        task.callbacks.forEach { callback in
            callback.options.onDataReceived?.forEach { sideEffect in
                sideEffect.onDataReceived(session, task: task, data: data)
            }
        }
    }
}
```

```swift
public protocol URLSessionDataDelegate : URLSessionTaskDelegate {
    optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)
}
```

ìœ„ í•¨ìˆ˜ëŠ” `URLSessionDataDelegate` í”„ë¡œí† ì½œì˜ ì˜µì…”ë„ íƒ€ì…ìœ¼ë¡œ ì„ ì–¸ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì„ íƒì  êµ¬í˜„ ëŒ€ìƒì…ë‹ˆë‹¤.

ë„¤íŠ¸ì›Œí¬ í†µì‹  ê³¼ì •ì—ì„œ ë‚´ë¶€ì ìœ¼ë¡œ `urlSession`í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ëŠ”ë° ì´ë•Œ ì „ë‹¬ë˜ëŠ” `dataTask`ê°€ í‚¹í”¼ì…”ì—ì„œ ì‚¬ìš©ë˜ëŠ” `SessionDataTask` ì¸ìŠ¤í„´ìŠ¤ë¡œ ë˜í•‘ë©ë‹ˆë‹¤.

`SessionDataTask` ì¸ìŠ¤í„´ìŠ¤ì—ëŠ” `callbacks` ì†ì„±ì´ ì¡´ì¬í•©ë‹ˆë‹¤.

```swift
public class SessionDataTask {
    var callbacks: [SessionDataTask.TaskCallback] {
        lock.lock()
        defer { lock.unlock() }
        return Array(callbacksStore.values)
    }

    // ...

    func addCallback(_ callback: TaskCallback) -> CancelToken {
        lock.lock()
        defer { lock.unlock() }
        callbacksStore[currentToken] = callback
        defer { currentToken += 1 }
        return currentToken
    }
}
```

`callbacks` ë°°ì—´ì€ `addCallback`í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´ì„œ ìš”ì†Œë“¤ì´ ë‚´ë¶€ì— appendë©ë‹ˆë‹¤. `addCallback`í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ëŠ” ì‹œì ì€ `ImageDownloader`ë¥¼ í†µí•´ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œê°€ ì‹œì‘ëœ ì´í›„ë¡œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.

```swift
open class ImageDownloader  {

    // ...

    private func addDownloadTask(
        context: DownloadingContext,
        callback: SessionDataTask.TaskCallback
    ) -> DownloadTask
    {
        // Ready to start download. Add it to session task manager (`sessionHandler`)
        let downloadTask: DownloadTask
        if let existingTask = sessionDelegate.task(for: context.url) {
            downloadTask = sessionDelegate.append(existingTask, callback: callback)
        } else {
            let sessionDataTask = session.dataTask(with: context.request)
            sessionDataTask.priority = context.options.downloadPriority
            downloadTask = sessionDelegate.add(sessionDataTask, url: context.url, callback: callback)
        }
        return downloadTask
    }
}
```

`ImageDownloader`ê°ì²´ì—ì„œ `addDownloadTask`í•¨ìˆ˜ê°€ í˜¸ì¶œì€ `private func startDownloadTask(context:  DownloadingContext, callback: SessionDataTask.TaskCallback) -> DownloadTask` í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.

`startDownloadTask` í•¨ìˆ˜ëŠ” ë˜ ë‹¤ì‹œ `downloadImage`í•¨ìˆ˜ë¡œ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°€ê³ , ìµœì¢…ì ìœ¼ë¡œ `retrieveImage`í•¨ìˆ˜ ë‚´ì—ì„œ `loadAndCacheImage` í•¨ìˆ˜ í˜¸ì¶œì˜ `.network`ì¼€ì´ìŠ¤ì—ì„œ ë³¸ê²©ì ì¸ íƒœìŠ¤í¬ ìƒì„±ê³¼ ì¶”ê°€ì˜ ì‘ì—…ì´ ì§„í–‰ë©ë‹ˆë‹¤.

:::tip í˜¸ì¶œê³¼ì • ì´í•´í•˜ê¸°

ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ íƒœìŠ¤í¬ê°€ ì¶”ê°€ë˜ëŠ” ê³¼ì •ì„ ì´í•´í•˜ê¸° ìœ„í•´ì„œëŠ” ìºì‹œ ì ‘ê·¼ì„ ìœ„í•œ `retrieveImage`í•¨ìˆ˜ í˜¸ì¶œê³¼ ë„¤íŠ¸ì›Œí¬ í†µì‹ ì´ ì´ë£¨ì–´ì§€ëŠ” ë‘ ê°€ì§€ ë°©í–¥ì„±ì„ ì´í•´í•´ì•¼ í•©ë‹ˆë‹¤.

ë¨¼ì € `retrieveImage`ì—ì„œ ìºì‹œ ì €ì¥ì†Œì— ì ‘ê·¼í•˜ê³  ìºì‹œ ë¯¸ìŠ¤ê°€ ë°œìƒí•œ ê²½ìš° `retrieveImage` ì¬ê·€ í˜¸ì¶œ íŒ¨í„´ì˜ ë§ë¯¸ì— ìˆëŠ” `loadAndCacheImage` í•¨ìˆ˜ê°€ í˜¸ì¶œë©ë‹ˆë‹¤. ì´ë•Œ `cacheOnly`ì™€ ê°™ì€ ì˜µì…˜ì´ ì§€ì •ë˜ì–´ ìˆì§€ ì•Šì€ ê²½ìš° `.network` ì¼€ì´ìŠ¤ë¡œ ë¶„ë¥˜ë˜ì–´ ë„¤íŠ¸ì›Œí¬ í†µì‹ ì„ ì§„í–‰í•©ë‹ˆë‹¤.

ì´ë•Œ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ íƒœìŠ¤í¬ëŠ” `ImageDownloader`ë¼ëŠ” í‚¹í”¼ì…”ì˜ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ë§¤ë‹ˆì € í´ë˜ìŠ¤ë¥¼ í†µí•´ ì§„í–‰ë©ë‹ˆë‹¤.

```swift
switch source {
case .network(let resource):
    let downloader = options.downloader ?? self.downloader
    let task = downloader.downloadImage(
        with: resource.downloadURL, options: options, completionHandler: _cacheImage
    )
    // ...
}
```

`self.downloader`í”„ë¡œí¼í‹°ë¥¼ í†µí•´ ë‹¤ìš´ë¡œë“œ íƒœìŠ¤í¬ ìƒì„±ì´ ì´ë£¨ì–´ì§€ê²Œ ë©ë‹ˆë‹¤. ì´ë•Œ ìƒì„±ë˜ëŠ” íƒœìŠ¤í¬ê°€ ë°”ë¡œ í‚¹í”¼ì…”ì˜ `SessionDataTask` ì˜¤ë¸Œì íŠ¸ì´ë©°, ë™ì‹œì— `Foundation`í”„ë ˆì„ì›Œí¬ì—ì„œ ìë™ìœ¼ë¡œ í˜¸ì¶œë˜ëŠ” `urlSession - didReceive`í•¨ìˆ˜ í˜¸ì¶œê³¼ ë§ë¬¼ë ¤ ìµœì¢…ì ìœ¼ë¡œ `onDataReceived` í´ë¡œì €ì—ì„œ `progressBlock` í˜¸ì¶œì´ ì´ë£¨ì–´ì§€ëŠ” ê²ƒì…ë‹ˆë‹¤.

```swift
open func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
    guard let task = self.task(for: dataTask) else {
        return
    }

    task.didReceiveData(data)

    // SessionDataTask
    task.callbacks.forEach { callback in
        callback.options.onDataReceived?.forEach { sideEffect in
            sideEffect.onDataReceived(session, task: task, data: data)
        }
    }
}
```

:::

ì „ì²´ í˜¸ì¶œ ê³¼ì •ì„ ë„ì‹í™”í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤. `progressBlock`í´ë¡œì €ê°€ ì‹¤í–‰ë˜ê¸°ê¹Œì§€ì˜ ê³¼ì •ì„ ì—¼ë‘ì— ë‘ê³  ì´í•´í•˜ë©´ ì¢‹ìŠµë‹ˆë‹¤.

![47-1](../.vuepress/assets/snack/47-1.jpg)

## ë‹¤ìš´ë¡œë“œ ì†Œìš” ì‹œê°„ ë¹„êµ (ì´ë¡  vs ì‹¤ì œ ê°’)

ìœ„ì—ì„œ ì´ë¡ ì ì¸ ê³µì‹ì— ë”°ë¼ ë„ì¶œí•œ ì»¨í…ì¸  ë‹¤ìš´ë¡œë“œ ì†Œìš” ì‹œê°„ì€ ì´ 6.12ì´ˆì˜€ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì‹¤ì œ ì´ ì†Œìš”ì‹œê°„ì€ ì•½ 14.29ì´ˆë¡œ ë¬´ì‹œí•˜ê¸°ì—ëŠ” ë„ˆë¬´ í° ì˜¤ì°¨ê°€ ë°œìƒí•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

```text
processingTime: 1.971391458 seconds
MEGA: 0.11989974975585938

processingTime: 5.402707917 seconds
MEGA: 0.2960662841796875

processingTime: 6.923137832999999 seconds
MEGA: 1.0994071960449219
```

ë„¤íŠ¸ì›Œí¬ ë§í¬ ì»¨ë””ì…”ë„ˆë¥¼ í†µí•´ ë¶„ëª… ë‹¤ìš´ë¡œë“œ ì†ë„ë¥¼ ê³ ì •í–ˆìŒì—ë„ ì™œ ì´ë ‡ê²Œ í° ì˜¤ì°¨ê°€ ë°œìƒí• ê¹Œìš”? ì´ì— ëŒ€í•œ ì›ì¸ë“¤ì„ ëª‡ ê°€ì§€ë¡œ ë‚˜ëˆ„ì–´ ê²€ì¦í•´ë³´ì•˜ìŠµë‹ˆë‹¤.

## ì›ì¸ 1. Thread-safeí•œ ì½”ë“œê°€ ì•„ë‹Œê°€?

ì½”ë“œ ì‹¤í–‰ì‹œê°„ì„ ì¸¡ì •í•˜ëŠ” ì½”ë“œë¥¼ ì•„ë˜ì™€ ê°™ì´ ì‘ì„±í–ˆì—ˆìŠµë‹ˆë‹¤.

```swift
KingfisherManager.shared.retrieveImage(with: url, options: []) { [weak self] processingSize, totalSize in
    guard let self = self else { return }

    if self.dict[url.absoluteString] != nil {
        self.dict[url.absoluteString]?.append(self.clock.now)
    } else {
        self.dict[url.absoluteString] = [self.clock.now]
    }

} completionHandler: { downloadResult in
    switch downloadResult {
    case .success(let downloaded):
        print("processingTime: \(self.dict[url.absoluteString]!.first!.duration(to: self.dict[url.absoluteString]!.last!))")
    case .failure(let error):
        print("error in first: ", error)
        return
    }
}
```

ìœ„ ì½”ë“œë¥¼ ë³´ë©´ ë ˆíŒŒì§€í† ë¦¬ ê°ì²´ì— `dict`ë¼ëŠ” ë”•ì…”ë„ˆë¦¬ ì†ì„±ì„ ë§ˆë ¨í•œ ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í¬ì¦ˆí”¼ë“œ íŠ¹ì„± ìƒ 8ê°œ ì»¨í…ì¸ ê°€ ì €ì¥ëœ S3 URLì„ ìˆœíšŒí•˜ë©° ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œê°€ ì§„í–‰ë˜ê¸° ë•Œë¬¸ì—, ê° URLì„ í‚¤ê°’ìœ¼ë¡œ ê°€ì§€ë©° `progressBlock`ì´ ì‹¤í–‰ë˜ëŠ” ì‹œì ë§ˆë‹¤ `.now`ì‹œê°„ì„ ë”•ì…”ë„ˆë¦¬ ë°¸ë¥˜ì— `append`í•´ì£¼ì—ˆìŠµë‹ˆë‹¤.

ì´ë•Œ ë³„ë‹¤ë¥¸ `sync`ë©”ì„œë“œ ì—†ì´ë„ Thread-safeí•œì§€ íŒë‹¨ì´ í•„ìš”í•œë°, ì œê°€ ë‚´ë¦° ê²°ë¡ ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

1. `retrieveImage`í•¨ìˆ˜ í˜¸ì¶œ ì´í›„ ì„¸ì…˜ ê°ì²´ë¥¼ í†µí•œ ì»¨í…ì¸  ë‹¤ìš´ë¡œë“œ íƒœìŠ¤í¬ëŠ” ì§ë ¬ íì—ì„œ ì´ë£¨ì–´ì§„ë‹¤. (ì„¸ì…˜ ê°ì²´ ìƒì„±ì‹œ delegateQueue íŒŒë¼ë¯¸í„°ì— nil ì „ë‹¬ë¨)
2. ì§ë ¬ íì—ì„œ ì‘ì—…ì´ ì´ë£¨ì–´ì§€ê³  URL ê¸°ì¤€ìœ¼ë¡œ í•´ì‹œí•˜ì—¬ ì ‘ê·¼í•˜ê¸° ë•Œë¬¸ì— URLì˜ ì‘ì—… ìˆ˜í–‰ ì‹œê°„ì´ ì„œë¡œ ì–½í ì¼ì€ ì—†ë‹¤.

ê°„ë‹¨íˆ ë„ì‹í™” í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

![47-2](../.vuepress/assets/snack/47-2.jpeg)

`progressBlock`í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ëŠ” í™˜ê²½ì´ ë©€í‹°ìŠ¤ë ˆë“œê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì— ìœ„ ì½”ë“œëŠ” `Thread-safe` í•˜ë‹¤ê³  ê²°ë¡  ë‚´ë¦´ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

## ì›ì¸ 2. ë„¤íŠ¸ì›Œí¬ í™˜ê²½ì˜ ë³€ìˆ˜

ê·¸ë ‡ë‹¤ë©´ ë‚¨ì€ ì›ì¸ì€ ë„¤íŠ¸ì›Œí¬ í†µì‹  ê³¼ì •ì—ì„œ í†µì œí•˜ì§€ ëª»í•œ í™˜ê²½ì  ë³€ìˆ˜ë“¤ë°–ì— ì›ì¸ì´ ì—†ë‹¤ê³  ê²°ë¡  ì§“ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ë¥¼ ì‹¤ì œë¡œ ê²€ì¦í•˜ê¸° ìœ„í•´ `Charles Proxy`ë¼ëŠ” íˆ´ì„ ì‚¬ìš©í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.
