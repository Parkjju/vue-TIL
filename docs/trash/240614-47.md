---
title: Snack 47호 - Kingfisher 코드 뜯어보기
tags: ['Snack', 'Kingfisher', 'Concurrency', '포즈피커 개발 이야기']
---

프로젝트 포즈피커 개발 이야기입니다! 궁금하시다면 놀러와주세요 :) [[포즈피커 다운받기🔗]](https://apps.apple.com/kr/app/%ED%8F%AC%EC%A6%88%ED%94%BC%EC%BB%A4-%EB%84%A4%EC%BB%B7%EC%82%AC%EC%A7%84-%ED%8F%AC%EC%A6%88%EC%B6%94%EC%B2%9C/id6474260471)

## 개요

킹피셔는 이미지를 캐싱 처리를 도와주는 라이브러리입니다. 디스크 혹은 메모리 캐시 접근을 지원하고 캐시 미스가 발생한 경우 내부적으로 네트워크를 통한 다운로드 비동기 태스크까지 진행해주는 편리한 라이브러리입니다.

이번 글에서는 메모리 캐시, 디스크 캐시, 캐시 miss시 발생하는 성능 차이를 비교하고 어떻게 활용하면 좋을지 고민하는 과정을 소개해보겠습니다.

## 킹피셔 retrieveImage 함수

킹피셔에서는 `retrieveImage`라는 함수를 제공합니다. 해당 함수는 파라미터에 전달된 키 문자열 값을 기준으로 디스크 해시를 진행합니다. 만약 캐시 저장소에 데이터가 존재한 경우 **캐시 히트**가 발생하여 `completionHandler` 콜백의 `Result`타입 파라미터가 `success` 케이스로 분류됩니다. 반대로 데이터가 존재하지 않은 경우 **캐시 미스**가 발생하여 `completionHandler` 콜백의 `Result` 타입 파라미터가 `failure` 케이스로 분류됩니다.

이때, 캐시 미스가 발생하여 `failure`케이스로 분류되었을 때 내부적으로 네트워크를 통해 이미지 다운로드를 진행하고 다운로드된 이미지를 캐시에 저장하는 역할을 바로 `KingfisherManager.shared.retrieveImage`가 진행합니다.

이러한 흐름을 이해하고 내부 코드를 간단히 뜯어보도록 하겠습니다.

## 1. ImageCache.default.retrieveImage 뜯어보기

내부 코드를 뜯어보면 다음과 같습니다.

```swift
open func retrieveImage(
        forKey key: String,
        options: KingfisherParsedOptionsInfo,
        callbackQueue: CallbackQueue = .mainCurrentOrAsync,
        completionHandler: ((Result<ImageCacheResult, KingfisherError>) -> Void)?)
    {
        // No completion handler. No need to start working and early return.
        guard let completionHandler = completionHandler else { return }

        // Try to check the image from memory cache first.
        if let image = retrieveImageInMemoryCache(forKey: key, options: options) {
            callbackQueue.execute { completionHandler(.success(.memory(image))) }
        } else if options.fromMemoryCacheOrRefresh {
            callbackQueue.execute { completionHandler(.success(.none)) }
        } else {

            // Begin to disk search.
            self.retrieveImageInDiskCache(forKey: key, options: options, callbackQueue: callbackQueue) {
                result in
                switch result {
                case .success(let image):

                    guard let image = image else {
                        // No image found in disk storage.
                        callbackQueue.execute { completionHandler(.success(.none)) }
                        return
                    }
                    // ... 나머지 코드
                case .failure(let error):
                    callbackQueue.execute { completionHandler(.failure(error)) }
                }
            }
        }
    }
```

위 코드의 주요 흐름을 정리하면 다음과 같습니다.

1. `completionHandler` 클로저 전달 유무에 따라 코드 실행 여부가 결정됩니다. early-return 패턴으로 함수가 조기 종료됩니다.
2. `retrieveImageInMemoryCache`: 메모리 캐시 접근을 먼저 진행합니다. 캐시 히트가 발생한 경우 `success` 케이스를 리턴하고 종료합니다.
3. `fromMemoryCacheOrRefresh`: 해당 옵션이 지정되어 있는 경우에만 코드가 실행되며, 메모리 캐시 접근 시도 후 캐시 미스가 발생하면 디스크 캐시에 접근합니다. 디스크 캐시에서도 캐시 미스가 발생한 경우 별도의 네트워크를 통한 이미지 다운로드는 처리하지 않습니다.
4. 아무 옵션도 지정되지 않고, 메모리 캐시도 미스난 경우 디스크 캐시에 접근합니다.
5. 킹피셔 에러가 발생한 경우 에러를 `Result`에 담아 콜백을 호출하고, 만약 디스크 캐시까지 미스난 경우 `.none`열거형 값을 콜백에 담아 리턴합니다. **.none**은 에러가 아님에 주의해야 합니다.
