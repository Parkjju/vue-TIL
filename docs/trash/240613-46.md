---
title: Snack 46í˜¸ - ë°˜ì‘í˜•ìœ¼ë¡œ UX ê°œì„ í•˜ê¸°
tags: ['Snack', 'UI/UX', 'RxSwift', 'í¬ì¦ˆí”¼ì»¤ ê°œë°œ ì´ì•¼ê¸°']
---

í”„ë¡œì íŠ¸ í¬ì¦ˆí”¼ì»¤ ê°œë°œ ì´ì•¼ê¸°ì…ë‹ˆë‹¤! ê¶ê¸ˆí•˜ì‹œë‹¤ë©´ ë†€ëŸ¬ì™€ì£¼ì„¸ìš” :) [[í¬ì¦ˆí”¼ì»¤ ë‹¤ìš´ë°›ê¸°ğŸ”—]](https://apps.apple.com/kr/app/%ED%8F%AC%EC%A6%88%ED%94%BC%EC%BB%A4-%EB%84%A4%EC%BB%B7%EC%82%AC%EC%A7%84-%ED%8F%AC%EC%A6%88%EC%B6%94%EC%B2%9C/id6474260471)

## ê¸°ì¡´ ì½”ë“œ

![39-1](../.vuepress/assets/snack/39-1.gif)

UIì— ì´ë¯¸ì§€ë“¤ì´ ë°”ì¸ë”© ë˜ê¸°ê¹Œì§€ì˜ íë¦„ì„ ì •ë¦¬í•´ë³´ê² ìŠµë‹ˆë‹¤. ê°€ì¥ ë¨¼ì € í¬ì¦ˆí”¼ë“œ ë·° ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ `viewDidLoad` í˜¸ì¶œ ì‹œ í¬ì¦ˆí”¼ë“œ ë·°ëª¨ë¸ì— ì¸í’‹ ì´ë²¤íŠ¸ê°€ ì „ë‹¬ë©ë‹ˆë‹¤.

```swift
final class PoseFeedViewModel {

    struct Input {
        let viewDidLoadEvent: Observable<Void>
        // ...
    }

    struct Output {
        let contents = PublishRelay<[Section<PoseFeedPhotoCellViewModel>]>()
        /// ...
    }

    func transform(input: Input, disposeBag: DisposeBag) -> Output {
        let output = Output()

        /// 1. viewDidLoad ì´í›„ ì´ˆê¸° ë°ì´í„° ìš”ì²­
        input.viewDidLoadEvent
            .subscribe(onNext: { [weak self] in
                self?.posefeedUseCase.fetchFeedContents()
            })
            .disposed(by: disposeBag)

        // ì¤‘ëµ

        self.posefeedUseCase
            .feedContents
            .subscribe(onNext: {
                output.contents.accept($0)
            })
            .disposed(by: disposeBag)
    }
}
```

ë·°ëª¨ë¸ì— ì¸í’‹ ë°ì´í„°ê°€ ì „ë‹¬ë¨ê³¼ ë™ì‹œì— ìœ ìŠ¤ì¼€ì´ìŠ¤ - ë ˆíŒŒì§€í† ë¦¬ë¥¼ ê±°ì³ í”¼ë“œì— ë°”ì¸ë”© í•  ë°ì´í„°ë¥¼ ìš”ì²­í•©ë‹ˆë‹¤. JSON ë””ì½”ë”© í›„ êµ¬ì¡°ì²´ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë° ì»¬ë ‰ì…˜ë·° ì…€ ë·°ëª¨ë¸ì„ ìƒì„±í•©ë‹ˆë‹¤.

êµ¬ì¡°ì²´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ” ì½”ë“œë¥¼ ë” ìì„¸íˆ ëœ¯ì–´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

```swift
final class DefaultPoseFeedRepository: PoseFeedRepository {
    let networkService: NetworkService

    init(networkService: NetworkService) {
        self.networkService = networkService
    }

    func fetchFeedContents() -> Observable<[Section<PoseFeedPhotoCellViewModel>]> {
        networkService
            .requestSingle(.retrieveFilteringPoseFeed(peopleCount: peopleCount, frameCount: frameCount, filterTags: filterTags, pageNumber: pageNumber))
            .asObservable()
            .withUnretained(self)
            .flatMapLatest { (owner, filteredContents: FilteredPose) -> Observable<[Section<PoseFeedPhotoCellViewModel>]> in
                return Observable.combineLatest(
                    owner.cacheItem(for: filteredContents.filteredContents),
                    owner.cacheItem(for: filteredContents.recommendedContents)
                )
                .flatMapLatest { filterSection, recommendSection in
                    let relay = BehaviorRelay<[Section<PoseFeedPhotoCellViewModel>]>(value: [
                        Section(header: "", items: filterSection),
                        Section(header: "ì´ëŸ° í¬ì¦ˆëŠ” ì–´ë•Œìš”?", items: recommendSection)
                    ])

                    return relay.asObservable()
                }
            }
    }

    private func cacheItem(for contents: [Pose]) -> Observable<[PoseFeedPhotoCellViewModel]> {
        let viewModelObservable = BehaviorRelay<[PoseFeedPhotoCellViewModel]>(value: [])

        contents.forEach { pose in
            ImageCache.default.retrieveImageInDiskCache(forKey: pose.poseInfo.imageKey) { result in
                switch result {
                case .success(let value):
                    if let image = value?.images?.first {
                        let viewModel = PoseFeedPhotoCellViewModel(image: image)
                        viewModelObservable.accept(viewModelObservable.value + [viewModel])
                    } else if let url = URL(string: pose.poseInfo.imageKey) {
                        KingfisherManager.shared.retrieveImage(with: url) { downloadResult in
                            switch downloadResult {
                            case .success(let downloaded):
                                let viewModel = PoseFeedPhotoCellViewModel(image: downloaded.image)
                                viewModelObservable.accept(viewModelObservable.value + [viewModel])
                            case .failure(let error):
                                print("error in first: ", error)
                                return
                            }
                        }
                    }
                case .failure:
                    return
                }
            }
        }

        return viewModelObservable.skip(while: { $0.count < contents.count }).asObservable()
    }
}
```

ë¨¼ì € í˜ì´ì§€ë„¤ì´ì…˜ì´ ì ìš©ëœ ì„œë²„ë¡œë¶€í„° í¬ì¦ˆ ì •ë³´ë¥¼ 8ê°œì”© ë¬¶ì–´ì„œ ì „ë‹¬ë°›ìŠµë‹ˆë‹¤. ê° í¬ì¦ˆì—ëŠ” ì´ë¯¸ì§€ê°€ ì €ì¥ëœ S3 ë²„í‚· URL ì •ë³´ê°€ ë‹´ê²¨ìˆìŠµë‹ˆë‹¤.

JSON ë””ì½”ë”©ì„ ë§ˆì³ URL ê°’ì„ ë¶ˆëŸ¬ì™”ë‹¤ë©´, 8ê°œ ì´ë¯¸ì§€ URLì„ í‚¤ê°’ìœ¼ë¡œ í•˜ì—¬ ìºì‹œ ì ‘ê·¼ì„ ì§„í–‰í•©ë‹ˆë‹¤. **ìºì‹œ íˆíŠ¸ì¸ ê²½ìš°** ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ UIImage ê°ì²´ë¡œ ë¡œë“œí•˜ì—¬ ë·°ëª¨ë¸ì„ ìƒì„±í•´ì¤€ë‹¤. **ìºì‹œ ë¯¸ìŠ¤ì¸ ê²½ìš°** ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.

ìœ„ ë™ì‘ì´ `cacheItem`í•¨ìˆ˜ì—ì„œ ì´ë£¨ì–´ì§€ëŠ”ë°, í•´ë‹¹ í•¨ìˆ˜ëŠ” í´ë¡œì €ë¥¼ í†µí•´ ìºì‹œ ì ‘ê·¼ê³¼ ê´€ë ¨ëœ ë¹„ë™ê¸° ì‘ì—…ë“¤ì„ ì§„í–‰í•©ë‹ˆë‹¤. ì¤‘ì²© í´ë¡œì €ë¥¼ í†µí•´ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ íƒœìŠ¤í¬ê°€ ë˜ ë‹¤ë¥¸ íë¡œ ë°°ì¹˜ë©ë‹ˆë‹¤.

ì´ ëª¨ë“  ì‘ì—…ë“¤ì„ ë§ˆì¹  ë•Œê¹Œì§€ ì˜µì €ë²„ë¸”ì€ ë·°ëª¨ë¸ ë°ì´í„°ë¥¼ ë°©ì¶œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì¤‘ì²© í´ë¡œì €ì— ì „ë‹¬ë˜ëŠ” íŒŒë¼ë¯¸í„°ë¥¼ ìº¡ì²˜í•˜ê²Œ ë˜ëŠ”ë°, `Pose` ëª¨ë¸ ë°ì´í„°ê°€ êµ¬ì¡°ì²´ë¡œ ëª¨ë‘ ê°’ íƒ€ì…ì´ê¸° ë•Œë¬¸ì— ì§ì ‘ ì£¼ì†Œë¥¼ ì°¸ì¡°í•˜ê²Œ ë©ë‹ˆë‹¤.

í´ë¡œì € íŒŒë¼ë¯¸í„°ì˜ ì›ë³¸ì„ ê·¸ëŒ€ë¡œ ì°¸ì¡°í•˜ê³  ìˆì–´ì•¼ ë³€ê²½ë˜ëŠ” ë°ì´í„°ë¥¼ ê³„ì†í•´ì„œ ì°¸ì¡°í•˜ê²Œ ë©ë‹ˆë‹¤. `contents.forEach` í•¨ìˆ˜ í˜¸ì¶œ í›„ ìŠ¤íƒ í”„ë ˆì„ ë‚´ì— ì§€ì—­ë³€ìˆ˜ë¡œ í• ë‹¹ëœ `pose`ê°’ì˜ ì›ë³¸ì„ ê³„ì†í•´ì„œ ì°¸ì¡°í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

`forEach` í´ë¡œì € ìì²´ëŠ” ë™ê¸°ì ìœ¼ë¡œ ë™ì‘í•˜ëŠ” ì½”ë“œì´ê¸° ë•Œë¬¸ì— ì „ì²´ ë¹„ë™ê¸° íƒœìŠ¤í¬ë¥¼ í‚¹í”¼ì…”ì—ì„œ ìƒì„±í•œ `ioQueue`ì— í• ë‹¹í•©ë‹ˆë‹¤.

`retrieveImageInDiskCache` í´ë¡œì € í˜¸ì¶œ í›„ ì´ë¯¸ì§€ë¥¼ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ë‹¤ë©´ ì´ë¯¸ì§€ì™€ í•¨ê»˜ ìƒˆë¡œìš´ ë·°ëª¨ë¸ ê°ì²´ ìƒì„± í›„ í´ë¡œì €ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.

```swift
ioQueue = DispatchQueue(label: ioQueueName)
```

ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ioQueue ì½”ë“œë¥¼ ë³´ë©´ ê¸°ë³¸ì ìœ¼ë¡œ í ì–´íŠ¸ë¦¬ë·°íŠ¸ê°€ ì„¤ì •ë˜ì–´ ìˆì§€ ì•Šì€ ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤. ì†ì„±ê°’ì„ ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ ìë™ìœ¼ë¡œ ì§ë ¬ íê°€ ë©ë‹ˆë‹¤.

> attributes - Apple Document
> The attributes to associate with the queue. Include the concurrent attribute to create a dispatch queue that executes tasks concurrently. If you omit that attribute, the dispatch queue executes tasks serially.

ë”°ë¼ì„œ ë°”ê¹¥ í´ë¡œì €ì˜ `retrieveImageInDiskCache`ë¹„ë™ê¸° íƒœìŠ¤í¬ê°€ ioQueueì— í‘¸ì‹œë˜ê³ , ê·¸ ë‹¤ìŒ ë‚´ë¶€ í´ë¡œì €ê°€ ë™ì¼í•˜ê²Œ `ioQueue`ì— í‘¸ì‹œë©ë‹ˆë‹¤.

:::tip íƒœìŠ¤í¬ ì‹¤í–‰ë˜ê³  ìˆëŠ” í ì´ë¦„ ì¶œë ¥í•˜ê¸°

```swift
print(String(cString: __dispatch_queue_get_label(nil), encoding: .utf8))
```

:::

## ë¬¸ì œì 

ì§ë ¬ í ê¸°ë°˜ìœ¼ë¡œ ë™ì‘í•˜ê²Œ ë˜ë©´ì„œ ë·°ëª¨ë¸ skip ì˜¤í¼ë ˆì´í„°ê°€ ì ìš©ëœ ì˜µì €ë²„ë¸”ì˜ ì°¸ì¡°ê°€ ìµœì¢…ì ìœ¼ë¡œ ë¦¬í„´ë˜ëŠ”ë°, ì´ë•Œ ëª¨ë“  ì‘ì—…ì´ ìˆœì°¨ì ìœ¼ë¡œ ë§ˆë¬´ë¦¬ ë ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ê²Œ ë©ë‹ˆë‹¤.

8ê°œì˜ ì´ë¯¸ì§€ê°€ ìºì‹œ íˆíŠ¸ í˜¹ì€ ìºì‹œ ë¯¸ìŠ¤ ì´í›„ ë‹¤ìš´ë¡œë“œê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤ëŠ” ê²ƒì¸ë°, ë¡œë”© ì¸ë””ì¼€ì´í„°ë§Œ ë„ì›Œë†“ëŠ” ê²ƒì´ì§€ ì‚¬ì‹¤ìƒ ì‚¬ìš©ìì—ê²Œ ë¹„ë™ê¸°ì ì¸ ì´ì ì„ í•˜ë‚˜ë„ ì‚´ë¦¬ì§€ ëª»í•˜ê²Œ ë˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

## Reference

1. [Medium - How to simulate poor network conditions on iOS Simulator and iPhone](https://medium.com/macoclock/how-to-simulate-poor-network-conditions-on-ios-simulator-and-iphone-faf35f0da1b5)
2. [Apple Document - init(label:qos:attributes:autoreleaseFrequency:target:)](https://developer.apple.com/documentation/dispatch/dispatchqueue/2300059-init)
