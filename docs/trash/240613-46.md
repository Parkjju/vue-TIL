---
title: Snack 46호 - 반응형으로 UX 개선하기
tags: ['Snack', 'UI/UX', 'RxSwift', '포즈피커 개발 이야기']
---

프로젝트 포즈피커 개발 이야기입니다! 궁금하시다면 놀러와주세요 :) [[포즈피커 다운받기🔗]](https://apps.apple.com/kr/app/%ED%8F%AC%EC%A6%88%ED%94%BC%EC%BB%A4-%EB%84%A4%EC%BB%B7%EC%82%AC%EC%A7%84-%ED%8F%AC%EC%A6%88%EC%B6%94%EC%B2%9C/id6474260471)

## 기존 코드

![39-1](../.vuepress/assets/snack/39-1.gif)

UI에 이미지들이 바인딩 되기까지의 흐름을 정리해보겠습니다. 가장 먼저 포즈피드 뷰 컨트롤러에서 `viewDidLoad` 호출 시 포즈피드 뷰모델에 인풋 이벤트가 전달됩니다.

```swift
final class PoseFeedViewModel {

    struct Input {
        let viewDidLoadEvent: Observable<Void>
        // ...
    }

    struct Output {
        let contents = PublishRelay<[Section<PoseFeedPhotoCellViewModel>]>()
        /// ...
    }

    func transform(input: Input, disposeBag: DisposeBag) -> Output {
        let output = Output()

        /// 1. viewDidLoad 이후 초기 데이터 요청
        input.viewDidLoadEvent
            .subscribe(onNext: { [weak self] in
                self?.posefeedUseCase.fetchFeedContents()
            })
            .disposed(by: disposeBag)

        // 중략

        self.posefeedUseCase
            .feedContents
            .subscribe(onNext: {
                output.contents.accept($0)
            })
            .disposed(by: disposeBag)
    }
}
```

뷰모델에 인풋 데이터가 전달됨과 동시에 유스케이스 - 레파지토리를 거쳐 피드에 바인딩 할 데이터를 요청합니다. JSON 디코딩 후 구조체 인스턴스 생성 및 컬렉션뷰 셀 뷰모델을 생성합니다.

구조체 인스턴스를 생성하는 코드를 더 자세히 뜯어보도록 하겠습니다.

```swift
final class DefaultPoseFeedRepository: PoseFeedRepository {
    let networkService: NetworkService

    init(networkService: NetworkService) {
        self.networkService = networkService
    }

    func fetchFeedContents() -> Observable<[Section<PoseFeedPhotoCellViewModel>]> {
        networkService
            .requestSingle(.retrieveFilteringPoseFeed(peopleCount: peopleCount, frameCount: frameCount, filterTags: filterTags, pageNumber: pageNumber))
            .asObservable()
            .withUnretained(self)
            .flatMapLatest { (owner, filteredContents: FilteredPose) -> Observable<[Section<PoseFeedPhotoCellViewModel>]> in
                return Observable.combineLatest(
                    owner.cacheItem(for: filteredContents.filteredContents),
                    owner.cacheItem(for: filteredContents.recommendedContents)
                )
                .flatMapLatest { filterSection, recommendSection in
                    let relay = BehaviorRelay<[Section<PoseFeedPhotoCellViewModel>]>(value: [
                        Section(header: "", items: filterSection),
                        Section(header: "이런 포즈는 어때요?", items: recommendSection)
                    ])

                    return relay.asObservable()
                }
            }
    }

    private func cacheItem(for contents: [Pose]) -> Observable<[PoseFeedPhotoCellViewModel]> {
        let viewModelObservable = BehaviorRelay<[PoseFeedPhotoCellViewModel]>(value: [])

        contents.forEach { pose in
            ImageCache.default.retrieveImageInDiskCache(forKey: pose.poseInfo.imageKey) { result in
                switch result {
                case .success(let value):
                    if let image = value?.images?.first {
                        let viewModel = PoseFeedPhotoCellViewModel(image: image)
                        viewModelObservable.accept(viewModelObservable.value + [viewModel])
                    } else if let url = URL(string: pose.poseInfo.imageKey) {
                        KingfisherManager.shared.retrieveImage(with: url) { downloadResult in
                            switch downloadResult {
                            case .success(let downloaded):
                                let viewModel = PoseFeedPhotoCellViewModel(image: downloaded.image)
                                viewModelObservable.accept(viewModelObservable.value + [viewModel])
                            case .failure(let error):
                                print("error in first: ", error)
                                return
                            }
                        }
                    }
                case .failure:
                    return
                }
            }
        }

        return viewModelObservable.skip(while: { $0.count < contents.count }).asObservable()
    }
}
```

먼저 페이지네이션이 적용된 서버로부터 포즈 정보를 8개씩 묶어서 전달받습니다. 각 포즈에는 이미지가 저장된 S3 버킷 URL 정보가 담겨있습니다.

JSON 디코딩을 마쳐 URL 값을 불러왔다면, 8개 이미지 URL을 키값으로 하여 캐시 접근을 진행합니다. **캐시 히트인 경우** 이미지 데이터를 UIImage 객체로 로드하여 뷰모델을 생성해준다. **캐시 미스인 경우** 이미지를 다운로드합니다.

위 동작이 `cacheItem`함수에서 이루어지는데, 해당 함수는 클로저를 통해 캐시 접근과 관련된 비동기 작업들을 진행합니다. 중첩 클로저를 통해 이미지 다운로드 태스크가 또 다른 큐로 배치됩니다.

이 모든 작업들을 마칠 때까지 옵저버블은 뷰모델 데이터를 방출하지 않습니다. 중첩 클로저에 전달되는 파라미터를 캡처하게 되는데, `Pose` 모델 데이터가 구조체로 모두 값 타입이기 때문에 직접 주소를 참조하게 됩니다.

클로저 파라미터의 원본을 그대로 참조하고 있어야 변경되는 데이터를 계속해서 참조하게 됩니다. `contents.forEach` 함수 호출 후 스택 프레임 내에 지역변수로 할당된 `pose`값의 원본을 계속해서 참조하는 것입니다.

`forEach` 클로저 자체는 동기적으로 동작하는 코드이기 때문에 전체 비동기 태스크를 킹피셔에서 생성한 `ioQueue`에 할당합니다.

`retrieveImageInDiskCache` 클로저 호출 후 이미지를 성공적으로 불러왔다면 이미지와 함께 새로운 뷰모델 객체 생성 후 클로저를 종료합니다.

```swift
ioQueue = DispatchQueue(label: ioQueueName)
```

라이브러리의 ioQueue 코드를 보면 기본적으로 큐 어트리뷰트가 설정되어 있지 않은 것을 볼 수 있다. 속성값을 지정하지 않으면 자동으로 직렬 큐가 됩니다.

> attributes - Apple Document
> The attributes to associate with the queue. Include the concurrent attribute to create a dispatch queue that executes tasks concurrently. If you omit that attribute, the dispatch queue executes tasks serially.

따라서 바깥 클로저의 `retrieveImageInDiskCache`비동기 태스크가 ioQueue에 푸시되고, 그 다음 내부 클로저가 동일하게 `ioQueue`에 푸시됩니다.

:::tip 태스크 실행되고 있는 큐 이름 출력하기

```swift
print(String(cString: __dispatch_queue_get_label(nil), encoding: .utf8))
```

:::

## 문제점

직렬 큐 기반으로 동작하게 되면서 뷰모델 skip 오퍼레이터가 적용된 옵저버블의 참조가 최종적으로 리턴되는데, 이때 모든 작업이 순차적으로 마무리 될때까지 기다리게 됩니다.

8개의 이미지가 캐시 히트 혹은 캐시 미스 이후 다운로드가 완료될 때까지 기다린다는 것인데, 로딩 인디케이터만 띄워놓는 것이지 사실상 사용자에게 비동기적인 이점을 하나도 살리지 못하게 되는 것입니다.

## Reference

1. [Medium - How to simulate poor network conditions on iOS Simulator and iPhone](https://medium.com/macoclock/how-to-simulate-poor-network-conditions-on-ios-simulator-and-iphone-faf35f0da1b5)
2. [Apple Document - init(label:qos:attributes:autoreleaseFrequency:target:)](https://developer.apple.com/documentation/dispatch/dispatchqueue/2300059-init)
