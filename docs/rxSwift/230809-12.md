---
title: RxSwift - RxCocoa Common Patterns
---

## TableView

`RxCocoa`에서는 델리게이트를 사용하지 않는다. 옵저버블을 뷰에 바인딩하는 방식으로 처리한다. 주로 배열데이터를 테이블뷰에 바인딩하는 형태로 처리하게 되는데, 이때 RxCocoa TableView 익스텐션의 `items` 메서드를 사용하게 된다.

```swift
let nameObservable = Observable.of(appleProducts.map{ $0.name })
let productObservable = Observable.of(appleProducts)

nameObservable.bind(to: listTableView.rx.items) { tableView, row, element in
    let cell = tableView.dequeueReusableCell(withIdentifier: "standardCell")!
    cell.textLabel?.text = element
    return cell
}
.disposed(by: bag)
```

기본 셀을 사용하는 경우 `bind` 연산자를 사용하면 되고, 테이블뷰의 `rx.items`를 파라미터로 전달한다. 클로저에서는 소스 테이블뷰, row 인덱스, 바인딩되는 데이터가 파라미터로 할당된다.

```swift
nameObservable.bind(to: listTableView.rx.items(cellIdentifier: "standardCell")){ row, element, cell in
        cell.textLabel?.text = element
    }
    .disposed(by: bag)
```

셀 id값을 지정하는 경우 `cellIdentifier` 파라미터를 전달하면 된다.

```swift
productObservable.bind(to: listTableView.rx.items(cellIdentifier: "productCell", cellType: ProductTableViewCell.self)){ [weak self] row, element, cell in
    cell.categoryLabel.text = element.category
    cell.priceLabel.text = self?.priceFormatter.string(for: element.price)
    cell.productNameLabel.text = element.name
    cell.summaryLabel.text = element.summary
}
.disposed(by: bag)
```

커스텀 셀을 사용하는 경우 셀 아이디값과 `cellType`클래스 메타타입을 전달하면 된다.

아래는 테이블뷰 아이템 셀렉트 이벤트를 처리하는 코드이다. 드라이버를 사용하여 선택된 셀의 객체 `name`속성을 출력한다.

```swift
listTableView.rx.itemSelected.asDriver()
    .drive{ [weak self] in
        self?.listTableView.deselectRow(at: $0, animated: true)
        print(appleProducts[$0.row].name)
    }
    .disposed(by: bag)
```

컨트롤이벤트의 클로저 파라미터로 `IndexPath`가 자동으로 전달된다.

:::warning MVVM과 modelSelected

`modelSelected`는 뷰에서 바인딩하는 데이터를 옵저버블 형태로 생성해둔 모델을 기준으로 타입캐스팅을 진행한다.

```swift
 productObservable.bind(to: listTableView.rx.items(cellIdentifier: "productCell", cellType: ProductTableViewCell.self)){ [weak self] row, element, cell in
            // UI 바인딩 작업
        }
        .disposed(by: bag)
```

**모델에 직접 접근하는 방식은 올바르지 않다.** 데이터 접근권한이 뷰모델에만 존재하기 때문에 뷰 내에서 배열 형태로 데이터에 접근하는 방식보다는 **이벤트 방출시 나온 데이터를 직접 사용하는 것이 좋다.**

위의 코드를 개선하면 다음과 같다.

```swift
listTableView.rx.modelSelected(Product.self)
            .bind{ print($0.name) }
            .disposed(by: bag)
```

`modelSelected` 연산자를 사용하며, 파라미터에 메타타입을 전달한 뒤 바인딩을 진행한다.

테이블뷰 `deselect`를 위한 `IndexPath`데이터를 가져와야 한다면 `itemSelected` 컨트롤 이벤트의 클로저를 사용하면 된다. 이들 각각 따로 정의해도 괜찮지만, `zip` 연산자를 통해 하나의 옵저버블로 묶어도 된다.

`zip` 연산자는 indexed 시퀀싱을 기반으로 동작한다.

```swift
Observable.zip(listTableView.rx.modelSelected(Product.self), listTableView.rx.itemSelected)
    .bind{ [weak self] product, indexPath in
        print(product.name)
        self?.listTableView.deselectRow(at: indexPath, animated: true)
    }
    .disposed(by: bag)
```

:::

코코아터치 프레임워크 자체 델리게이트 프로토콜 채택 후 메서드 구현시 **RxCocoa를 기반으로 구현해둔 코드들은 동작하지 않게 된다.**

RxCocoa 기반에서 델리게이트를 지정하는 방법은 기존과 다르다. `rx.setDelegate(뷰컨)` 메서드를 사용한다. 델리게이트 설정 후 `dispose`까지 완료해야한다.

델리게이트 연결 방식에만 차이가 있고, 메서드 구현 방식은 이전처럼 프로토콜 채택 후 내부 구현을 진행하면 된다.

```swift
listTableView.rx.setDelegate(self)
    .disposed(by: bag)

extension RxCocoaTableViewViewController: UITableViewDelegate{
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        print("SELECTED")
    }
}
```

컬렉션뷰는 테이블뷰와 거의 유사하게 동작한다.
