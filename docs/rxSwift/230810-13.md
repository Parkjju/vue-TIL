---
title: RxSwift - Custom Extension
---

## Custom Binder

`Binder` 생성자 함수를 살펴보자.

```swift
public init<Target: AnyObject>(_ target: Target, scheduler: ImmediateSchedulerType = MainScheduler(), binding: @escaping (Target, Value) -> Void) {
    weak var weakTarget = target

    self.binding = { event in
        switch event {
        case .next(let element):
            _ = scheduler.schedule(element) { element in
                if let target = weakTarget {
                    binding(target, element)
                }
                return Disposables.create()
            }
        case .error(let error):
            rxFatalErrorInDebug("Binding error: \(error)")
        case .completed:
            break
        }
    }
}
```

1. `target`: 바인딩을 진행할 타겟 객체이다. 보통 UI 컴포넌트가 전달된다.
2. `scheduler`: UI 업데이트와 관련된 로직을 주로 수행하므로 스케줄러는 메인 스케줄러를 사용한다.
3. `binding`: 바인딩을 위한 클로저이다. 클로저 파라미터로 타겟 객체와 바인딩을 진행하는 값이 전달된다.

`next` 이벤트가 전달될때마다 클로저를 호출한다. 에러 호출시 디버그모드에서는 `fatalError`를 발생시키지만 릴리즈모드에서는 에러를 출력만 해준다.

아래는 바인더 클래스를 활용하여 실제로 구현되어 있는 `UILabel` 익스텐션이다.

```swift
public var text: Binder<String?> {
    return Binder(self.base) { label, text in
        label.text = text
    }
}
```

직접 바인딩 로직을 구현하는 예시 코드를 살펴보자.

```swift
extension Reactive where Base: UILabel{
    var segmentedValue: Binder<Int>{
        return Binder(self.base) { label, index in
            switch index{
            case 0:
                label.textColor = .red
                label.text = "Red"
            case 1:
                label.textColor = .green
                label.text = "Green"
            case 2:
                label.textColor = .blue
                label.text = "Blue"
            default:
                label.textColor = .black
                label.text = "Unknown"
            }
        }
    }
}
```

바인더 클래스는 옵저버이다. 이벤트를 방출하는 옵저버블에서 바인더 객체로 데이터를 방출하는 형태로 코드를 작성하면 된다.

```swift
// 컬러피커 seletedSegmentIndex는 ControlProperty<Int>를 방출하는 옵저버블
colorPicker.rx.selectedSegmentIndex
    .bind(to: self.valueLabel.rx.segmentedValue)
    .disposed(by: bag)
```

:::tip where

`where`는 Reactive 클래스의 제네릭 타입인 `Base`가 어떤 클래스일때 확장을 사용할 지에 대해 분기처리해줄 수 있다.

:::

## Custom ControlProperty

**get-only** 커스텀 속성이 필요하다면 바인더를 사용하고, 읽기 쓰기 모두 가능한 커스텀 속성이 필요하면 **커스텀 컨트롤 프로퍼티를 사용한다.**

```swift
whiteSlider.rx.value
    .map { UIColor(white: CGFloat($0), alpha: 1.0) }
    .bind(to: view.rx.backgroundColor)
    .disposed(by: bag)
```

위 코드를 보면 슬라이더 위치 변경에 따라 값이 next 이벤트로 방출된다. 방출되는 각각의 값을 map으로 UIColor와 매핑시킨다. 밸류-컬러 변환 로직을 컨트롤 프로퍼티를 통해 구현하게 된다.

```swift
extension Reactive where Base: UISlider {

    /// Reactive wrapper for `value` property.
    public var value: ControlProperty<Float> {
        return base.rx.controlPropertyWithDefaultEvents(
            getter: { slider in
                slider.value
            }, setter: { slider, value in
                slider.value = value
            }
        )
    }

}
```

1. 베이스 객체의 `controlPropertyWithDefaultEvents` 함수를 실행한다.
2. `getter`에서는 값을 리턴한다.
3. `setter`에서는 클로저 파라미터에 전달된 베이스 객체의 값을 세팅한다.

```swift
internal func controlPropertyWithDefaultEvents<T>(
    editingEvents: UIControl.Event = [.allEditingEvents, .valueChanged],
    getter: @escaping (Base) -> T,
    setter: @escaping (Base, T) -> Void
    ) -> ControlProperty<T> {
    return controlProperty(
        editingEvents: editingEvents,
        getter: getter,
        setter: setter
    )
}
```

위 함수를 보면 `controlPropertyWithDefaultEvents`의 파라미터는 세개이다. 첫번째 파라미터는 기본값으로 설정되어 있다. 함수 호출 즉시 `controlProperty`함수가 리턴되는데, 이 지점이 우리가 직접 구현할 부분이다.

```swift
public func controlProperty<T>(
    editingEvents: UIControl.Event,
    getter: @escaping (Base) -> T,
    setter: @escaping (Base, T) -> Void
) -> ControlProperty<T> {
    let source: Observable<T> = Observable.create { [weak weakControl = base] observer in
            guard let control = weakControl else {
                observer.on(.completed)
                return Disposables.create()
            }

            observer.on(.next(getter(control)))

            // 지정된 이벤트 감지때마다 next 방출, getter를 전달
            let controlTarget = ControlTarget(control: control, controlEvents: editingEvents) { _ in
                if let control = weakControl {
                    observer.on(.next(getter(control)))
                }
            }

            return Disposables.create(with: controlTarget.dispose)
        }
        .take(until: deallocated)

    // 바인더 생성 후 컨트롤 프로퍼티에 할당 및 리턴
    let bindingObserver = Binder(base, binding: setter)

    return ControlProperty<T>(values: source, valueSink: bindingObserver)
}
```

`controlProperty`의 `editingEvents`파라미터는 next이벤트를 방출하기 위한 이벤트이다.

커스텀 컨트롤 프로퍼티 익스텐션을 활용하여 실제 구현한 코드를 살펴보자.

```swift
extension Reactive where Base: UISlider{
    var color: ControlProperty<UIColor?> {
        return base.rx.controlProperty(editingEvents: .valueChanged) { slider in
            UIColor(white: CGFloat(slider.value), alpha: 1.0)
        } setter: { slider, color in
            var white = CGFloat(1)
            color?.getWhite(&white, alpha: nil)
            slider.value = Float(white)
        }

    }
}
```

1. 베이스 객체의 `controlProperty` 함수를 호출하며, 넥스트 이벤트를 방출할 이벤트를 지정한다.
2. getter와 setter를 각각 구현한다.

컨트롤프로퍼티 정의 후 실제 활용하는 코드이다.

```swift
whiteSlider.rx.color
    .bind(to: view.rx.backgroundColor)
    .disposed(by: bag)

resetButton.rx.tap
    .map{ UIColor(white:0.5, alpha: 1.0) }
    .bind(to: view.rx.backgroundColor.asObserver(), whiteSlider.rx.color.asObserver())
    .disposed(by: bag)
```

바인딩을 진행해주는데, 새로 정의한 슬라이더의 `color` 컨트롤 프로퍼티는 옵저버블이면서 옵저버이므로, 바인딩시 `asObserver`로 명시를 해줘야 한다. 이는 기본 컨트롤 프로퍼티인 `view.rx.backgroundColor`도 동일하다.

## Custom Event
