---
title: RxSwift - Transforming Operator
---

## toArray

ì˜µì €ë²„ë¸”ì˜ ë°©ì¶œë˜ëŠ” ì´ë²¤íŠ¸ë“¤ì„ ë°°ì—´ì— ë‹´ì•„ `onComplete`ê°€ í˜¸ì¶œë˜ëŠ” ì‹œì ì— í•´ë‹¹ ë°°ì—´ì„ í•œë²ˆì— ë°©ì¶œí•œë‹¤.

ì—ëŸ¬ê°€ ì „ë‹¬ë˜ë©´ ë°°ì—´ì— ë‹´ê²¼ë˜ ë°ì´í„°ëŠ” ë¬´ì‹œëœë‹¤.

`onCompleted`ê°€ ì „ë‹¬ë˜ê¸° ì „ê¹Œì§€ ì „ë‹¬ë˜ë˜ ìš”ì†Œë“¤ì€ ì´ë²¤íŠ¸ë¡œ ë°©ì¶œë˜ì§€ ì•Šê³  ë°°ì—´ë‚´ì— ì ì¬ë˜ê¸°ë§Œ í•œë‹¤.

```swift
let subject = PublishSubject<Int>()
subject
    .toArray()
    .subscribe{ print($0) }
    .disposed(by: disposeBag)

subject.onNext(0)
subject.onNext(1)
subject.onCompleted() // [0, 1]
```

## map

`map` í´ë¡œì €ì— ì „ë‹¬ë˜ëŠ” ë™ì‘ì— ë§ì¶° ìš”ì†Œë¥¼ ê°€ê³µí•˜ì—¬ êµ¬ë…ìì—ê²Œ ì „ë‹¬í•œë‹¤.

```swift
let skills = ["Swift", "SwiftUI", "RxSwift"]

Observable.from(skills)
    .map{ $0.count }
    .subscribe{ print($0) } // next(5) next(7) next(7)
    .disposed(by: disposeBag)
```

ìš”ì†Œê°€ ê°€ê³µëœ ë°ì´í„° íƒ€ì…ì€ ì†ŒìŠ¤ ì˜µì €ë²„ë¸”ì— ì „ë‹¬ë˜ëŠ” ìš”ì†Œ íƒ€ì…ì„ ë”°ë¼ê°ˆ í•„ìš”ê°€ ì—†ë‹¤. ìœ„ì—ì„œ `skills`ë¼ëŠ” ë³€ìˆ˜ ë‚´ì—ëŠ” `String`ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆì§€ë§Œ mapìœ¼ë¡œ ë¦¬í„´í•˜ëŠ” ë°ì´í„°ëŠ” `Int`í˜•ì´ë‹¤.

## compactMap

ê¸°ë³¸ ìŠ¤ìœ„í”„íŠ¸ì—ì„œë„ ì œê³µí•˜ëŠ” `compactMap`ê³¼ ë™ì‘ì´ ë™ì¼í•˜ë‹¤. ì˜µì…”ë„ ë°ì´í„°ê°€ í˜¼ì¬ëœ ë°°ì—´ì„ ìˆœíšŒí• ë•Œ ì˜µì…”ë„íƒ€ì…ì€ ì˜µì…”ë„ ë°”ì¸ë”©ì„ ì§„í–‰í•˜ì—¬ ì›ë³¸ ë°ì´í„°ë¥¼ ì¶”ì¶œí•´ì£¼ê³ , `nil`ê°’ì€ ë™ì‹œì— í•„í„°ë§ í•´ì£¼ëŠ” ì—­í• ì„ í•´ì¤€ë‹¤.

RxSwiftì—ì„œì˜ compactMapì€ ì´ì™€ ë™ì¼í•˜ê²Œ ì´ë²¤íŠ¸ ë°©ì¶œ ëŒ€ìƒì— ëŒ€í•´ ì˜µì…”ë„ ë°”ì¸ë”©ì„ ì§„í–‰í•˜ë©°, `nil`ê°’ì€ ì´ë²¤íŠ¸ë¡œ ë°©ì¶œí•˜ì§€ ì•Šê³  ë¬´ì‹œí•œë‹¤.

```swift
let subject = PublishSubject<String?>()

subject
    .compactMap{ $0 }
    .subscribe { print($0) }
    .disposed(by: disposeBag)

Observable<Int>.interval(.milliseconds(300), scheduler: MainScheduler.instance)
    .take(10)
    .map { _ in Bool.random() ? "â­ï¸" : nil }
    .subscribe(onNext: { subject.onNext($0) })
    .disposed(by: disposeBag)
```

1. 0.3ì´ˆë§ˆë‹¤ `Optional(â­ï¸)` ë˜ëŠ” `nil`ì„ ì´ë²¤íŠ¸ë¡œ ë°©ì¶œí•œë‹¤.
2. ì„œë¸Œì íŠ¸ì˜ `compactMap`ì„ í˜¸ì¶œí•˜ì—¬ ìµœì¢… êµ¬ë…ìì—ê²Œ ë°ì´í„°ë¥¼ ì „ë‹¬í• ë•Œ ì˜µì…”ë„ ë°”ì¸ë”© ë° `nil` í•„í„°ë§ì„ ì§„í–‰í•œë‹¤.
3. ë§¨ ì•„ë˜ ì˜µì €ë²„ë¸”ì—ì„œ ì˜µì…”ë„ ë¬¸ìì—´ë“¤ì„ ìì‹ ì˜ êµ¬ë…ìì¸ ì„œë¸Œì íŠ¸ë¡œ ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ê³ , ì´ë¥¼ ë‹¤ì‹œ `print($0)`ì„ ì§„í–‰í•˜ëŠ” êµ¬ë…ìì—ê²Œ ë°ì´í„°ë¥¼ ì „ë‹¬í•˜ëŠ” ë°©ì‹ì´ë‹¤.

## flatMap

<figure style="display:flex; align-items:center; flex-direction:column">
<img src="../.vuepress/assets/rxSwift/rx-3.png" height="80%" width="80%"/>
<figcaption style="font-size:1rem; color:grey; font-weight:bold; margin-top:0.8rem; margin-bottom:1rem;">ì¶œì²˜: https://reactivex.io/documentation/operators/flatmap.html</figcaption>
</figure>

`flatMap`ì€ ë°©ì¶œ ì´ë²¤íŠ¸ ìš”ì†Œë¥¼ ì •ì˜í•œ ë¡œì§ì— ë”°ë¼ ì—¬ëŸ¬ê°œì˜ ì˜µì €ë²„ë¸”ë¡œ ìª¼ê° ë‹¤. ì´í›„ ìµœì¢…ì ìœ¼ë¡œ ëª¨ë‘ë¥¼ í•œ ì˜µì €ë²„ë¸”ë¡œ ë¬¶ì–´ ë°©ì¶œí•œë‹¤.

1. ì—¬ëŸ¬ê°œë¡œ ìª¼ê°œì§€ëŠ” ì˜µì €ë²„ë¸”ì„ ì´ë„ˆ ì˜µì €ë²„ë¸”(Inner Observable)ì´ë¼ê³  í•œë‹¤.
2. ìµœì¢…ì ìœ¼ë¡œ ë°©ì¶œë˜ëŠ” ì˜µì €ë²„ë¸”ì„ ë¦¬ì ˆíŠ¸ ì˜µì €ë²„ë¸”(Result Observable)ì´ë¼ê³  í•œë‹¤.
3. ì´ëŸ¬í•œ ì¼ë ¨ì˜ ê³¼ì •ì„ í‰íƒ„í™”(Flattening)ë¼ê³  í•œë‹¤.

```swift
let redCircle = "ğŸ”´"
let greenCircle = "ğŸŸ¢"
let blueCircle = "ğŸ”µ"

let redHeart = "â¤ï¸"
let greenHeart = "ğŸ’š"
let blueHeart = "ğŸ’™"

Observable.from([redCircle, greenCircle, blueCircle])
    .flatMap{ circle -> Observable<String> in
        switch circle {
        case redCircle:
            return Observable.repeatElement(redHeart)
                .take(5)
        case greenCircle:
            return Observable.repeatElement(greenHeart)
                .take(5)
        case blueCircle:
            return Observable.repeatElement(blueHeart)
                .take(5)
        default:
            return Observable.just("")
        }
    }
    .subscribe{ print($0) }
    .disposed(by: disposeBag)
```

ë¦¬ì ˆíŠ¸ ì˜µì €ë²„ë¸”ì„ êµ¬ë…í•˜ì—¬ ë°©ì¶œëœ ì´ë²¤íŠ¸ë¥¼ ì¶œë ¥í•´ë³´ë©´ ê·¸ë“¤ ìˆœì„œê°€ ë’¤ì£½ë°•ì£½ì¸ ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.

ìœ„ì˜ ì˜ˆì‹œì—ì„œ í•˜íŠ¸ê°€ ë¹¨ê°„ìƒ‰ì´ ë¨¼ì € 5ê°œê°€ ì¶œë ¥ë˜ê³  ê·¸ ë‚˜ë¨¸ì§€ê°€ ì¶œë ¥ë˜ëŠ” ë°©ì‹ì´ ì•„ë‹Œ, ìˆœì„œ ìƒê´€ì—†ì´ ì²˜ë¦¬ë¨ì— ë”°ë¼ ê·¸ë•Œê·¸ë•Œ ìµœì¢… ì˜µì €ë²„ë¸”ì— í‘¸ì‹œë˜ëŠ” í˜•íƒœì´ë‹¤.

ì´ëŸ¬í•œ í˜„ìƒì„ ì¸í„°ë¦¬ë¹™(Interleaving)ì´ë¼ê³  í•œë‹¤.

## flatMapFirst

ìœ„ì˜ flatMapê³¼ ë™ì¼í•œ ì˜ˆì‹œì½”ë“œì—ì„œ `flatMapFirst`ë¡œë§Œ ì½”ë“œë¥¼ ìˆ˜ì •í•œë‹¤.

```swift
Observable.from([redCircle, greenCircle, blueCircle])
    .flatMapFirst{ circle -> Observable<String> in // FlatMapFirstë¡œ ìˆ˜ì •!
        switch circle {
        case redCircle:
            return Observable.repeatElement(redHeart)
                .take(5)
        case greenCircle:
            return Observable.repeatElement(greenHeart)
                .take(5)
        case blueCircle:
            return Observable.repeatElement(blueHeart)
                .take(5)
        default:
            return Observable.just("")
        }
    }
    // ... ë‚˜ë¨¸ì§€ ë™ì¼
```

1. `from` ì—°ì‚°ìë¥¼ í†µí•´ ë§¨ ì²˜ìŒ `redCircle`ë¬¸ìì—´ì´ ì°¸ì¡°ë˜ë©° flatMapìœ¼ë¡œ ì´ë„ˆ ì˜µì €ë²„ë¸”ì´ ë§Œë“¤ì–´ì§„ë‹¤.
2. ê°€ì¥ ì²˜ìŒ ë§Œë“¤ì–´ì§„ ì´ë„ˆì„œí´ì´ `redCircle`ì—ì„œ ë¶„ê¸°ì²˜ë¦¬ëœ ì˜µì €ë²„ë¸”ì´ë¯€ë¡œ, í•´ë‹¹ ì˜µì €ë²„ë¸”ì´ ì•„ë‹ˆë©´ ë‚˜ë¨¸ì§€ ì´ë²¤íŠ¸ë“¤ì€ ë°©ì¶œí•˜ì§€ ì•Šê³  ë¬´ì‹œëœë‹¤.

`flatMapFirst`ëŠ” **ì£¼ê¸°ê°€ ê²¹ì¹˜ë©´ ë‹¤ë¥¸ ì´ë²¤íŠ¸ë“¤ì€ ë¬´ì‹œëœë‹¤.** ì£¼ê¸°ê°€ ê²¹ì¹˜ì§€ ì•ŠëŠ” ì´ë²¤íŠ¸ê°€ ìƒˆë¡­ê²Œ ë°©ì¶œë˜ëŠ” ì‹œì ì— ì²˜ìŒ ë°©ì¶œëœ ì´ë²¤íŠ¸ë¥¼ ê°€ì§€ê³  ë‹¤ì‹œ í‰íƒ„í™”ë¥¼ ì§„í–‰í•œë‹¤.

```swift
let sourceObservable = PublishSubject<String>()

sourceObservable
    .flatMapFirst { circle -> Observable<String> in
        switch circle {
        case redCircle:
            return Observable<Int>.interval(.milliseconds(200), scheduler: MainScheduler.instance)
                .map { _ in redHeart}
                .take(10)
        case greenCircle:
            return Observable<Int>.interval(.milliseconds(200), scheduler: MainScheduler.instance)
                .map { _ in greenHeart}
                .take(10)
        case blueCircle:
            return Observable<Int>.interval(.milliseconds(200), scheduler: MainScheduler.instance)
                .map { _ in blueHeart}
                .take(10)
        default:
            return Observable.just("")
        }
    }
    .subscribe { print($0) }
    .disposed(by: disposeBag)

sourceObservable.onNext(redCircle)

DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
    sourceObservable.onNext(greenCircle)
}

DispatchQueue.main.asyncAfter(deadline: .now() + 6) {
    sourceObservable.onNext(blueCircle)
}
```

ìœ„ì˜ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê³¼ì •ìœ¼ë¡œ ì§„í–‰ëœë‹¤.

1. flatMapì„ ì‚¬ìš©í•˜ëŠ” ì˜µì €ë²„ë¸”ì„ ìƒì„±í•œë‹¤.
2. `onNext` ì´ˆê¸° ì´ë²¤íŠ¸ë¡œ `redCircle`ì´ ì „ë‹¬ëœë‹¤.
3. 0.2ì´ˆ ê°„ê²©ìœ¼ë¡œ `redCircle`ì´ `redHeart`ë¡œ ë³€í™˜ë˜ë„ë¡ í•˜ì—¬ ì´ë„ˆ ì˜µì €ë²„ë¸”ì„ ìƒì„±í•œë‹¤.
4. `onNext`ê°€ `redCircle`ë¡œ ì „ë‹¬ëœ ì‹œì  0.5ì´ˆ ì´í›„ `greenCircle`ì´ nextì´ë²¤íŠ¸ë¡œ ë°©ì¶œëœë‹¤.
5. ì´ë•Œ redCircleê¸°ì¤€ 0.2ì´ˆë§ˆë‹¤ redHeartê°€ ì´ë„ˆ ì˜µì €ë²„ë¸”ë¡œ ìƒì„±ë˜ëŠ” ì£¼ê¸° ì†ì— í¬í•¨ë˜ì–´ ìˆìœ¼ë¯€ë¡œ, `greenHeart`ëŠ” ë¬´ì‹œëœë‹¤.
6. redCircle - greenCircleë¡œ ì´ì–´ì§€ëŠ” ëª¨ë“  ì£¼ê¸°ë¥¼ ëë§ˆì¹œ ë’¤ `blueCircle`ì´ ì´ë²¤íŠ¸ë¡œ ë°©ì¶œëœë‹¤.
7. ì´ë„ˆ ì˜µì €ë²„ë¸” ìƒì„± í›„ `blueHeart`ê°€ 0.2ì´ˆ ê°„ê²©ìœ¼ë¡œ 10ë²ˆ ë°©ì¶œëœë‹¤.

`greenCircle`ì´ `onNext`ì „ë‹¬ë˜ë©´ì„œ `redCircle`ê³¼ ì£¼ê¸°ê°€ ì–´ì¤‘ê°„í•˜ê²Œ ê²¹ì¹˜ê²Œ ë˜ëŠ”ë°, `redCircle`ì´ 0~2ì´ˆê¹Œì§€ ì´ë²¤íŠ¸ ë°©ì¶œì´ ì§„í–‰ëœë‹¤ë©´ `greenCircle`ì€ 0.5~2.5ì´ˆê¹Œì§€ ì´ë²¤íŠ¸ ë°©ì¶œì´ ì´ë£¨ì–´ì§€ê²Œ ëœë‹¤.

ì´ë“¤ ì£¼ê¸°ê°€ ê²¹ì³ ì´ 0~2.5ì´ˆê°„ redCircleì´ ì•„ë‹Œ ì´ë“¤ì— ëŒ€í•´ì„œëŠ” ì´ë²¤íŠ¸ë¡œ ë°©ì¶œí•˜ì§€ ì•Šê³  ë¬´ì‹œëœë‹¤.

## flatMapLatest

`flatMapLatest`ëŠ” ìƒì„±ëœ ì´ë²¤íŠ¸ì¤‘ ê°€ì¥ ìµœê·¼ ì´ë²¤íŠ¸ì— ëŒ€í•´ì„œë§Œ ë°©ì¶œí•œë‹¤.

ê¸°ì¡´ê³¼ ë‹¤ë¥¸ ì´ë„ˆ ì˜µì €ë²„ë¸”ë¡œ ìƒì„±ë˜ëŠ” ê²½ìš° ê¸°ì¡´ ì˜µì €ë²„ë¸”ì€ ê·¸ ì¦‰ì‹œ ì¢…ë£Œëœë‹¤.

```swift
let sourceObservable = PublishSubject<String>()
let trigger = PublishSubject<Void>()

sourceObservable
    .flatMapLatest { circle -> Observable<String> in
        switch circle {
        case redCircle:
            return Observable<Int>.interval(.milliseconds(200), scheduler: MainScheduler.instance)
                .map { _ in redHeart}
                .take(until: trigger)
        case greenCircle:
            return Observable<Int>.interval(.milliseconds(200), scheduler: MainScheduler.instance)
                .map { _ in greenHeart}
                .take(until: trigger)
        case blueCircle:
            return Observable<Int>.interval(.milliseconds(200), scheduler: MainScheduler.instance)
                .map { _ in blueHeart}
                .take(until: trigger)
        default:
            return Observable.just("")
        }
    }
    .subscribe { print($0) }
    .disposed(by: disposeBag)

sourceObservable.onNext(redCircle)

DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
    sourceObservable.onNext(greenCircle)
}

DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
    sourceObservable.onNext(blueCircle)
}

DispatchQueue.main.asyncAfter(deadline: .now() + 10) {
    trigger.onNext(())
}
```

1. redCircleì„ ì´ë²¤íŠ¸ë¡œ ì „ë‹¬í•˜ë©´ 0.2ì´ˆ ê°„ê²©ìœ¼ë¡œ ë°©ì¶œëœë‹¤.
2. 1ì´ˆ ë’¤ greenCircleì´ ì´ë²¤íŠ¸ë¡œ ë°©ì¶œë˜ëŠ”ë°, ê¸°ì¡´ redCircle ì˜µì €ë²„ë¸”ê³¼ ë‹¤ë¥´ë¯€ë¡œ ë°©ì¶œë˜ê³  ìˆë˜ redCircle ì˜µì €ë²„ë¸”ì´ ì¢…ë£Œëœë‹¤.
3. 2ì´ˆ ë’¤ blueCircleì´ ì´ë²¤íŠ¸ë¡œ ë°©ì¶œë˜ëŠ”ë°, ê¸°ì¡´ greenCircle ì˜µì €ë²„ë¸”ê³¼ ë‹¤ë¥´ë¯€ë¡œ ë°©ì¶œë˜ê³  ìˆë˜ greenCircle ì˜µì €ë²„ë¸”ì´ ì¢…ë£Œëœë‹¤.
4. íŠ¸ë¦¬ê±° ì„œë¸Œì íŠ¸ì˜ nextì´ë²¤íŠ¸ ë°©ì¶œì— ë”°ë¼ `take(until:)` ì—°ì‚°ìê°€ ì‹¤í–‰ë˜ì–´ ì†ŒìŠ¤ ì˜µì €ë²„ë¸”ì´ ì¢…ë£Œëœë‹¤.

:::warning

`flatMapLatest`ëŠ” ê¸°ì¡´ ì˜µì €ë²„ë¸”ì„ ì¬ìƒì„±í•˜ëŠ” í˜•íƒœê°€ ì•„ë‹Œ ì¬ì‚¬ìš©í•˜ëŠ” í˜•íƒœì´ë‹¤. ì¬ì‚¬ìš© ê³¼ì •ì—ì„œ í˜„ì¬ ì˜µì €ë²„ë¸”ê³¼ ë‹¤ë¥¸ ë°ì´í„°ê°€ ë°©ì¶œ ëŒ€ìƒìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” ê²½ìš° í˜„ì¬ ì´ë„ˆ ì˜µì €ë²„ë¸”ì„ ì¢…ë£Œí•˜ê²Œ ë˜ëŠ” ê²ƒì´ë‹¤.

:::

## concatMap

`flatMap`ì€ ì¸í„°ë¦¬ë¹™ì„ í—ˆìš©í•œë‹¤. `concatMap`ì€ ìˆœì„œë¥¼ ë³´ì¥í•œë‹¤.

## scan

ëˆ„ì ì—°ì‚°ì„ ì²˜ë¦¬í• ë•Œ ì‚¬ìš©í•œë‹¤. ì‹œë“œê°’ì„ ì²«ë²ˆì§¸ íŒŒë¼ë¯¸í„°ë¡œ, ê³„ì‚° ë¡œì§ì„ accumulator íŒŒë¼ë¯¸í„°ë¡œ ë°›ëŠ”ë‹¤.

```swift
Observable.range(start: 1, count: 10)
    .scan(0, accumulator: { prev, next in
        return prev + next
    })
    .subscribe{ print($0) }
    .disposed(by: disposeBag)
```

## buffer

ë²„í¼ì—°ì‚°ìëŠ” ì´ë²¤íŠ¸ ë°©ì¶œ ì¡°ê±´ì„ ë§Œì¡±í•˜ê¸° ì „ê¹Œì§€ ì´ë²¤íŠ¸ë¥¼ ë³´ìœ í•  í•œê³„ë¥¼ ì •ì˜í•œë‹¤. ë²„í¼ ì—°ì‚°ìëŠ” ì„¸ê°€ì§€ íŒŒë¼ë¯¸í„°ë¥¼ ë°›ëŠ”ë‹¤. `timeSpan`, `count`, `scheduler`ì´ë‹¤.

1. `timeSpan`: ì–¼ë§ˆë‚˜ ì‹œê°„ë™ì•ˆ ì´ë²¤íŠ¸ë¥¼ ë²„í¼ì— ì €ì¥í•˜ê³  ìˆì„ì§€ë¥¼ ì§€ì •í•œë‹¤.
2. `count`: ìµœëŒ€ ëª‡ê°œì˜ ì´ë²¤íŠ¸ë¥¼ ë²„í¼ì— ì €ì¥í•˜ê³  ìˆì„ì§€ë¥¼ ê²°ì •í•œë‹¤.

`timeSpan` ë˜ëŠ” `count`ê°’ì„ ë‹¬ì„±í•˜ëŠ” ì¦‰ì‹œ ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ëŠ” í˜•íƒœì´ë‹¤.

```swift
Observable<Int>.interval(.seconds(1), scheduler: MainScheduler.instance)
    .buffer(timeSpan: .seconds(3), count: 3, scheduler: MainScheduler.instance)
    .take(5)
    .subscribe{ print($0) }
    .disposed(by: disposeBag)
```

1. ì¸í„°ë²Œ ì—°ì‚°ì ê²°ê³¼ ì˜µì €ë²„ë¸”ì„ 5ê°œê¹Œì§€ë§Œ ë°›ëŠ”ë‹¤.
2. ê° ì˜µì €ë²„ë¸”ë§ˆë‹¤ 3ê°œì˜ ì´ë²¤íŠ¸ê°€ ë°œìƒí•˜ê±°ë‚˜, 3ì´ˆê°€ ì§€ë‚œ ê²½ìš° ì´ë“¤ ìš”ì†Œë¥¼ ë°©ì¶œí•œë‹¤.

## window

ë²„í¼ì™€ ë™ì¼í•œ ê¸°ëŠ¥ì„ í•˜ì§€ë§Œ, ìœˆë„ìš° ì—°ì‚°ìëŠ” ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ í•´ë‹¹ ì´ë²¤íŠ¸ë¥¼ ë‹´ì€ ì˜µì €ë²„ë¸”ì„ ë¦¬í„´í•œë‹¤.

ì˜µì €ë²„ë¸”ì´ ì˜µì €ë²„ë¸”ì„ ë˜í•‘í•˜ëŠ” í˜•íƒœë¡œ ì¡´ì¬í•œë‹¤.

```swift
Observable<Int>.interval(.seconds(1), scheduler: MainScheduler.instance)
    .window(timeSpan: .seconds(2), count: 3, scheduler: MainScheduler.instance)
    .take(5)
    .subscribe{
        // ì´ë²¤íŠ¸ë¡œ ë°©ì¶œëœ ì˜µì €ë²„ë¸”ì„ ë‹¤ì‹œ êµ¬ë…í•˜ì—¬ ë‚´ë¶€ ìš”ì†Œë“¤ì„ ì¶œë ¥í•œë‹¤.
        if let observable = $0.element {
            observable.subscribe{ print("Inner : \($0)") }
        }
    }
    .disposed(by: disposeBag)
```

## groupBy

`groupBy` íŒŒë¼ë¯¸í„°ì— ì „ë‹¬ëœ ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ë™ì¼í•œ ìš”ì†Œë“¤ì„ ë¬¶ì–´ ì´ë„ˆì˜µì €ë²„ë¸”ì„ ë¦¬í„´í•œë‹¤.

```swift
let words = ["Apple", "Banana", "Orange", "Book", "City", "Axe"]

Observable.from(words)
    .groupBy{ $0.count }
    .subscribe(onNext: { groupedObservable in
        print("== \(groupedObservable.key)")
        groupedObservable.subscribe{ print("   ", $0)}
    })
    .disposed(by: disposeBag)
```

ë”•ì…”ë„ˆë¦¬ì™€ ìœ ì‚¬í•˜ê²Œ ë™ì‘í•œë‹¤ê³  ë³´ë©´ ëœë‹¤.

ìœ„ì˜ ì½”ë“œëŠ” ë¬¸ìì—´ ê¸¸ì´ë§ˆë‹¤ ê·¸ë£¹ì„ ì§€ì–´ ì´ë„ˆ ì˜µì €ë²„ë¸”ì„ ìƒì„±í•œë‹¤. `next`ì´ë²¤íŠ¸ ë°©ì¶œì‹œ ê·¸ë£¹í™”ëœ ì´ë„ˆ ì˜µì €ë²„ë¸”ì´ ì „ë‹¬ëœë‹¤.

í•´ë‹¹ ì´ë„ˆ ì˜µì €ë²„ë¸”ì˜ `key`ê°’ì— ì ‘ê·¼í•˜ë©´ í‚¤ê°’ì„ ì¶œë ¥í•  ìˆ˜ ìˆë‹¤.

ê·¸ë£¹ë°”ì´ ì—°ì‚°ìëŠ” ì£¼ë¡œ `flatMap`ê³¼ `toArray`ë¥¼ ë¬¶ì–´ ì‚¬ìš©í•œë‹¤.

```swift
Observable.from(words)
    .groupBy{ $0.count }
    .flatMap{ $0.toArray() }
    .subscribe{ print($0) }
    .disposed(by: disposeBag)

// next(["Book", "City"])
// next(["Banana", "Orange"])
// next(["Apple"])
// next(["Axe"])
```

í‚¤ì…€ë ‰í„°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë¬¶ì¸ ì´ë“¤ì„ ë°°ì—´ì— ë‹´ì•„ ì´ë„ˆ ì˜µì €ë²„ë¸”ì„ ìƒì„±í•œë‹¤. ì´ë“¤ì„ result ì˜µì €ë²„ë¸”ì— ë‹´ì•„ ìµœì¢…ì ìœ¼ë¡œ ì´ë²¤íŠ¸ë“¤ì„ ëª¨ë‘ ë°©ì¶œí•œë‹¤.

## Reference

1. [reactiveX - FlatMap](https://reactivex.io/documentation/operators/flatmap.html)
