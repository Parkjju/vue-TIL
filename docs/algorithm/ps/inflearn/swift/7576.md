---
title: BOJ 7576 - 토마토! (Swift)
tags: ['Algorithm']
---

[문제 링크](https://www.acmicpc.net/problem/7576)

## 풀이

1. BFS풀이
2. 플러드필 알고리즘 적용

```swift
import Foundation

let MN = readLine()!.split(separator: " ").map { Int($0)! }; let M = MN[1]; let N = MN[0]
var visited: [[Bool]] = .init(repeating: .init(repeating: false, count: 1005), count: 1005)
var adj: [[Int]] = .init(repeating: .init(repeating: -1, count: N+5), count: M+5)
var pos: [(Int, Int)] = []
let dy = [-1, 0, 1, 0]; let dx = [0, 1, 0, -1]
var ret = 0

struct Queue<T> {
    var array: [T?] = []
    var head = 0

    var isEmpty: Bool {
        return count == 0
    }

    var count: Int {
        return array.count - head
    }

    mutating func enqueue(_ element: T) {
        array.append(element)
    }

    mutating func dequeue() -> T? {
        guard head < array.count,
              let element = array[head] else { return nil }

        array[head] = nil
        head += 1

        let percentage = Double(head) / Double(array.count)
        if array.count > 50 && percentage > 0.25 {
            array.removeFirst(head)
            head = 0
        }

        return element
    }

    var front: T? {
        if isEmpty {
            return nil
        } else {
            return array[head]
        }
    }
}

var q = Queue<(Int, Int)>()

func bfs() {
    while !q.isEmpty {
        let qSize = q.count
        ret += 1
        for _ in 0..<qSize {
            guard let here = q.dequeue() else { return }
            for i in 0..<4 {
                let ny = dy[i] + here.0
                let nx = dx[i] + here.1

                if ny >= M || nx >= N || ny < 0 || nx < 0 || visited[ny][nx] || adj[ny][nx] == -1 || adj[ny][nx] == 1 {
                    continue
                }

                q.enqueue((ny, nx))
                adj[ny][nx] = 1
                visited[ny][nx] = true
            }
        }
    }
}

func check() -> Bool {
    for row in 0..<M {
        for col in 0..<N {
            if adj[row][col] == 0  {
                return false
            }
        }
    }

    return true
}

for row in 0..<M {
    adj[row] = readLine()!.split(separator: " ").enumerated().map { (col, value) in
        let tomato = Int(value)!
        if tomato == 1 {
            q.enqueue((row, col))
        }
        return tomato
    }
}

bfs()
print(check() ? ret - 1 : -1)
```
