---
title: BOJ 4179 - 불! (Swift)
tags: ['Algorithm']
---

[문제 링크](https://www.acmicpc.net/problem/4179)

## 풀이 (오답)

1. 지훈이 기준으로 BFS 진행
2. BFS 순회 과정에서 가장자리 닿은 경우 visited 좌표값이 최단거리이므로 리턴
3. 지훈이 4방향 이동 후에 불 퍼뜨리기
4. 지훈이의 다음 BFS는 불이 퍼진 뒤에 진행되는 상황

```swift
import Foundation

// 가장자리 좌표들 모아두기
// 지훈이 위치부터 가장자리까지 최단거리 계산하기
// 최단거리 중 최솟값 리턴하기

struct Queue<T> {
    var array: [T?] = []
    var head = 0

    var isEmpty: Bool {
        return count == 0
    }

    var count: Int {
        return array.count - head
    }

    mutating func enqueue(_ element: T) {
        array.append(element)
    }

    mutating func dequeue() -> T? {
        guard head < array.count,
              let element = array[head] else { return nil }

        array[head] = nil
        head += 1

        let percentage = Double(head) / Double(array.count)
        if percentage > 0.25 && head >= 50 {
            array.removeFirst(head)
            head = 0
        }

        return element
    }

    var front: T? {
        if isEmpty {
            return nil
        } else {
            return array[head]
        }
    }
}


let rc = readLine()!.split(separator: " ").map { Int($0)! }; let r = rc[0]; let c = rc[1]
var adj: [[String]] = .init(repeating: [], count: r); var visited: [[Int]] = .init(repeating: .init(repeating: 0, count: c), count: r)
var firePos: [(Int, Int)] = []

var jPos: (Int, Int) = (0,0)
let dy = [-1, 0, 1, 0]; let dx = [0, 1, 0, -1]

for i in 0..<r {
    adj[i] = readLine()!.map { String($0) }
    if let jIndex = adj[i].firstIndex(of: "J") {
        jPos = (i, Int(jIndex))
    }

    for (index, row) in adj[i].enumerated() {
        if row == "F" {
            firePos.append((i, index))
        }
    }
}

func fire() {
    var appendix: [(Int, Int)] = []
    for f in firePos {
        for i in 0..<4 {
            let ny = dy[i] + f.0
            let nx = dx[i] + f.1

            if ny < 0 || nx < 0 || ny >= r || nx >= c || adj[ny][nx] == "#" || adj[ny][nx] == "F" {
                continue
            }
            adj[ny][nx] = "F"
            appendix.append((ny, nx))
        }
    }
    firePos += appendix
}

func bfs(_ here: (Int, Int)) -> Int? {
    visited[here.0][here.1] = 1
    var q = Queue<(Int, Int)>()
    q.enqueue(here)

    while(!q.isEmpty) {
        guard let there = q.dequeue() else { return nil }

        for i in 0..<4 {
            let ny = dy[i] + there.0
            let nx = dx[i] + there.1

            if ny < 0 || nx < 0 || ny >= r || nx >= c || visited[ny][nx] != 0 || adj[ny][nx] == "#" || adj[ny][nx] == "F" {
                continue
            }

            visited[ny][nx] = visited[there.0][there.1] + 1

            if ny == 0 || nx == 0 || ny == r - 1 || nx == c - 1 {
                return visited[ny][nx]
            }
            q.enqueue((ny, nx))
        }
        fire()
    }

    return nil
}

let result = bfs(jPos)
print(result ?? "IMPOSSIPLE")
```

## 2차 풀이 (오답)

1. 그래프 뎁스별로 4방향 조회를 모두 진행하고 해당 과정에서 탈출 가능한 경우 최단거리 리턴
2. 뎁스 모두 조회했을때도 여전히 탈출 못했으면 4방향 불지르기

```swift
import Foundation

// 가장자리 좌표들 모아두기
// 지훈이 위치부터 가장자리까지 최단거리 계산하기
// 최단거리 중 최솟값 리턴하기

struct Queue<T> {
    var array: [T?] = []
    var head = 0

    var isEmpty: Bool {
        return count == 0
    }

    var count: Int {
        return array.count - head
    }

    mutating func enqueue(_ element: T) {
        array.append(element)
    }

    mutating func dequeue() -> T? {
        guard head < array.count,
              let element = array[head] else { return nil }

        array[head] = nil
        head += 1

        let percentage = Double(head) / Double(array.count)
        if percentage > 0.25 && head >= 50 {
            array.removeFirst(head)
            head = 0
        }

        return element
    }

    var front: T? {
        if isEmpty {
            return nil
        } else {
            return array[head]
        }
    }
}


let rc = readLine()!.split(separator: " ").map { Int($0)! }; let r = rc[0]; let c = rc[1]
var adj: [[String]] = .init(repeating: [], count: r); var visited: [[Int]] = .init(repeating: .init(repeating: 0, count: c), count: r)
var firePos: [(Int, Int)] = []

var jPos: (Int, Int) = (0,0)
let dy = [-1, 0, 1, 0]; let dx = [0, 1, 0, -1]
var depth = 1; var fireDepth = 0

for i in 0..<r {
    adj[i] = readLine()!.map { String($0) }
    if let jIndex = adj[i].firstIndex(of: "J") {
        jPos = (i, Int(jIndex))
    }

    for (index, row) in adj[i].enumerated() {
        if row == "F" {
            firePos.append((i, index))
        }
    }
}

func fire() {
    var appendix: [(Int, Int)] = []
    for f in firePos {
        for i in 0..<4 {
            let ny = dy[i] + f.0
            let nx = dx[i] + f.1

            if ny < 0 || nx < 0 || ny >= r || nx >= c || adj[ny][nx] == "#" || adj[ny][nx] == "F" {
                continue
            }
            adj[ny][nx] = "F"
            appendix.append((ny, nx))
        }
    }
    firePos += appendix
}

// BFS 뎁스 하나가 끝나고 불질러야됨
func bfs(_ here: (Int, Int)) -> Int? {
    visited[here.0][here.1] = 1
    var q = Queue<(Int, Int)>()
    q.enqueue(here)

    while(!q.isEmpty) {
        guard let there = q.front else { return nil }
        _ = q.dequeue()
//        print()
//        for row in adj {
//            for col in row {
//                print(col, terminator: "")
//            }
//            print()
//        }
        for i in 0..<4 {
            let ny = dy[i] + there.0
            let nx = dx[i] + there.1

            if ny < 0 || nx < 0 || ny >= r || nx >= c || visited[ny][nx] != 0 || adj[ny][nx] == "#" || adj[ny][nx] == "F" {
                continue
            }

            visited[ny][nx] = visited[there.0][there.1] + 1
            adj[ny][nx] = "J"

            depth += 1
            if depth > Int(pow(4.0, Double(fireDepth))) {
                fire()
                fireDepth += 1
            }

            if ny == 0 || nx == 0 || ny == r - 1 || nx == c - 1 {
                return visited[ny][nx]
            }
            q.enqueue((ny, nx))
        }

//        for row in adj {
//            for col in row {
//                print(col, terminator: "")
//            }
//            print()
//        }
    }

    return nil
}

let result = bfs(jPos)
print(result ?? "IMPOSSIPLE")
```
